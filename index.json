[{"content":"RAG는 죽지 않았습니다. 다만 \u0026ldquo;문서를 잘라서 벡터 DB에 넣고 Top-k만 붙이는 단순 RAG\u0026quot;가 빠르게 한계를 드러내고 있습니다.\n이 글은 아래 영상을 바탕으로, 왜 단순 RAG가 흔들리는지와 지금 바로 적용할 수 있는 개선 패턴을 정리한 실전 노트입니다.\n영상: 아직도 RAG 쓰세요? 이거 보고 나면 멈춥니다 채널: 메이커 에반 | Maker Evan 3줄 요약 문제는 RAG 자체가 아니라, 문맥이 끊기는 단순 청킹 중심 RAG입니다. 개선의 핵심은 하이브리드 검색 + 검색 후 검증 + 청크에 맥락 주석(Contextual Retrieval)입니다. 문서량이 작을 때는 Long Context 직접 주입이 빠르지만, 비용·확장성·중간 구간 누락 리스크를 같이 봐야 합니다. flowchart LR A[단순 RAG 청킹 + 벡터검색] --\u003e B[문맥 손실] B --\u003e C[검색은 됐는데 답이 틀림] C --\u003e D[운영 불신 증가] D --\u003e E[개선 필요]왜 단순 RAG에서 오답이 늘어날까 영상에서 강조하는 핵심은 \u0026ldquo;문서를 자르는 순간 의미의 좌표가 사라진다\u0026quot;는 점입니다.\n예를 들어 \u0026ldquo;마케팅 비용이 전 분기 대비 15% 증가\u0026quot;라는 문장만 떼어 놓으면, 어느 회사인지, 어느 분기인지, 어떤 기준인지가 사라집니다.\nflowchart TD D0[원본 문서] --\u003e D1[청킹] D1 --\u003e C1[청크 A 마케팅 비용 15% 증가] D1 --\u003e C2[청크 B 2024 Q3 A기업] D1 --\u003e C3[청크 C 비교 기준/주석] Q[사용자 질문] --\u003e R[벡터 검색 Top-k] R --\u003e C1 C1 --\u003e L[LLM] L --\u003e O[맥락 부족한 답변]즉, 검색 히트율과 정답률은 다릅니다. \u0026ldquo;비슷한 문장\u0026quot;을 찾는 것만으로는 \u0026ldquo;정확한 문맥\u0026quot;까지 보장되지 않습니다.\n영상에서 제시한 개선 전략 1: 하이브리드 검색 의미 기반 검색(semantic)과 키워드 기반 검색(keyword)을 함께 써야 누락이 줄어듭니다.\n의미 기반: 표현이 달라도 의도가 비슷한 문서를 찾음 키워드 기반: 고유명사/정확 용어(예: 삼성전자, 계약번호)를 놓치지 않음 flowchart LR Q[질문] --\u003e S1[Semantic Search] Q --\u003e S2[Keyword Search] S1 --\u003e M[결과 병합] S2 --\u003e M M --\u003e RR[Re-rank / 관련성 검증] RR --\u003e K[최종 컨텍스트] K --\u003e L[LLM 응답]여기서 중요한 포인트는 \u0026ldquo;검색 후 검증(Re-rank)\u0026rdquo; 단계입니다. 검색 결과를 그대로 넣지 말고, 한 번 더 관련도를 점검해 노이즈를 줄여야 합니다.\n개선 전략 2: Contextual Retrieval(맥락 주석형 청킹) 영상에서 특히 강하게 추천하는 방식은 청크 앞에 \u0026ldquo;문서 내 위치/의미\u0026quot;를 짧게 붙여 저장하는 것입니다.\n예시:\n기존 청크: \u0026ldquo;마케팅 비용이 15% 증가했다\u0026rdquo; 맥락 주석 청크: \u0026ldquo;A기업 2024년 3분기 실적 보고서 중 마케팅 비용 분석 섹션: 마케팅 비용이 15% 증가했다\u0026rdquo; flowchart TB A[원본 단락] --\u003e B[청킹] B --\u003e C[청크별 맥락 주석 생성] C --\u003e D[(벡터/검색 저장소)] Q[질문] --\u003e E[검색] E --\u003e F[맥락 포함 청크 회수] F --\u003e G[LLM] G --\u003e H[정확도 개선]영상 내 언급 기준으로, 이 접근은 검색 실패율을 크게 낮추는 효과가 보고됩니다. 핵심은 \u0026ldquo;청크를 작게 자르되, 의미의 꼬리표를 붙여 잃어버린 맥락을 복구\u0026quot;하는 것입니다.\n개선 전략 3: 요약본으로 찾고, 원문으로 답하기 실무에서 적용하기 쉬운 패턴은 다음 2단계입니다.\n각 단락을 요약해 \u0026ldquo;검색용 인덱스\u0026quot;를 만든다. 검색에 성공하면 실제 생성 단계에는 \u0026ldquo;요약이 아닌 원문\u0026quot;을 전달한다. sequenceDiagram participant Doc as 문서 저장소 participant Idx as 검색 인덱스(요약본) participant Ret as 리트리버 participant LLM as LLM Doc-\u003e\u003eIdx: 단락 요약 + 소제목 인덱싱 Ret-\u003e\u003eIdx: 질문 기반 검색 Idx--\u003e\u003eRet: 요약본 Top-k Ret-\u003e\u003eDoc: 원문 단락 조회 Doc--\u003e\u003eRet: 원문 컨텍스트 Ret-\u003e\u003eLLM: 질문 + 원문 LLM--\u003e\u003eRet: 최종 답변이 구조는 속도와 정확도를 분리해 최적화한다는 점이 장점입니다.\n검색 단계: 가벼운 요약본으로 빠르게 생성 단계: 원문으로 깊고 정확하게 Long Context를 언제 쓸까 문서량이 작거나 태스크가 단기성이라면, 복잡한 RAG 파이프라인 없이 통째로 넣는 방식이 빠를 수 있습니다. 다만 영상에서 짚듯이 세 가지를 같이 봐야 합니다.\n비용: 토큰 사용량이 급증할 수 있음 확장성: 문서량이 커지면 전량 주입이 불가능해짐 품질: 긴 문맥에서 중간 구간 정보가 약해질 수 있음 flowchart TD S[시작] --\u003e D1{문서 총량이 작고 변경이 적은가?} D1 --\u003e|예| D2{지연시간/개발속도 최우선인가?} D2 --\u003e|예| C1[Long Context 직접 주입] D2 --\u003e|아니오| C2[경량 RAG + 검증] D1 --\u003e|아니오| D3{정확 근거 추적이 중요한가?} D3 --\u003e|예| C3[하이브리드 RAG + 맥락 주석] D3 --\u003e|아니오| C4[요약 검색 + 원문 전달]팀 적용용 체크리스트 아래 항목 5개만 적용해도 단순 RAG 대비 체감 품질이 빠르게 올라갑니다.\n청킹 전에 문서 구조(장/절/표/주석)를 보존할 수 있는지 점검 Semantic + Keyword 하이브리드 검색 기본값으로 설정 검색 후 Re-rank 또는 관련성 필터 단계 추가 청크 저장 시 맥락 주석(문서명/섹션/시점/주체) 붙이기 검색 인덱스와 생성 컨텍스트를 분리(요약 검색 + 원문 전달) 결론 \u0026ldquo;RAG is dead\u0026quot;의 정확한 해석은 \u0026ldquo;단순 RAG의 시대가 끝나고 있다\u0026quot;에 가깝습니다.\n앞으로의 기준은 더 선명합니다.\n문서가 작고 빠른 실험이 필요하면: Long Context 우선 문서가 크고 운영이 중요하면: 하이브리드 RAG + Contextual Retrieval 둘 사이에서는: 요약 검색 + 원문 전달 패턴으로 현실적인 균형 결국 승부는 모델 이름이 아니라, 문맥을 어떻게 설계하고 전달하느냐에서 납니다.\n참고 아직도 RAG 쓰세요? 이거 보고 나면 멈춥니다 (YouTube) 메이커 에반 | Maker Evan ","date":"2026-02-20","permalink":"/post/2026/2026-02-20-rag-contextual-retrieval-practical-guide/","section":"post","summary":"RAG는 죽지 않았습니다. 다만 \u0026ldquo;문서를 잘라서 벡터 DB에 넣고 Top-k만 붙이는 단순 RAG\u0026quot;가 빠르게 한계를 드러내고 있습니다.\n이 글은 아래 영상을 바탕으로, 왜 단순 RAG가 흔들리는지와 지금 바로 적용할 수 있는 개선 패턴을 정리한 실전 노트입니다.\n영상: 아직도 RAG 쓰세요? 이거 보고 나면 멈춥니다 채널: 메이커 에반 | Maker Evan ","title":"아직도 RAG 쓰세요? 단순 RAG는 줄이고, Contextual Retrieval로 올리는 실전 가이드"},{"content":"웹서버를 처음 고를 때 가장 자주 나오는 질문이 있습니다.\n\u0026ldquo;Nginx를 써야 할까, Caddy를 써도 될까?\u0026rdquo;\n이 글은 같은 요구사항을 두 서버 설정으로 나란히 보여주면서, 어디서 차이가 나는지 직관적으로 설명합니다.\n한눈에 보는 차이 flowchart LR R[요구사항HTTPS + 프록시 + 정적서빙] --\u003e N[Nginx강력한 범용성] R --\u003e C[Caddy단순한 운영] N --\u003e N1[인증서 발급/갱신 경로를 직접 설계] N --\u003e N2[세부 튜닝 자유도 높음] C --\u003e C1[Automatic HTTPS 기본 제공] C --\u003e C2[Caddyfile로 짧은 설정]핵심만 먼저 정리하면:\nNginx: 세밀한 제어와 생태계가 강점, 대신 초기 구성과 운영 포인트가 많습니다. Caddy: 기본값이 좋아서 빠르게 서비스 열기 좋고, HTTPS 자동화가 특히 편합니다. 비교 시나리오 아래 3가지를 같은 조건으로 비교합니다.\napp.example.com을 localhost:3000으로 프록시 HTTPS 적용 정적 파일(/var/www/site) 서빙 1) 리버스 프록시: 같은 기능, 다른 설정 밀도 Nginx 예제 server { listen 80; server_name app.example.com; location / { proxy_pass http://127.0.0.1:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } Caddy 예제 app.example.com { reverse_proxy 127.0.0.1:3000 } 둘 다 같은 역할이지만, Caddy는 기본 프록시 헤더 처리와 HTTPS 연계가 자연스럽게 이어져 설정이 짧습니다.\n2) HTTPS: 운영 난이도 차이가 크게 나는 지점 Nginx 예제 (인증서 설정 포함) server { listen 80; server_name app.example.com; return 301 https://$host$request_uri; } server { listen 443 ssl http2; server_name app.example.com; ssl_certificate /etc/letsencrypt/live/app.example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/app.example.com/privkey.pem; location / { proxy_pass http://127.0.0.1:3000; } } Nginx는 보통 Certbot 같은 도구와 갱신 스케줄을 별도로 운영합니다.\nCaddy 예제 (Automatic HTTPS) app.example.com { reverse_proxy 127.0.0.1:3000 } 공개 DNS가 올바르게 연결된 도메인이라면, Caddy가 인증서 발급/갱신/적용을 자동으로 처리합니다.\nflowchart TD D[도메인 DNS 연결] --\u003e S[Caddy 시작] S --\u003e A[ACME 챌린지 수행] A --\u003e I[인증서 발급] I --\u003e T[TLS 적용] T --\u003e R[자동 갱신]3) 정적 파일 서빙: 문법 차이 Nginx 예제 server { listen 80; server_name static.example.com; root /var/www/site; index index.html; location / { try_files $uri $uri/ =404; } } Caddy 예제 static.example.com { root * /var/www/site file_server } 기본 정적 사이트 운영에서는 Caddy 문법이 더 읽기 쉽고, 작은 팀에서 유지보수 부담이 낮습니다.\nCaddy 사용법: 처음부터 운영까지 여기서는 Linux 서버 기준으로 가장 단순한 흐름만 정리합니다.\n1) 설치 공식 문서를 기준으로 배포판별 설치 방법을 사용합니다.\nCaddy Docs: https://caddyserver.com/docs/install 2) Caddyfile 작성 /etc/caddy/Caddyfile 예시:\napp.example.com { reverse_proxy 127.0.0.1:3000 } 3) 설정 검증 caddy fmt --overwrite /etc/caddy/Caddyfile caddy validate --config /etc/caddy/Caddyfile 4) 서비스 실행/재시작 sudo systemctl enable caddy sudo systemctl restart caddy sudo systemctl status caddy 5) 로그 확인 sudo journalctl -u caddy -f 운영 관점에서 중요한 점은 \u0026ldquo;설정이 짧다\u0026quot;보다 \u0026ldquo;HTTPS 갱신 운영이 자동화된다\u0026quot;는 부분입니다.\n언제 Caddy를 선택하면 좋은가? 소규모/중간 규모 서비스에서 빠르게 HTTPS까지 안정적으로 열고 싶을 때 Nginx 고급 튜닝보다 운영 단순성이 더 중요할 때 인프라 담당자가 적어 인증서 갱신 자동화의 가치가 클 때 언제 Nginx가 더 적합한가? 이미 Nginx 중심 운영 표준(템플릿, 모듈, 모니터링)이 자리잡은 조직 매우 세밀한 트래픽 제어/고급 라우팅/기존 에코시스템 결합이 필요한 경우 결론 둘 중 \u0026ldquo;절대 우위\u0026quot;는 없습니다.\n빠른 시작과 단순한 HTTPS 운영이 목표라면 Caddy가 유리하고, 강한 제어권과 기존 운영 자산을 활용해야 하면 Nginx가 유리합니다. 처음 도입 단계라면, 같은 서비스에 대해 두 설정을 직접 작성해 보고 팀의 운영 부담이 어디서 줄어드는지 비교해 보는 것이 가장 현실적인 선택 방법입니다.\n참고 자료 Caddy Docs - Automatic HTTPS: https://caddyserver.com/docs/automatic-https Caddy Docs - Caddyfile Concepts: https://caddyserver.com/docs/caddyfile/concepts Caddy Docs - reverse_proxy Directive: https://caddyserver.com/docs/caddyfile/directives/reverse_proxy Caddy Docs - Install: https://caddyserver.com/docs/install Nginx Docs - Beginner\u0026rsquo;s Guide: https://nginx.org/en/docs/beginners_guide.html Nginx Docs - Reverse Proxy: https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/ Certbot Docs: https://certbot.eff.org/ ","date":"2026-02-19","permalink":"/post/2026/2026-02-19-caddy-vs-nginx-and-caddy-usage/","section":"post","summary":"웹서버를 처음 고를 때 가장 자주 나오는 질문이 있습니다.\n\u0026ldquo;Nginx를 써야 할까, Caddy를 써도 될까?\u0026rdquo;\n이 글은 같은 요구사항을 두 서버 설정으로 나란히 보여주면서, 어디서 차이가 나는지 직관적으로 설명합니다.\n","title":"Caddy vs Nginx 비교와 Caddy 사용법: 예제로 이해하는 웹서버 선택 가이드"},{"content":"Claude Code를 막 도입했거나, 쓰고는 있는데 결과 품질이 들쑥날쑥하다면 이 글을 먼저 읽어보세요. 이 포스트는 2026년 2월 기준 Opus 4.6 환경을 바탕으로, 설치부터 운영 자동화까지 실제로 바로 적용할 수 있는 핵심만 압축해 정리합니다.\n한눈에 보는 전체 지도 flowchart LR A[Part 1시작하기] --\u003e B[Part 2실전 워크플로우] B --\u003e C[Part 3자동화와 확장] C --\u003e D[부록단축키/액션/보안]이 글은 아래 순서로 진행합니다.\n시작하기: 설치, IDE, 토큰/컨텍스트, CLAUDE.md 실전 워크플로우: Task-Do-Verify, Plan Mode, 컨텍스트 관리 자동화/확장: Skill, MCP, Sub Agent, Agent Team Part 1. Claude Code 시작하기 Claude Code란? Claude Code는 Anthropic의 에이전틱 코딩 도구입니다. 터미널 중심으로 동작하며 코드 읽기, 파일 수정, 명령 실행, 도구 통합, Git 작업(커밋/브랜치/PR)까지 한 흐름에서 수행할 수 있습니다.\n구독 플랜 및 설치 플랜 가격 주요 특징 Pro $20/월 모든 기능 사용 가능, 사용량 제한 Max 5x $100/월 Pro의 5배 사용량, Opus 4.6, Agent Teams Max 20x $200/월 Pro의 20배 사용량, 최대 우선순위 API 종량제 사용량 기반 Sonnet 4.5: 입력 $3/1M, 출력 $15/1M 토큰 설치 명령어:\n# macOS / Linux / WSL curl -fsSL https://claude.ai/install.sh | bash # Windows PowerShell irm https://claude.ai/install.ps1 | iex # Homebrew brew install --cask claude-code Tip: 네이티브 설치는 Node.js 없이 동작하고 자동 업데이트가 포함됩니다.\n개발 환경(IDE) 설정 VS Code에서 Anthropic 공식 Claude Code 확장을 사용하는 방식이 가장 일반적입니다. 비슷한 이름의 비공식 확장은 보안 위험이 있을 수 있어 피하는 것이 안전합니다.\n영역 위치 역할 파일 탐색기 왼쪽 프로젝트 파일/폴더 탐색 코드 편집기 가운데 코드 확인/수정 Claude Code 채팅 오른쪽 또는 아래 지시 전달/결과 확인 토큰과 컨텍스트 윈도우 항목 의미 토큰(Token) AI가 텍스트를 처리하는 기본 단위 컨텍스트 윈도우 AI가 한 번에 기억 가능한 대화/문맥 범위 Opus 4.6 기준으로 컨텍스트 윈도우는 약 200,000 토큰입니다. 결국 핵심은 \u0026ldquo;큰 컨텍스트를 얼마나 효율적으로 운영하느냐\u0026quot;입니다.\n프로젝트 브레인: CLAUDE.md CLAUDE.md는 프로젝트 루트에서 Claude Code가 가장 먼저 읽는 지침서입니다. 기술 스택, 코드 스타일, 구조, 작업 규칙을 이 파일에 고정하면 세션마다 재설명 비용이 크게 줄어듭니다.\nflowchart TD U[사용자 요청] --\u003e G[Global CLAUDE.md] G --\u003e P[Project CLAUDE.md] P --\u003e A[Admin/Org 정책] A --\u003e R[최종 동작 규칙]작성 실전 팁:\n가장 중요한 규칙을 파일 맨 위에 둡니다. API 문서는 통째로 붙이지 말고 핵심 규칙만 요약합니다. 같은 실수가 반복되면 그때 규칙을 추가합니다. 오래된 규칙은 주기적으로 정리합니다. Rules 폴더와 Auto Memory .claude/rules/에 주제별 규칙 파일을 분리하면 관리가 쉬워집니다.\n.claude/ rules/ workflow.md design-rules.md technical-defaults.md MEMORY.md 자동 메모리를 함께 쓰면 세션이 바뀌어도 중요한 맥락을 이어가기 좋습니다.\nPart 2. 실전 개발 워크플로우 Task-Do-Verify 루프 AI 코딩의 기본은 Task -\u0026gt; Do -\u0026gt; Verify 반복입니다.\nflowchart LR T[Task작업 지시] --\u003e D[DoAI 실행] D --\u003e V[Verify결과 검증] V --\u003e T검증을 생략하면 초반엔 빨라 보여도 후반에 Context Rot로 품질이 급격히 흔들립니다.\nContext Rot 방지 포인트 단계마다 테스트/실행 결과를 확인합니다. 실패 원인과 수정 내용을 짧게라도 기록합니다. 긴 세션은 /compact로 정리하고, 큰 전환 시 /clear를 고려합니다. 병렬 작업과 Hook 시스템 병렬 작업은 3~4개 정도가 실전에서 효율적입니다. Hook은 특정 이벤트에서 자동 실행되는 스크립트로, 반복 실수를 방지하는 강제 장치로 쓰기 좋습니다.\nHook 이벤트 시점 활용 예시 PreToolUse 도구 실행 전 보호 파일 편집 차단 PostToolUse 도구 실행 후 포맷팅/정적 검사 Stop 응답 완료 시 완료 알림 Notification 알림 전송 시 OS 알림 연동 SessionStart 세션 시작 시 환경 초기화 UserPromptSubmit 프롬프트 제출 시 입력 정책 검증 종료 코드 해석:\nExit 0: 진행 허용 Exit 2: 진행 차단 + 오류 피드백 기타: 진행되지만 stderr는 로그로만 기록 4가지 권한 모드 모드 설명 추천 기본 모드 파일 변경마다 승인 안전 최우선 자동 수정 모드 기존 파일 자동 수정, 새 파일 확인 초보자 권장 Bypass Permissions 권한 대부분 위임 격리 환경에서만 Plan Mode 설계 우선, 코드 수정 불가 복잡 작업 필수 Bypass Permissions는 반드시 주의해서 사용해야 합니다. 격리되지 않은 환경에서의 무분별한 사용은 큰 손실로 이어질 수 있습니다.\nPlan Mode 활용법 복잡한 작업일수록 \u0026ldquo;바로 구현\u0026quot;보다 \u0026ldquo;먼저 계획\u0026quot;이 결과 품질과 속도를 동시에 올립니다.\nflowchart TD A[코드베이스 분석] --\u003e B[질문/가정 정리] B --\u003e C[구현 계획 작성] C --\u003e D[사용자 검토/승인] D --\u003e E[코드 작성]실무 체감으로는 1분 계획이 10분 디버깅을 줄여주는 경우가 흔합니다.\n컨텍스트 관리 전략 전략 설명 /context 현재 사용량 확인 /compact 대화 고밀도 압축 짧고 구체적인 프롬프트 토큰 절약 + 해석 오차 감소 Sub Agent 위임 메인 컨텍스트 보호 Extended Thinking 사고 토큰 누적 완화 모델 분리 운용 단순 작업 Sonnet, 복잡 작업 Opus Part 3. 자동화와 확장 Skill 시스템 Skill은 반복 작업을 재사용 가능한 작업 매뉴얼로 고정하는 방법입니다.\n.claude/skills/my-skill.skill.md --- name: my-skill description: 이 스킬의 간단한 설명 --- 실제 작업 단계... 핵심은 \u0026ldquo;자주 하는 일을 사람 기억이 아니라 파일 규칙으로 전환\u0026quot;하는 것입니다.\nMCP (Model Context Protocol) MCP는 Claude Code를 외부 서비스(Gmail, Slack, Notion, Sheets 등)와 연결하는 확장 메커니즘입니다.\n항목 MCP Skill 토큰 사용 상대적으로 큼 상대적으로 작음 처리 속도 서비스/네트워크 영향 큼 빠른 편 용도 연결/탐색/프로토타입 운영 자동화 추천 흐름: MCP로 검증 -\u0026gt; 반복되는 경로는 Skill/API 호출로 고정.\nSub Agent와 Agent Team Sub Agent는 특정 작업을 별도 컨텍스트로 위임하고 요약만 회수하는 모델입니다. Agent Team은 여러 에이전트가 상호 소통하며 협업하는 모델입니다.\nflowchart LR subgraph SA[Sub Agent] M[Main] --\u003e S1[Sub 1] M --\u003e S2[Sub 2] S1 --\u003e M S2 --\u003e M end subgraph AT[Agent Team] L[Lead] \u003c--\u003e|P2P 협업| T1[Teammate 1] L \u003c--\u003e|P2P 협업| T2[Teammate 2] T1 \u003c--\u003e|메시지| T2 L --\u003e B[Shared Task Board] T1 --\u003e B T2 --\u003e B endAgent Team 사용 시 핵심은 파일 충돌 없는 역할 분리입니다. 백엔드/프론트/테스트처럼 디렉토리 단위로 분업하면 안정성이 올라갑니다.\n비용과 활용 기준 Agent Team은 강력하지만 토큰 사용량이 단일 세션보다 크게 증가할 수 있습니다. 대형 리팩터링/보안 감사처럼 다각도 병렬 분석이 필요한 경우에 집중 투입하는 것이 효율적입니다. 부록 1) 주요 단축키 단축키 설명 Esc Claude 중지 Esc x 2 이전 메시지 목록 이동 Shift+Tab Plan Mode 전환 Cmd+T Extended Thinking 토글 Cmd+P 모델 선택기 Ctrl+G 외부 에디터 편집 Ctrl+O 상세 모드 토글 Ctrl+B 현재 작업 백그라운드 전환 부록 2) 오늘 바로 실행할 3가지 /init으로 CLAUDE.md를 만들고, 팀 규칙 3줄만 먼저 추가합니다. 다음 복잡 작업에서 Plan Mode를 먼저 거친 뒤 구현합니다. 매일 반복하는 작업 하나를 Skill로 분리해 자동화합니다. 부록 3) 보안 주의사항 AI가 생성한 코드에는 보안 취약점이 포함될 수 있습니다. 특히 결제, 인증, 개인정보 처리 기능은 배포 전 반드시 보안 검토를 거치세요. 도구의 생산성과 서비스의 안전성은 별개의 품질 게이트로 관리해야 합니다.\n마무리 Claude Code의 성능 차이는 모델 스펙보다 **운영 체계(규칙, 검증, 자동화, 분업)**에서 더 크게 발생합니다. 설치 후 바로 코드를 쓰기보다, CLAUDE.md와 검증 루프를 먼저 세팅하는 것이 가장 높은 ROI를 만듭니다.\n최신 내용은 공식 문서를 함께 확인하세요.\nAnthropic Docs Model Context Protocol ","date":"2026-02-18","permalink":"/post/2026/2026-02-18-claude-code-core-guide-opus-46/","section":"post","summary":"Claude Code를 막 도입했거나, 쓰고는 있는데 결과 품질이 들쑥날쑥하다면 이 글을 먼저 읽어보세요. 이 포스트는 2026년 2월 기준 Opus 4.6 환경을 바탕으로, 설치부터 운영 자동화까지 실제로 바로 적용할 수 있는 핵심만 압축해 정리합니다.\n","title":"Claude Code 핵심 가이드: 설치부터 Agent Team까지 (2026년 2월, Opus 4.6 기준)"},{"content":"AI 활용의 병목은 모델 자체보다, 모델이 일할 수 있는 환경 설계에 있다는 주장이 빠르게 힘을 얻고 있습니다.\n이 글은 아래 영상을 기반으로, 하니스 엔지니어링의 개념과 실무 적용 순서를 한 번에 정리한 레퍼런스 노트입니다.\n영상: https://www.youtube.com/watch?v=BssPGKsP60s\u0026amp;t=12s 채널: 메이커 에반 | Maker Evan 핵심 요약 프롬프트 엔지니어링은 \u0026ldquo;무엇을 물을까\u0026quot;에 집중한다. 컨텍스트 엔지니어링은 \u0026ldquo;무엇을 보여줄까\u0026quot;를 설계한다. 하니스 엔지니어링은 컨텍스트, 도구 연결, 스킬, 에이전트 설정까지 포함한 전체 운영 환경 설계다. 같은 모델도 하니스 품질에 따라 결과 격차가 크게 벌어진다. 실무 시작점은 컨텍스트 파일, MCP 연결, 스킬 파일 3가지다. flowchart LR P[프롬프트 엔지니어링\n무엇을 물을까] --\u003e C[컨텍스트 엔지니어링\n무엇을 보여줄까] C --\u003e H[하니스 엔지니어링\n전체 환경을 어떻게 설계할까]왜 하니스 엔지니어링이 등장했나 영상의 문제의식은 명확합니다. AI가 단일 Q\u0026amp;A에서 멈추지 않고, 다단계 작업을 스스로 수행하는 에이전트 모드로 넘어가면서 \u0026ldquo;질문 한 줄\u0026rdquo; 최적화만으로는 품질을 보장하기 어려워졌다는 점입니다.\nflowchart TD A[사용자 목표 입력] --\u003e B[에이전트 계획] B --\u003e C[도구 호출 1] C --\u003e D[도구 호출 2] D --\u003e E[도구 호출 N] E --\u003e F[중간 검증/수정] F --\u003e G[최종 산출물]즉, 이제는 모델이 똑똑한가보다 모델이 일할 수 있는 작업장(하니스)이 잘 설계됐는가가 더 중요해졌습니다.\n하니스 엔지니어링의 구성 요소 영상 기준으로 하니스는 아래 요소를 함께 다루는 개념입니다.\n프로젝트 지침 파일(예: CLAUDE.md) MCP 서버 설정(외부 도구 연결) 스킬 파일(작업별 전문 지식) 에이전트 설정(역할/책임 분리) mindmap root((Harness)) 프로젝트 지침 파일 MCP 서버 연결 스킬 파일 에이전트 구성 에러 복구 로직 승인/검토 흐름영상의 비유를 빌리면, 컨텍스트 엔지니어링이 \u0026ldquo;좋은 재료 고르기\u0026quot;라면 하니스 엔지니어링은 \u0026ldquo;주방 전체 설계\u0026quot;에 가깝습니다.\n핵심 주장: 모델이 아니라 하니스가 병목이다 영상에서 반복되는 메시지는 아래 한 줄로 요약됩니다.\n같은 모델도 어떤 환경에서 어떻게 운영하느냐에 따라 성과가 크게 달라진다.\nflowchart LR M[동일 모델] --\u003e H1[약한 하니스] M --\u003e H2[강한 하니스] H1 --\u003e R1[낮은 일관성\n높은 재시도] H2 --\u003e R2[높은 일관성\n낮은 운영비용]즉, \u0026ldquo;어떤 모델을 쓰느냐\u0026rdquo; 경쟁에서 \u0026ldquo;어떤 작업 환경을 설계했느냐\u0026rdquo; 경쟁으로 무게중심이 이동한 것입니다.\n영상 사례: OpenAI 내부 에이전트 운용에서 나온 교훈 영상에서는 OpenAI 내부 사례를 다음처럼 소개합니다.\nCodex 기반 에이전트만으로 내부 제품 개발 시도 초기에는 기대보다 느렸음 원인은 모델 성능보다 하니스 세팅 부족(도구 연결, 복구 로직, 운영 규칙) 하니스를 정비하면서 성과가 가속됨 또한 영상 내 수치로는 \u0026ldquo;5개월 동안 100만 줄 코드, 1500개 PR 머지\u0026rdquo; 같은 지표가 언급됩니다. 이 수치는 영상 화자의 제시 값으로 이해하는 것이 안전합니다.\nflowchart TD S0[초기 도입] --\u003e S1[속도/품질 불안정] S1 --\u003e S2[하니스 문제 식별] S2 --\u003e S3[도구 연결 보강] S3 --\u003e S4[에러 복구/운영 규칙 추가] S4 --\u003e S5[성과 가속]실무 적용: 지금 당장 시작할 3단계 1) 컨텍스트 파일을 먼저 고정 프로젝트 구조, 코딩 규칙, 리뷰 기준, 금지사항을 대화가 아니라 파일로 고정합니다.\n2) MCP 연결을 최소 단위로 설계 브라우저 자동화, 문서 검색, 디자인 도구 등 필요한 도구만 연결하고, 과도한 도구 노출은 피합니다.\n3) 스킬 파일로 작업별 전문성 분리 코드 리뷰, 문서 작성, 배포 점검처럼 반복되는 작업을 스킬로 모듈화합니다.\nflowchart TB A[Context File 작성] --\u003e B[MCP 최소 연결] B --\u003e C[Skill 파일 분리] C --\u003e D[작업별 에이전트 적용] D --\u003e E[반복 측정/개선]운영 체크리스트 아래 항목이 갖춰져 있으면 하니스 기반 운영으로 넘어갈 준비가 된 상태입니다.\n프로젝트 규칙이 대화창이 아닌 파일에 남아 있는가? 에이전트가 쓸 도구 범위와 권한이 명확한가? 반복 작업이 스킬 파일로 표준화되어 있는가? 실패 시 복구 규칙(재시도/중단/승인)이 정의되어 있는가? 산출물 품질을 검증할 체크포인트가 있는가? 결론 2025년이 컨텍스트 엔지니어링의 해였다면, 영상의 메시지대로 2026년은 하니스 엔지니어링의 해라고 볼 수 있습니다.\nAI 모델 성능은 점점 평준화되지만, 하니스는 팀의 운영 방식과 축적된 노하우가 반영되어 쉽게 복제되지 않습니다. 결국 장기 경쟁력은 \u0026ldquo;어떤 모델을 쓰는가\u0026quot;보다 \u0026ldquo;AI가 성과를 내는 환경을 얼마나 잘 설계했는가\u0026quot;에서 결정됩니다.\n참고 YouTube: 하니스 엔지니어링 관련 영상 Model Context Protocol ","date":"2026-02-18","permalink":"/post/2026/2026-02-18-harness-engineering-ai-agents/","section":"post","summary":"AI 활용의 병목은 모델 자체보다, 모델이 일할 수 있는 환경 설계에 있다는 주장이 빠르게 힘을 얻고 있습니다.\n이 글은 아래 영상을 기반으로, 하니스 엔지니어링의 개념과 실무 적용 순서를 한 번에 정리한 레퍼런스 노트입니다.\n영상: https://www.youtube.com/watch?v=BssPGKsP60s\u0026amp;t=12s 채널: 메이커 에반 | Maker Evan ","title":"하니스 엔지니어링이 AI 성과를 가른다: 컨텍스트를 넘어 환경을 설계하는 법"},{"content":"이 글은 ykdojo/claude-code-tips의 README와 연관 파일을 바탕으로, 팁을 한국어로 번역하고 실무 기준으로 재정리한 문서입니다.\n원문은 팁 번호가 0부터 시작해서 45까지 이어지므로, 제목은 45 Tips지만 실제 항목 표기는 46개(0~45)입니다.\n먼저 전체 구조부터 보기 flowchart TD A[입력/조작 최적화] --\u003e B[컨텍스트 관리] B --\u003e C[검증/테스트 자동화] C --\u003e D[병렬 작업/격리 실행] D --\u003e E[지식 자산화] E --\u003e F[지속 학습/공유]핵심 메시지는 간단합니다.\n빠른 입력보다 중요한 건 재현 가능한 작업 흐름이다. 길어진 대화는 정리/분기/압축해서 신선한 컨텍스트로 유지해야 한다. 코드 생성 자체보다 검증 루프(테스트, 리뷰, 자기검증)가 품질을 결정한다. 위험한 작업은 컨테이너/권한 분리로 안전하게 실행해야 한다. 45개 팁(0~45) 한국어 번역 + 정리 아래는 원문 팁을 실무 흐름 순서로 다시 묶어 요약한 버전입니다.\n1) CLI 기본기와 입력 속도 Tip 0 상태바를 커스터마이징해 모델, 브랜치, 미커밋 파일, 토큰 사용률을 한눈에 본다. Tip 1 /usage, /chrome, /mcp, /stats, /clear 같은 핵심 슬래시 명령부터 익힌다. Tip 2 로컬 음성 인식 도구를 붙여 타이핑보다 빠르게 지시를 전달한다. Tip 6 /copy, pbcopy, 파일 저장 후 에디터 열기 등으로 터미널 출력을 깔끔하게 꺼낸다. Tip 7 c, ch 같은 alias로 반복 실행 비용을 줄인다. Tip 10 접근 안 되는 웹/출력은 Cmd/Ctrl + A 복붙으로 컨텍스트를 직접 넣는다. Tip 24 다른 경로 파일은 realpath로 절대경로를 전달해 혼선을 줄인다. Tip 38 입력 박스 단축키(Ctrl+A/E/W/U/K/G)를 익혀 긴 프롬프트 편집 속도를 높인다. 2) 문제 분해와 계획 수립 Tip 3 큰 문제는 작은 실행 단위로 계속 쪼개서 해결한다. Tip 39 구현 전에 계획을 먼저 만들고, 빠른 프로토타입으로 기술 선택을 검증한다. Tip 32 항상 같은 깊이로 보지 말고, 상황에 맞게 추상화 레벨을 조절한다. Tip 35 모르는 영역도 반복 탐색 방식으로 접근하면 해결 가능성이 커진다. 3) 컨텍스트 관리(성능/품질 핵심) Tip 5 대화 컨텍스트는 길어질수록 성능이 떨어지므로, 주제별 새 세션이 유리하다. Tip 8 /compact를 수동으로 운용하고, 핸드오프 문서(HANDOFF.md)를 남겨 세션을 교체한다. Tip 13 ~/.claude/projects/의 대화 로그를 검색해 과거 맥락을 재활용한다. Tip 15 시스템 프롬프트/툴 설명 토큰 오버헤드를 줄이는 전략(패치, lazy-load MCP)을 적용한다. Tip 23 /fork, clone/half-clone으로 대화를 분기하거나 절반만 남겨 문맥을 가볍게 유지한다. Tip 30 CLAUDE.md는 짧게 유지하고 주기적으로 업데이트한다. 4) Git/GitHub/PR 실전 운영 Tip 4 Git/gh 작업(브랜치, 커밋, PR 생성)을 대화형으로 위임하되 푸시는 보수적으로 관리한다. Tip 16 병렬 작업 충돌을 줄이기 위해 git worktree를 사용한다. Tip 26 PR 리뷰를 일회성 평가가 아니라 대화형 점검 루프로 운영한다. Tip 28 테스트, 드래프트 PR, 시각적 Git 클라이언트, 자기 재검증 프롬프트를 조합해 검증한다. Tip 29 GitHub Actions 장애 분석을 자동화해 DevOps 디버깅 시간을 줄인다. Tip 33 승인된 위험 명령(rm -rf, sudo 등)을 정기 감사해 사고를 예방한다. Tip 34 테스트를 많이 쓰고 TDD로 명세-구현 일치를 강제한다. 5) 브라우저/리서치/외부정보 수집 Tip 9 자율 실행은 반드시 write-test 사이클(작성→실행→검증)을 완성해야 안정적이다. Tip 11 접근 제한 사이트는 Gemini CLI 등 대체 채널을 skill로 붙여 우회한다. Tip 27 Claude Code를 코드/시장/로그 조사용 리서치 엔진으로 활용한다. Tip 36 긴 bash/subagent 작업은 백그라운드로 보내고 병렬 진행한다. Tip 43 /release-notes, 커뮤니티, DevRel 채널로 지속적으로 최신 기능을 학습한다. 6) 글쓰기/문서/지식 관리 Tip 18 글쓰기도 초안 생성 후 줄 단위 피드백 루프로 품질을 끌어올린다. Tip 19 문서의 기본 포맷을 Markdown으로 두면 AI 협업 효율이 높다. Tip 20 링크 보존이 필요하면 Notion을 중간 포맷 변환기로 활용한다. Tip 41 반복되는 지시/명령을 자동화하는 자동화(automation of automation)를 추구한다. Tip 42 팁 공유와 오픈소스 기여를 통해 피드백 루프를 만든다. 7) 작업환경 확장(컨테이너/플러그인/오케스트레이션) Tip 12 내 워크플로를 직접 개선(음성 입력, 상태바, 규칙 문서)하는 투자를 한다. Tip 14 터미널 탭을 캐스케이드 방식으로 운영해 멀티태스킹을 정돈한다. Tip 17 긴 작업은 수동 지수 백오프로 상태를 점검해 토큰 낭비를 줄인다. Tip 21 위험하거나 장시간 작업은 컨테이너에서 실행해 호스트를 보호한다. Tip 22 결국 실력이 느는 가장 빠른 방법은 실제로 많이 쓰는 것이다. Tip 31 Claude Code를 단순 코더가 아니라 컴퓨터 작업 전반의 범용 인터페이스로 본다. Tip 37 개인 맞춤형 소프트웨어를 빠르게 만드는 시대가 열렸다는 관점을 갖는다. 8) 규칙 시스템 이해와 빠른 셋업 Tip 25 CLAUDE.md / Skills / Slash Commands / Plugins의 역할 차이를 구분해서 쓴다. Tip 40 모델이 과하게 복잡한 코드를 만들면 의도 설명을 요구하고 단순화시킨다. Tip 44 dx 플러그인으로 gha/handoff/clone 등 반복 작업을 묶어 설치한다. Tip 45 제공된 setup 스크립트로 권장 설정을 한번에 적용하되 항목별로 선택 설치한다. 실무 적용 순서(추천) flowchart LR A[단축키/alias/핵심 slash] --\u003e B[CLAUDE.md 최소화] B --\u003e C[검증 루프 테스트+PR] C --\u003e D[컨텍스트 분기/핸드오프] D --\u003e E[컨테이너 격리 자동화] E --\u003e F[플러그인/스킬 패키징]처음부터 모든 팁을 한 번에 넣기보다, 위 순서대로 한 단계씩 도입하는 편이 실패 확률이 낮습니다.\n번역 시 유지해야 할 전제(중요) 원문의 일부 팁은 환경 의존성이 강하므로, 그대로 복사하기보다 전제를 함께 봐야 합니다.\nflowchart TD A[팁 적용] --\u003e B{내 환경과 맞는가?} B --\u003e|예| C[바로 적용] B --\u003e|아니오| D[대체안 선택] D --\u003e E[권한/보안/비용 재검토] macOS 기준 예시가 많다(pbcopy, 키 바인딩, 경로 예시). --dangerously-skip-permissions, 시스템 프롬프트 패치, 자동 승인 권한은 강한 리스크를 동반한다. 컨테이너 오케스트레이션, 다중 모델 병행은 초보자에게 과할 수 있다. 플러그인/스킬은 편리하지만, 설정 파일과 승인 규칙 감사가 선행되어야 안전하다. 바로 써먹는 최소 체크리스트 /usage, /mcp, /stats부터 익혔는가? CLAUDE.md를 짧게 유지하고 불필요 지시를 제거했는가? 코드 작업마다 테스트/드래프트 PR 기반 검증 루프를 두었는가? 컨텍스트가 길어질 때 handoff/half-clone 같은 분기 전략이 있는가? 위험 명령 승인 목록을 정기적으로 감사하는가? 참고 원문 메인 문서: README.md 설정 예시: GLOBAL-CLAUDE.md 스크립트/스킬: scripts, skills ","date":"2026-02-18","permalink":"/post/2026/2026-02-18-claude-code-tips-korean-translation/","section":"post","summary":"이 글은 ykdojo/claude-code-tips의 README와 연관 파일을 바탕으로, 팁을 한국어로 번역하고 실무 기준으로 재정리한 문서입니다.\n원문은 팁 번호가 0부터 시작해서 45까지 이어지므로, 제목은 45 Tips지만 실제 항목 표기는 46개(0~45)입니다.\n","title":"ykdojo/claude-code-tips 한글 번역·정리: 45개 팁(0~45) 실무 요약"},{"content":"OpenClaw를 처음 설치할 때는 공식 문서의 최소 경로대로 진행하면 가장 빠르게 동작을 확인할 수 있습니다.\n이 글은 Getting Started와 Remote Access를 기준으로,\n설치 온보딩 Dashboard 실행 서버에서 --no-open 출력이 나왔을 때 원격 접속 까지 한 번에 정리한 실전용 가이드입니다.\n전체 흐름 한눈에 보기 flowchart TD A[Node 22+ 확인] --\u003e B[OpenClaw 설치] B --\u003e C[openclaw onboard --install-daemon] C --\u003e D[openclaw gateway status] D --\u003e E[openclaw dashboard] E --\u003e F{GUI 없는 서버인가?} F -- 아니오 --\u003e G[브라우저에서 Dashboard 사용] F -- 예 --\u003e H[openclaw dashboard --no-open] H --\u003e I[SSH 터널 생성] I --\u003e J[localhost:18789 접속]1) 사전 준비 공식 문서 기준 필수 조건은 다음 하나입니다.\nNode.js 22 이상 node --version 2) OpenClaw 설치 macOS / Linux curl -fsSL https://openclaw.ai/install.sh | bash Windows (PowerShell) iwr -useb https://openclaw.ai/install.ps1 | iex 3) 온보딩과 게이트웨이 확인 설치 후 바로 온보딩을 실행합니다.\nopenclaw onboard --install-daemon 다음으로 게이트웨이 상태를 확인합니다.\nopenclaw gateway status 정상이면 Dashboard를 엽니다.\nopenclaw dashboard 4) 서버 환경에서 Dashboard 접속하기 (--no-open) 리눅스 서버처럼 GUI가 없는 환경에서 아래처럼 실행하면:\nopenclaw dashboard --no-open 다음과 같은 핵심 메시지가 나옵니다.\nDashboard URL: http://127.0.0.1:18789/#token=... No GUI detected. Open from your computer: ssh -N -L 18789:127.0.0.1:18789 gyuha@192.168.0.11 Then open: http://localhost:18789/ http://localhost:18789/#token=... 이 출력의 의미는 간단합니다.\nOpenClaw Dashboard는 서버의 127.0.0.1:18789(루프백)에서 열려 있음 내 로컬 PC에서 직접 접근할 수 없으므로 SSH 로컬 포트 포워딩 필요 터널을 열면 로컬 localhost:18789로 서버 Dashboard에 접속 가능 5) 실제 원격 접속 절차 로컬 컴퓨터(내 노트북/데스크톱)에서 아래 명령을 실행합니다.\nssh -N -L 18789:127.0.0.1:18789 gyuha@192.168.0.11 그리고 브라우저에서 다음 주소를 엽니다.\nhttp://localhost:18789/ 토큰 인증이 필요하면 CLI가 출력한 URL 그대로 열면 됩니다.\nhttp://localhost:18789/#token=2cf9481971b618af3e439e78930f22d812368c16eee30bb1 --no-open은 브라우저를 자동 실행하지 않겠다는 옵션일 뿐이고, 실제 Dashboard 엔드포인트와 토큰은 그대로 출력해 주기 때문에 원격 서버에서 특히 유용합니다.\n6) 왜 SSH 터널이 필요한가? flowchart LR U[내 로컬 브라우저] --\u003e|localhost:18789| T[SSH 터널] T --\u003e|127.0.0.1:18789| S[원격 서버의 OpenClaw Gateway] S --\u003e D[Dashboard]공식 Remote Access 문서도 기본 권장값을 \u0026ldquo;루프백 바인드 + SSH 터널\u0026quot;로 안내합니다.\n게이트웨이를 외부 공개하지 않고 필요한 때만 터널을 열어 원격 제어하는 방식이라 안전하고 단순합니다. 7) 자주 확인하는 체크리스트 flowchart TD A[Node 22+] --\u003e B[openclaw onboard 완료] B --\u003e C[gateway status 정상] C --\u003e D[dashboard --no-open URL 확인] D --\u003e E[SSH -L 터널 유지 중] E --\u003e F[localhost:18789 접속 성공] 포트가 기본값이 아닐 경우 18789를 실제 포트로 바꿔서 터널링 SSH 세션이 끊기면 Dashboard 접속도 같이 끊김 #token=... URL은 인증 정보이므로 공유 시 주의 참고 OpenClaw Getting Started OpenClaw Remote Access OpenClaw Dashboard OpenClaw Gateway Remote Docs ","date":"2026-02-18","permalink":"/post/2026/2026-02-18-openclaw-install-and-remote-dashboard/","section":"post","summary":"OpenClaw를 처음 설치할 때는 공식 문서의 최소 경로대로 진행하면 가장 빠르게 동작을 확인할 수 있습니다.\n이 글은 Getting Started와 Remote Access를 기준으로,\n설치 온보딩 Dashboard 실행 서버에서 --no-open 출력이 나왔을 때 원격 접속 까지 한 번에 정리한 실전용 가이드입니다.\n","title":"OpenClaw 설치 가이드: Getting Started 기준으로 10분 만에 올리고 원격 Dashboard 접속하기"},{"content":"OpenClaw를 트레이딩에 붙이면 \u0026ldquo;지표 조회 자동화\u0026rdquo; 수준을 넘어서, 전략 문서를 해석하고 점수화 로직을 만들고 주문까지 연결하는 운영 체계를 만들 수 있습니다.\n이번 글은 아래 두 소스를 기준으로, 실제로 따라 할 수 있는 구축 순서와 운영 체크포인트를 한 번에 정리한 실전형 포스팅입니다.\n영상: OpenClaw Utilization Guide 문서: OpenClaw Trading Notion 핵심 요약 OpenClaw Trading의 본질은 \u0026ldquo;매매 봇 하나 실행\u0026quot;이 아니라 다음 루프를 계속 돌리는 것입니다.\n데이터 수집 파이프라인 구축 전략 문서 기반 분석 모듈 생성 종목 스코어링 및 주문 집행 결과 기록과 피드백을 다음 전략에 반영 즉, 사람이 매일 감으로 진입/청산을 판단하는 구조가 아니라, 전략-실행-회고를 자동화 가능한 운영 시스템으로 바꾸는 접근입니다.\n시스템 구조: 4계층 아키텍처 flowchart TB A[Data Layer\nOHLCV/거래량/공시/재무 수집] --\u003e B[Strategy Layer\n전략 문서 해석\n활성 전략 관리] B --\u003e C[Analysis Layer\n다중 팩터 스코어링\n랭킹/매수수량 계산] C --\u003e D[Execution Layer\n주문 집행\n손익/체결 기록] D --\u003e E[(Supabase)] E --\u003e B1) Data Layer OHLCV, 거래량, 공시/재무 데이터 수집 종목군(예: 거래량 상위 Top 50) 기준 적재 장중/장후/새벽 정리 작업까지 스케줄링 2) Strategy Layer 투자 전략 보고서(PDF/문서) 입력 LLM이 전략 규칙을 실행 가능한 로직으로 변환 전략 버전 관리(활성/비활성) 3) Analysis Layer 다중 팩터 스코어링(수치, 차트, 뉴스/감성 등) 종목별 점수, 랭킹, 예산 대비 매수 수량 계산 Python 분석 모듈 자동 생성/수정 4) Execution Layer 스케줄 또는 신호 기반 주문 실행 예산 한도와 분산 투자 규칙 적용 주문/체결/손익 로그 저장 OpenClaw가 자동으로 돌아가는 3가지 메커니즘 flowchart TB Cron[Cron\n정시/주기 실행] --\u003e Agent[OpenClaw Agent] Heartbeat[Heartbeat\n간격 기반 점검] --\u003e Agent Webhook[Webhook\n외부 이벤트 트리거] --\u003e Agent Agent --\u003e Telegram[Telegram 알림/대화] Agent --\u003e Kiwoom[키움 REST API\n주문/조회] Agent --\u003e DART[OpenDART API\n공시/재무] Agent --\u003e DB[(Supabase)]Cron 정해진 시간에 작업을 실행합니다.\n예: 장중 5분 수집, 장후 일봉 적재, 장마감 전 청산 Heartbeat 고정 시각이 아니라 \u0026ldquo;간격 기반\u0026quot;으로 상태를 확인합니다.\n장애 감지, 누락 점검, 알림에 유리 Webhook 외부 이벤트가 들어오면 작업을 깨웁니다.\n메시지/트리거 기반 실행 기술 스택 조합이 중요한 이유 영상/문서 흐름에서 강조되는 조합은 다음입니다.\n키움 REST API: 자동매매 실행 경로 OpenDART API: 공시/재무 데이터 보강 Supabase(Postgres): 데이터/전략/결과 저장소 Telegram: 운영 커뮤니케이션 채널 포인트는 \u0026ldquo;모델이 똑똑하다\u0026quot;가 아니라, 실행 가능한 인프라와 연결되어 있느냐입니다.\n구축 절차: 실무에서 바로 쓰는 순서 flowchart TD S1[1. OpenClaw/Telegram 기본 연결] --\u003e S2[2. 스킬 설치\nKiwoom/OpenDART/Supabase] S2 --\u003e S3[3. API 키 발급/환경변수 등록] S3 --\u003e S4[4. API 연결 테스트] S4 --\u003e S5[5. 데이터 파이프라인 적재/스케줄] S5 --\u003e S6[6. 전략 문서 등록\n분석 모듈 생성] S6 --\u003e S7[7. 백테스트] S7 --\u003e S8[8. 모의투자 운영] S8 --\u003e S9[9. 소액 실전 전환]1) 기본 환경 준비 OpenClaw 설치 및 초기 설정 Telegram bot 연결(대화 승인/송수신 확인) 스킬 경로 확인 (~/.openclaw/skills) 2) 스킬 설치 키움 REST API 스킬 OpenDART API 스킬 Supabase/Postgres 관련 스킬 시크릿/환경변수 관리 스킬 핵심은 임시 프롬프트가 아니라, 반복 가능한 작업을 스킬로 고정하는 것입니다.\n3) API 키 발급 및 환경변수 등록 필수 항목 예시:\nSUPABASE_URL SUPABASE_SECRET_KEY SUPABASE_DB_PASSWORD OPENDART_API_KEY KIWOOM_MOCK_APP_KEY, KIWOOM_MOCK_SECRET_KEY, KIWOOM_MOCK_ACCOUNT_NO KIWOOM_APP_KEY, KIWOOM_SECRET_KEY, KIWOOM_ACCOUNT_NO 실전 팁: 모의/실전 키는 변수명부터 명확히 분리해야 운영 사고를 줄일 수 있습니다.\n4) API 연결 테스트(반드시 선행) 순서:\nSupabase 읽기/쓰기 테스트 OpenDART 조회 테스트 키움 REST API 핵심 엔드포인트 테스트 이 단계를 건너뛰면, 이후 문제 발생 시 전략 오류와 인프라 오류를 구분하기가 어려워집니다.\n데이터 파이프라인 설계 예시 영상 흐름 기준 운영 주기:\n장중: 5분 봉 데이터 수집 장후: 일봉/집계 데이터 적재 공시: 10분 단위 모니터링 새벽: 정리/청소 작업 또한 예시로 Top 50 종목군 대상 데이터 적재(수천 건 규모)를 수행하고, 기술/재무/공시/스냅샷 테이블을 분리 관리합니다.\n중요한 운영 포인트는 하나입니다.\n\u0026ldquo;스케줄 문서 작성\u0026quot;이 아니라, 실제 cron 등록 여부를 반드시 검증해야 한다.\n전략 생성: 감 대신 근거로 영상/문서에서는 전략 설계 시 다음 흐름을 추천합니다.\n리서치 도구(예: Deep Research)로 전략 아이디어 정리 진입/청산/가중치/임계값을 수식/파라미터로 명시 분석 코드를 자동 생성하고 버전 관리 백테스트로 1차 검증 예시로 통합 점수 임계값(예: 70점 이상 진입) 같은 규칙을 명확히 수치화해, 전략 해석 편차를 줄이는 접근을 사용합니다.\n백테스트와 실거래는 다르게 나온다 소스에서 제시된 백테스트 수치(승률/손익비 등)는 참고 지표일 뿐, 그대로 실거래 성과를 보장하지 않습니다.\n대표적인 이유:\n과최적화(Overfitting) 체결 지연/슬리피지 장중 분석 지연으로 인한 타이밍 미스 API/네트워크/운영 장애 권장 순서는 항상 같습니다.\n모의투자 충분 검증 소액 실전 점진적 증액 실행 레이어 운영 예시 데이트레이딩 형태 기준으로는 다음 패턴이 자주 사용됩니다.\n장중 특정 시각: 스냅샷 + 스코어링 실행 예산 사용 한도 적용(예: 자산의 일정 비율) 종목별 상/하한 규칙으로 분산 매수 장마감 전 일괄 청산 이 구조는 \u0026ldquo;당일 리스크 종료\u0026quot;에 유리하지만, 스윙 전략에는 별도 청산 규칙이 필요합니다.\n운영에서 성능을 만드는 진짜 포인트 flowchart LR R1[당일 손익/체결 리포트] --\u003e R2[실패 원인 태깅\n신호/체결/데이터/운영] R2 --\u003e R3[파라미터 수정 후보 생성] R3 --\u003e R4[다음 거래일 반영] R4 --\u003e R1자동매매는 주문 자동화보다 회고 자동화가 더 중요합니다.\n매일 최소 루프:\n당일 손익/체결 리포트 생성 실패 원인 태깅(신호/체결/데이터/운영) 파라미터 수정 후보 제안 다음 거래일 반영 이 루프가 없으면, 시스템은 \u0026ldquo;자동 실행\u0026quot;만 하고 \u0026ldquo;자동 개선\u0026quot;은 하지 못합니다.\n리스크 관리 체크리스트 모의/실전 계정과 키를 완전히 분리했는가 주문 전 한도(일손실, 종목당 익스포저)를 강제했는가 데이터 누락/지연 감지 알림이 있는가 비정상 응답 시 주문 중지(fail-safe) 규칙이 있는가 cron이 실제 등록되어 있고 주기 점검 중인가 로그/감사 추적(누가, 언제, 어떤 규칙으로 주문했는가)이 가능한가 비용 최적화 전략 운영 단계에서 놓치기 쉬운 부분이 모델/API 비용입니다.\n전략 설계/재구성: 상위 모델 일상 운영/반복 분석: 경량 모델 이벤트성 재검증: 상위 모델 재투입 결국 목표는 \u0026ldquo;수익률\u0026quot;뿐 아니라 수익 - 운영비(모델/API/인프라) 기준으로 시스템을 관리하는 것입니다.\n마무리 OpenClaw Trading은 \u0026ldquo;AI에게 주문을 맡긴다\u0026quot;보다 훨씬 큰 개념입니다.\n정확히는, 전략 지식 + 데이터 파이프라인 + 자동 집행 + 피드백 학습을 하나의 운영 시스템으로 묶는 작업입니다.\n자동매매를 시작할 때 가장 먼저 해야 할 일은 화려한 전략이 아니라, 안전하게 반복 실행 가능한 기본 루프를 만드는 것입니다.\n참고 OpenClaw 홈페이지 OpenClaw Repository OpenClaw Utilization Guide (YouTube) OpenClaw Trading (Notion) 키움증권 REST API 개발자 포털 Liner AI (딥리서치) OpenDART (공시정보) Supabase (클라우드 데이터베이스) SkillsMP (스킬 마켓플레이스) 스킬 다운로드 유틸 Telegram Bot 공식 문서 ","date":"2026-02-18","permalink":"/post/2026/2026-02-18-openclaw-trading-system-guide/","section":"post","summary":"OpenClaw를 트레이딩에 붙이면 \u0026ldquo;지표 조회 자동화\u0026rdquo; 수준을 넘어서, 전략 문서를 해석하고 점수화 로직을 만들고 주문까지 연결하는 운영 체계를 만들 수 있습니다.\n이번 글은 아래 두 소스를 기준으로, 실제로 따라 할 수 있는 구축 순서와 운영 체크포인트를 한 번에 정리한 실전형 포스팅입니다.\n영상: OpenClaw Utilization Guide 문서: OpenClaw Trading Notion ","title":"OpenClaw Trading 실전 구축기: AI 자동매매 시스템을 데이터-전략-분석-집행으로 운영하는 방법"},{"content":"LLM 애플리케이션을 만들다 보면 결국 같은 질문에 부딪힙니다.\n\u0026ldquo;외부 지식을 매 요청마다 검색(RAG) 할지, 아니면 미리 넣어두고 캐시(CAG) 할지\u0026rdquo;\n이 글은 공식 문서와 논문을 바탕으로 RAG와 CAG를 실무 관점에서 비교합니다.\n먼저 용어 정리: 이 글에서 CAG는 무엇인가? 먼저 주의할 점이 있습니다. CAG라는 약어는 문맥에 따라 다르게 쓰일 수 있습니다.\n이 글에서 CAG는 Cache-Augmented Generation(캐시 증강 생성)을 의미합니다. 즉, 질의 시점의 실시간 검색을 줄이거나 생략하고, 미리 준비한 컨텍스트/캐시를 활용하는 접근입니다. RAG 한 장 요약 RAG(Retrieval-Augmented Generation)는 질의가 들어올 때마다 관련 문서를 검색해 LLM 프롬프트에 붙여 답변을 생성하는 방식입니다.\nflowchart TD U[사용자 질문] --\u003e Q[질의 전처리/임베딩] Q --\u003e V[(벡터 DB/검색 인덱스)] V --\u003e R[관련 문서 Top-k 검색] R --\u003e P[프롬프트 구성 질문 + 검색 문맥] P --\u003e L[LLM 생성] L --\u003e A[응답 + 근거]RAG의 강점 문서가 자주 바뀌는 환경에 유리합니다. 대규모 지식베이스(문맥창보다 큰 규모)에도 확장하기 쉽습니다. 검색된 근거를 함께 보여주기 쉬워 감사/추적에 강합니다. RAG의 주의점 검색 품질(청킹, 임베딩, 리랭킹)에 따라 답변 품질이 흔들립니다. 검색 단계가 추가되어 시스템 복잡도와 지연이 늘어납니다. CAG 한 장 요약 CAG(Cache-Augmented Generation)는 자주 쓰는 컨텍스트를 미리 로딩/캐싱해, 반복 질의에서 재사용하는 접근입니다.\nflowchart TD K[지식/문서 준비] --\u003e C[초기 로딩/캐시 생성] C --\u003e S[(캐시된 프리픽스 또는 KV 상태)] U[사용자 질문] --\u003e M[질문 결합] S --\u003e M M --\u003e L[LLM 생성] L --\u003e A[응답]CAG의 강점 반복 질의 워크로드에서 지연과 비용을 낮추기 쉽습니다. 검색 계층이 줄어 아키텍처가 단순해집니다. CAG의 주의점 지식이 자주 바뀌면 캐시 무효화/재생성 전략이 필요합니다. 모델 컨텍스트 크기와 캐시 정책 제약을 직접 관리해야 합니다. RAG vs CAG 핵심 비교 항목 RAG CAG 지식 반영 방식 질의 시점 실시간 검색 사전 로딩/캐시 재사용 데이터 변경 대응 강함 (업데이트 반영 용이) 보통 (재캐시 필요) 시스템 구성 검색 파이프라인 필요 상대적으로 단순 응답 근거 추적 용이 구현 방식에 따라 다름 반복 질의 효율 중간 높음(캐시 히트 시) 대규모 코퍼스 확장 유리 컨텍스트/캐시 한계에 영향 언제 무엇을 선택할까? flowchart TD S[시작] --\u003e D1{데이터가 자주 바뀌는가?} D1 --\u003e|예| R1[RAG 우선 검토] D1 --\u003e|아니오| D2{반복 질의가 많은가?} D2 --\u003e|예| C1[CAG 우선 검토] D2 --\u003e|아니오| D3{코퍼스가 컨텍스트에 안정적으로 들어가는가?} D3 --\u003e|예| C2[CAG 또는 Hybrid] D3 --\u003e|아니오| R2[RAG 또는 Hybrid]실무에서는 하이브리드도 자주 씁니다.\n변동이 큰 데이터: RAG로 최신성 확보 고정된 정책/핸드북/반복 규칙: CAG로 캐시 효율 확보 구현 팁 (짧게) RAG 품질을 올리려면 청킹 기준(길이/의미 단위)을 먼저 고정합니다. 검색 후 리랭킹 단계를 넣어 관련도 편차를 줄입니다. \u0026ldquo;검색 실패\u0026rdquo; 케이스를 별도로 로깅해 인덱스 품질을 개선합니다. CAG 효율을 올리려면 프롬프트에서 고정 프리픽스를 앞에 두고, 변동 입력을 뒤에 둡니다. 캐시 키 전략(테넌트/문서 버전 단위)을 명시합니다. TTL, 캐시 무효화, 버전 롤백 정책을 운영 규칙으로 둡니다. 결론 RAG와 CAG는 경쟁이라기보다 워크로드에 따라 분업하는 관계에 가깝습니다.\n최신성/대규모/근거 추적이 핵심이면 RAG 반복 질의/지연·비용 최적화가 핵심이면 CAG 대부분의 프로덕션은 둘을 섞는 하이브리드가 현실적입니다. 참고 자료 Lewis et al., \u0026ldquo;Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks\u0026rdquo; (arXiv, 2020): https://arxiv.org/abs/2005.11401 Chan et al., \u0026ldquo;Don\u0026rsquo;t Do RAG: When Cache-Augmented Generation is All You Need for Knowledge Tasks\u0026rdquo; (arXiv, 2024/2025): https://arxiv.org/abs/2412.15605 OpenAI Docs, \u0026ldquo;Prompt caching\u0026rdquo;: https://developers.openai.com/api/docs/guides/prompt-caching/ Anthropic Docs, \u0026ldquo;Prompt caching\u0026rdquo;: https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching Anthropic News, \u0026ldquo;Introducing Contextual Retrieval\u0026rdquo; (RAG 품질 향상 관련): https://www.anthropic.com/news/contextual-retrieval Google Cloud, \u0026ldquo;Vertex AI RAG Engine overview\u0026rdquo;: https://docs.cloud.google.com/vertex-ai/generative-ai/docs/rag-engine/rag-overview AWS Prescriptive Guidance, \u0026ldquo;Retrieval Augmented Generation options and architectures on AWS\u0026rdquo;: https://docs.aws.amazon.com/prescriptive-guidance/latest/retrieval-augmented-generation-options/introduction.html ","date":"2026-02-18","permalink":"/post/2026/2026-02-18-rag-vs-cag-comparison/","section":"post","summary":"LLM 애플리케이션을 만들다 보면 결국 같은 질문에 부딪힙니다.\n\u0026ldquo;외부 지식을 매 요청마다 검색(RAG) 할지, 아니면 미리 넣어두고 캐시(CAG) 할지\u0026rdquo;\n이 글은 공식 문서와 논문을 바탕으로 RAG와 CAG를 실무 관점에서 비교합니다.\n","title":"LLM에서 RAG vs CAG 비교: 언제 검색하고, 언제 캐시할까?"},{"content":"프롬프트를 잘 쓰는 시대는 끝났다는 말이 과장처럼 들릴 수 있습니다. 하지만 최근 에이전트형 AI 흐름에서는 \u0026ldquo;질문 한 줄\u0026quot;보다 \u0026ldquo;AI가 일을 수행할 수 있는 문맥 전체\u0026quot;를 어떻게 설계하느냐가 결과를 좌우합니다.\n이 글은 아래 영상을 기반으로, 핵심 개념과 실무 적용법을 도표 중심으로 정리한 레퍼런스 노트입니다.\n영상: 90%가 모르는 AI 활용법… 질문이 아니라 \u0026lsquo;이것\u0026rsquo;입니다 채널: 메이커 에반 | Maker Evan 핵심 요약 프롬프트 엔지니어링은 \u0026ldquo;어떻게 물어볼까\u0026quot;에 집중한다. 컨텍스트 엔지니어링은 \u0026ldquo;무엇을 보여줄까\u0026quot;를 설계한다. AI 성능 저하는 모델 문제가 아니라 컨텍스트 오염/과부하에서 자주 발생한다. 실무에서는 저장하기, 골라주기, 정리하기, 나눠주기 4가지 전략이 효과적이다. 좋은 컨텍스트 설계는 품질뿐 아니라 비용까지 줄인다. flowchart LR A[프롬프트 엔지니어링 어떻게 물어볼까] --\u003e B[컨텍스트 엔지니어링 무엇을 보여줄까] B --\u003e C[에이전트 실행 성능 개선] B --\u003e D[반복 실수 감소] B --\u003e E[비용 최적화]왜 프롬프트만으로는 한계가 생겼을까 영상의 핵심 전제는 간단합니다. AI가 더 이상 단일 Q\u0026amp;A가 아니라, 도구를 연속 호출하며 다단계 업무를 수행하는 환경으로 바뀌었다는 점입니다.\nflowchart TD subgraph Old[🔹 기존 방식] Q1[단일 질문 입력] --\u003e A1[단일 답변 생성] end Old -.-\u003e|패러다임 전환| New subgraph New[🔸 에이전트 방식] T1[작업 목표] --\u003e P1[계획 수립] P1 --\u003e X1[도구 호출 1] X1 --\u003e X2[도구 호출 2] X2 --\u003e X3[도구 호출 N] X3 --\u003e R1[중간 점검/수정] R1 --\u003e O1[최종 산출물] end즉, 이제는 대사 한 줄을 고치는 기술보다 \u0026ldquo;시나리오 전체를 설계하는 기술\u0026quot;이 중요해졌습니다.\n컨텍스트 엔지니어링의 정의 영상에서는 컨텍스트 엔지니어링을 다음처럼 설명합니다.\nAI가 다음 할 일을 제대로 수행하도록, 필요한 정보만 선별해 전달하는 설계 기술\nflowchart TB U[사용자 목표] --\u003e C1[컨텍스트 설계] C1 --\u003e C2[관련 정보 선별] C2 --\u003e C3[불필요 정보 제거] C3 --\u003e C4[형식/우선순위 정렬] C4 --\u003e M[AI 추론/도구 실행] M --\u003e Y[결과 품질]컨텍스트를 구성하는 7가지 요소 질문은 컨텍스트의 일부일 뿐입니다. 영상의 프레임으로 보면, 실제 결과를 좌우하는 요소는 아래처럼 더 넓습니다.\nmindmap root((컨텍스트)) 기본 지침 현재 질문 대화 기록 장기 기억 외부 자료 사용 가능한 도구 답변 형식이 관점으로 보면 \u0026ldquo;질문 잘 쓰기\u0026quot;는 7개 중 1개만 다루는 셈입니다.\n실패 패턴: 컨텍스트가 나쁘면 생기는 4가지 문제 영상에서 강조한 문제를 운영 관점으로 재정리하면 아래와 같습니다.\nflowchart LR A[오염 잘못된 정보 유입] --\u003e E[결론 왜곡] B[산만 루프 반복] --\u003e E C[혼동 엉뚱한 참조] --\u003e E D[충돌 모순 지시] --\u003e EstateDiagram-v2 [*] --\u003e 정상실행 정상실행 --\u003e 오염: 잘못된 사실 주입 정상실행 --\u003e 산만: 목표 추적 실패 정상실행 --\u003e 혼동: 관련도 낮은 자료 사용 정상실행 --\u003e 충돌: 상충 지시 동시 존재 오염 --\u003e 재설계 산만 --\u003e 재설계 혼동 --\u003e 재설계 충돌 --\u003e 재설계 재설계 --\u003e 정상실행실무 전략 4가지: 저장, 선별, 요약, 분할 영상의 실행 전략을 팀 적용 관점으로 도식화하면 다음과 같습니다.\nflowchart TB S1[저장하기 핵심 문맥 외부 보관] --\u003e S2[골라주기 현재 작업에 필요한 정보만 주입] S2 --\u003e S3[정리하기 긴 대화 중간 요약] S3 --\u003e S4[나눠주기 큰 작업을 단계별 분리] S4 --\u003e S5[최종 통합]sequenceDiagram participant U as 사용자 participant O as 오케스트레이터 participant A as AI 에이전트 participant K as 지식저장소 U-\u003e\u003eO: 작업 목표 전달 O-\u003e\u003eK: 관련 컨텍스트 조회 O-\u003e\u003eA: 선별된 컨텍스트 + 작업 1 A--\u003e\u003eO: 중간 결과 + 이슈 O-\u003e\u003eA: 요약 컨텍스트 + 작업 2 A--\u003e\u003eO: 최종 결과 O--\u003e\u003eU: 산출물 전달To-Do 루프가 중요한 이유 영상에서 특히 강조되는 운영 팁은 \u0026ldquo;작업 시작 시 To-Do를 만들고 단계별로 갱신\u0026quot;하는 방식입니다.\nflowchart TB T0[목표 입력] --\u003e T1[To-Do 생성] T1 --\u003e T2[단계 실행] T2 --\u003e T3[체크리스트 갱신] T3 --\u003e T4{완료?} T4 --\u003e|아니오| T2 T4 --\u003e|예| T5[최종 검토]긴 작업에서 목표 이탈을 막고, 실패 원인을 추적하기 쉬워지는 구조입니다.\n비용 관점: 캐싱은 왜 중요한가 영상의 중요한 메시지 중 하나는 \u0026ldquo;같은 컨텍스트를 안정적으로 재사용하면 비용이 크게 줄어든다\u0026quot;는 점입니다. 반대로 매 요청마다 바뀌는 정보(예: 현재 시각)를 고정 프리픽스에 넣으면 캐시 효율이 떨어집니다.\nflowchart TD A[고정 컨텍스트 분리] --\u003e B[프리픽스 캐시 히트] B --\u003e C[토큰 비용 절감] D[매번 변하는 정보 포함] --\u003e E[캐시 미스 증가] E --\u003e F[재처리 비용 상승]pie showData title 컨텍스트 설계 전/후 비용 비중(개념도) \"고정 문맥 재사용\" : 55 \"변동 입력 처리\" : 30 \"불필요 재처리\" : 15바로 적용하는 실전 템플릿 아래 템플릿을 업무 프롬프트 시작점으로 쓰면, \u0026ldquo;질문 문장\u0026quot;이 아니라 \u0026ldquo;작업 문맥\u0026rdquo; 중심으로 요청을 구성할 수 있습니다.\nflowchart TB I1[역할/목표] --\u003e I2[배경 정보] I2 --\u003e I3[제약 조건] I3 --\u003e I4[사용 가능 도구] I4 --\u003e I5[출력 형식] I5 --\u003e I6[검증 기준]실무 입력 예시(요약):\n역할: \u0026ldquo;당신은 B2B 마케팅 매니저 어시스턴트다.\u0026rdquo; 목표: \u0026ldquo;거래처 미팅 일정 조율 메일 작성\u0026rdquo; 배경: \u0026ldquo;이전 논의, 상대 선호 시간, 금지 표현\u0026rdquo; 제약: \u0026ldquo;톤은 정중/길이는 7문장 이하\u0026rdquo; 출력: \u0026ldquo;제목 3개 + 본문 1개\u0026rdquo; 검증: \u0026ldquo;오해 가능 표현 제거 체크리스트 포함\u0026rdquo; 결론 영상의 메시지를 한 문장으로 요약하면 이것입니다.\n이제 AI 활용력은 질문 문장 스킬이 아니라, 컨텍스트를 설계하는 운영 능력에서 갈립니다.\n모델이 좋아질수록 격차는 더 줄어들 것 같지만, 실제로는 반대입니다. 좋은 모델일수록 좋은 컨텍스트에서 더 큰 성능 차이를 내기 때문입니다.\n참고 90%가 모르는 AI 활용법… 질문이 아니라 \u0026lsquo;이것\u0026rsquo;입니다 (YouTube) 메이커 에반 | Maker Evan BESPIN GLOBAL - 컨텍스트 엔지니어링 한빛미디어 - AI 에이전트와 컨텍스트 엔지니어링 IBM - 2026 AI 트렌드 ","date":"2026-02-18","permalink":"/post/2026/2026-02-18-context-engineering-ai-usage/","section":"post","summary":"프롬프트를 잘 쓰는 시대는 끝났다는 말이 과장처럼 들릴 수 있습니다. 하지만 최근 에이전트형 AI 흐름에서는 \u0026ldquo;질문 한 줄\u0026quot;보다 \u0026ldquo;AI가 일을 수행할 수 있는 문맥 전체\u0026quot;를 어떻게 설계하느냐가 결과를 좌우합니다.\n이 글은 아래 영상을 기반으로, 핵심 개념과 실무 적용법을 도표 중심으로 정리한 레퍼런스 노트입니다.\n영상: 90%가 모르는 AI 활용법… 질문이 아니라 \u0026lsquo;이것\u0026rsquo;입니다 채널: 메이커 에반 | Maker Evan ","title":"90%가 놓치는 AI 활용법: 프롬프트 엔지니어링에서 컨텍스트 엔지니어링으로"},{"content":"AI 코딩 도구를 쓰고 있는데도 결과가 들쑥날쑥하다면, 문제는 모델 성능보다 사용 방식일 가능성이 큽니다.\n이번 글은 메이커 에반님의 영상 **\u0026ldquo;클로드 이렇게 쓰면 100배 차이 납니다\u0026rdquo;**를 참고해, Claude Code를 단순 챗봇이 아니라 재현 가능한 작업 시스템으로 쓰는 방법을 정리한 포스팅입니다.\n핵심 요약 영상의 중심 메시지는 아래 네 줄로 압축할 수 있습니다.\n막연한 요청(\u0026ldquo;잘해줘\u0026rdquo;)은 거의 효과가 없다. 세션 메모리를 신뢰하지 말고, 중요한 규칙은 파일에 먼저 고정해야 한다. 설정은 \u0026ldquo;부탁\u0026quot;이고, 훅은 \u0026ldquo;강제\u0026quot;에 가깝다. 프로젝트 구조 자체가 AI가 이해하기 쉬워야 생산성이 올라간다. 즉, 성능 차이를 만드는 건 프롬프트 한 줄이 아니라 운영 방식의 시스템화입니다.\n문제 정의: 왜 같은 Claude Code인데 결과가 크게 갈릴까? 영상 초반부에서 강조하는 포인트는 \u0026ldquo;도구 사용 숙련도의 격차\u0026quot;입니다.\nAI 도구를 쓰는 것 자체는 이제 진입장벽이 낮아졌고 실제 차이는 반복 가능한 규칙을 갖고 운용하느냐에서 벌어진다는 주장입니다. 발표자는 30일 동안 대규모 코드 작업을 하며 같은 문제를 반복해서 겪었고, 결론적으로 \u0026ldquo;클로드는 도구가 아니라 시스템으로 다뤄야 한다\u0026quot;는 관점을 제시합니다.\n원칙 1) 설정 파일은 추상 문장 대신 \u0026ldquo;상황 -\u0026gt; 행동\u0026rdquo; 규칙으로 작성하기 영상에서 가장 먼저 지적한 안티패턴은 이런 문장입니다.\n\u0026ldquo;친절하게 답해줘\u0026rdquo; \u0026ldquo;좋은 코드 써줘\u0026rdquo; \u0026ldquo;잘해줘\u0026rdquo; 이런 지시는 해석 폭이 너무 넓어 모델이 일관되게 따르기 어렵습니다.\n대신 아래처럼 조건과 행동을 묶어 써야 한다고 설명합니다.\n코드가 30줄을 넘으면 분리하기 에러 가능 구간에는 방어 로직 추가하기 새 파일 상단에 파일 역할 1줄 명시하기 핵심은 감각적 지시가 아니라 검증 가능한 규칙 문장입니다.\n원칙 2) \u0026ldquo;기억할게요\u0026quot;를 신뢰하지 말고, 파일 기반 메모를 기본값으로 두기 영상에서 반복 언급되는 문제는 세션 경계입니다.\n대화창을 닫거나 새 세션으로 넘어가면 이전 맥락이 유지되지 않는 상황이 생김 중요한 규칙이 구두 지시로만 남아 있으면 다음 작업에서 재설명 비용이 커짐 해결책은 단순합니다.\n중요한 규칙/결정사항은 먼저 파일로 기록 이후 대화는 파일을 기준으로 진행 이렇게 하면 매번 \u0026ldquo;처음부터 다시 설명\u0026quot;하는 시간이 크게 줄어듭니다.\n원칙 3) 설정만으로 부족할 때는 훅으로 자동 검증 파이프를 만들기 영상에서 말하는 핵심 구분은 이렇습니다.\n설정 파일: 권고/요청 성격 훅(Hooks): 조건 충족 시 자동 실행되는 강제 장치 예시로는 \u0026ldquo;기록했다\u0026quot;고 답했지만 실제 메모 파일 갱신이 없을 때, 훅으로 차단/재요청을 걸어 누락을 줄이는 흐름을 설명합니다.\n결국 훅의 목적은 모델을 더 똑똑하게 만드는 것이 아니라, 사람이 정한 프로세스를 안정적으로 집행하는 데 있습니다.\n원칙 4) Claude를 바꾸기 전에 프로젝트를 Claude 친화적으로 구성하기 영상 후반부에서 실전 팁으로 제시한 항목은 프로젝트 구조 최적화입니다.\n4-1. 저장소를 한곳에서 보이게 정리하기 프론트/백/스크립트가 과하게 분산되면 전체 맥락 파악이 느려짐 모노레포처럼 구조를 한 번에 읽기 좋게 맞추면 맥락 연결이 쉬워짐 4-2. 한 파일에 기능을 과밀하게 넣지 않기 거대한 파일은 관련 없는 맥락까지 끌어와 수정 실수를 늘림 기능 단위 분리로 탐색 비용과 오수정 가능성을 낮춤 4-3. AI가 많이 본, 안정적인 기술 스택 우선하기 지나치게 최신이거나 레퍼런스가 적은 조합은 출력 정확도가 흔들릴 수 있음 검증된 버전/패턴이 유지보수성과 예측 가능성을 높임 4-4. 폴더/파일 단위 가이드 문서와 헤더 설명 넣기 폴더별 규칙 문서(어떤 스타일/규칙을 따르는지) 파일 상단 1줄 설명(이 파일의 역할) 이 두 가지는 사람이 읽기 편할 뿐 아니라, AI가 빠르게 의도를 파악하는 데도 직접적인 도움을 줍니다.\n원칙 5) 데이터 접근과 계획 수립에도 운영 규칙을 넣기 영상에서 함께 제시된 실무 팁은 아래 두 가지입니다.\n데이터베이스는 우선 읽기 전용 연결로 진단/탐색 안정성 확보 구현 전에 계획 생성과 리뷰에 충분한 시간 투자 특히 \u0026ldquo;빨리 만들기\u0026quot;보다 \u0026ldquo;좋은 계획을 먼저 만들고 검토하기\u0026quot;가 결과 품질을 더 크게 좌우한다는 점을 강조합니다.\n관통 메시지: 바이브 코딩보다 바이브 리뷰 영상의 마지막 키워드는 vibe coding이 아니라 vibe review입니다.\n코드 생성은 AI에게 맡겨도 무엇을 만들었는지 이해하고 검토하는 책임은 사람에게 남아 있어야 함 이 검토 루프가 없으면 생산성은 잠깐 올라가도 품질이 무너지고, 장기적으로는 오히려 속도가 느려집니다.\n바로 적용할 체크리스트 오늘 내용 기준으로, 바로 실행 가능한 최소 체크리스트를 정리하면 다음과 같습니다.\n규칙을 추상 문장이 아니라 조건/행동 문장으로 바꿨는가? 중요한 지시를 대화창이 아니라 파일에 먼저 기록했는가? 반복 누락 항목에 훅 기반 자동 검증을 붙였는가? 프로젝트 구조를 AI가 탐색하기 쉽게 분리/정리했는가? 폴더/파일 가이드 문서로 맥락 설명 비용을 줄였는가? 생성 이후 리뷰 기준(정확성/안전성/일관성)을 운영하고 있는가? 마무리 Claude Code의 성능은 모델 스펙보다 운영 체계에 더 크게 좌우됩니다.\n이번 영상을 실무 관점으로 요약하면, \u0026ldquo;잘 쓰는 사람\u0026quot;은 프롬프트를 잘 꾸미는 사람이 아니라 규칙, 기록, 자동 검증, 구조화를 통해 실수 가능성을 시스템적으로 줄인 사람입니다. 당장 하나만 적용한다면, 오늘부터는 중요한 의사결정을 대화창이 아니라 파일에 먼저 남기는 습관부터 시작해 보세요.\n참고 YouTube: 클로드 이렇게 쓰면 100배 차이 납니다 Anthropic Docs Model Context Protocol ","date":"2026-02-17","permalink":"/post/2026/2026-02-18-claude-code-100x-usage-guide/","section":"post","summary":"AI 코딩 도구를 쓰고 있는데도 결과가 들쑥날쑥하다면, 문제는 모델 성능보다 사용 방식일 가능성이 큽니다.\n이번 글은 메이커 에반님의 영상 **\u0026ldquo;클로드 이렇게 쓰면 100배 차이 납니다\u0026rdquo;**를 참고해, Claude Code를 단순 챗봇이 아니라 재현 가능한 작업 시스템으로 쓰는 방법을 정리한 포스팅입니다.\n","title":"클로드 코드, 이렇게 쓰면 생산성이 벌어진다: 30일 실전에서 뽑은 핵심 원칙"},{"content":"바이브 코딩으로 기능은 빠르게 완성했는데, 화면을 여는 순간 \u0026ldquo;AI가 만든 티\u0026quot;가 나는 경험을 한 번쯤 해보셨을 겁니다.\n이번 글은 메이커 에반님의 영상 \u0026ldquo;바이브코딩 결과물, 3초만에 들통나는 이유\u0026ldquo;를 참고해서, 디자인 전공 지식 없이도 바로 적용 가능한 규칙 중심으로 재구성한 실전 요약입니다.\n핵심 요약 영상의 메시지는 단순합니다.\n바이브 코딩 결과물이 어색해 보이는 이유는 \u0026ldquo;감각 부족\u0026quot;보다 \u0026ldquo;규칙 부재\u0026quot;에 가깝다. 색/도구/컴포넌트 선택을 임의로 하지 말고, 일관성 유지에 유리한 경로를 고정해야 한다. 특히 디자인 단계에서 토큰이 과소모되면 AI 출력 품질과 일관성이 함께 무너질 수 있다. 즉, 디자인은 센스 싸움이 아니라 초기 규칙 세팅 싸움이라는 이야기입니다.\n왜 바이브 코딩 결과물이 금방 들통날까? 영상에서 지적하는 전형적인 신호는 다음과 같습니다.\n버튼/카드/여백의 기준이 화면마다 다름 강조색이 문맥 없이 남발됨 페이지별 폰트/톤/간격 리듬이 깨짐 기능은 잘 동작하는데, 시각적 시스템이 없어서 결과물이 \u0026ldquo;임시 화면\u0026quot;처럼 보이는 상태입니다.\n규칙 1) 컬러는 \u0026ldquo;직접 고르기\u0026quot;보다 팔레트에서 고정하기 영상에서는 색상을 임의로 지정하는 습관을 가장 큰 문제로 봅니다.\n\u0026ldquo;파란색으로 해줘\u0026quot;처럼 모호하게 지시하면 매번 다른 색조가 섞입니다. 회색/배경/강조색 간 조화가 깨지면서 전체 완성도가 급격히 떨어집니다. 추천 흐름은 다음과 같습니다.\n팔레트 생성 도구(영상 예시: coolors.co)에서 조합을 먼저 고른다. HEX 코드를 그대로 프롬프트/설정에 넣는다. 중간에 \u0026ldquo;조금 더 진하게\u0026rdquo; 같은 즉흥 수정을 최소화한다. 핵심은 \u0026ldquo;예쁜 색\u0026quot;을 찾는 게 아니라 같은 색 체계를 끝까지 유지하는 것입니다.\n규칙 2) 색은 많이 쓰지 말고, 메인/서브 2개로 제한하기 영상에서 반복 강조하는 포인트는 \u0026ldquo;색을 줄여야 깔끔해진다\u0026quot;입니다.\n메인 컬러: CTA, 핵심 강조 서브 컬러: 보조 배경/상태 표현 나머지: 흰색/검정/회색 계열 중심 여러 포인트 컬러를 동시에 쓰면 UI가 정보 구조를 잃고, 시선이 분산됩니다.\n바이브 코딩에서는 특히 이 제한이 중요합니다. 제약이 없으면 AI가 화면마다 다른 해석을 하기 쉽기 때문입니다.\n규칙 3) UI 생성 도구를 쓸 때는 \u0026ldquo;정확한 입력\u0026quot;으로 일관성 확보하기 영상 예시 도구는 Stitch입니다. 도구 자체보다 중요한 건 입력 방식입니다.\n색상 지시는 이름이 아니라 HEX 코드로 전달 레퍼런스 묘사는 한국어 한 줄보다 영문으로 구체적으로 전달 예: \u0026ldquo;토스처럼 깔끔하게\u0026quot;보다 \u0026ldquo;clean mobile finance app style, high contrast hierarchy, generous whitespace, compact cards\u0026rdquo; 같은 식으로 스타일 힌트를 구체화합니다.\n결과적으로 프롬프트의 모호성을 줄일수록 결과물 편차도 줄어듭니다.\n규칙 4) 디자인을 MCP로 직접 조작하는 흐름은 신중하게 영상에서는 디자인 단계에서 MCP를 과도하게 사용하는 접근을 비추천합니다.\n논리는 명확합니다.\n컨텍스트가 길어질수록 토큰 소모가 커짐 토큰 압박이 생기면 앞서 만든 시각 규칙을 모델이 안정적으로 유지하지 못함 수정이 반복될수록 컴포넌트 스타일이 흔들릴 가능성이 커짐 모든 팀/상황에 100% 동일하게 적용되는 법칙은 아니지만, \u0026ldquo;디자인 일관성 유지\u0026quot;가 1순위인 초기 단계에서는 충분히 현실적인 경고입니다.\n규칙 5) MCP 대신 \u0026ldquo;디자인 스킬 문서\u0026quot;를 먼저 고정하기 영상에서 제안하는 대안은, 디자인 규칙을 문서화해 반복 참조하게 만드는 방식입니다.\n예를 들어 .claude/skills 또는 프로젝트 가이드 문서에 아래를 고정합니다.\nprimary / secondary color spacing scale (예: 4, 8, 12, 16, 24) radius / shadow 규칙 typography scale 버튼/입력/카드 상태 규칙 이렇게 해두면 AI는 매번 \u0026ldquo;새로 디자인\u0026quot;하는 대신 \u0026ldquo;기존 규칙에 맞춰 생성\u0026quot;하게 됩니다.\n규칙 6) Next.js에서는 스타일 커스터마이징이 쉬운 UI 시스템을 고르기 영상 후반부에서는 Next.js 기반 바이브 코딩에서 shadcn/ui를 추천합니다.\n핵심 이유는 커스터마이징 경로가 단순하기 때문입니다.\n컴포넌트 소스가 프로젝트 내부에 있어 AI가 직접 수정하기 쉽고 디자인 토큰/테마를 일관되게 반영하기 유리하며 \u0026ldquo;프레임워크 기본 톤\u0026quot;과 싸우는 비용을 줄일 수 있습니다 특정 라이브러리가 절대적인 정답은 아니지만, 바이브 코딩에서는 AI가 안전하게 수정 가능한 구조가 생산성에 큰 영향을 줍니다.\n영상 기반 실행 순서 (바로 적용 버전) 영상 내용을 실무 순서로 다시 정리하면 아래와 같습니다.\n팔레트 도구에서 색 조합 1개를 고른다. 메인/서브 2색만 확정한다. 프로젝트 시작 시점에 컬러/간격/타입 규칙을 먼저 설정한다. UI 생성 프롬프트에는 HEX 코드 + 구체적인 영문 스타일 설명을 넣는다. 디자인 규칙 문서를 고정해 AI가 반복 참조하도록 만든다. 기능 개발 전부터 동일 규칙으로 컴포넌트를 생성한다. 여기서 가장 중요한 건 3번입니다. \u0026ldquo;기능 먼저, 디자인은 나중\u0026quot;으로 가면 결국 전체 화면을 다시 손보게 됩니다.\n개인적으로 중요하게 본 포인트 이 영상의 강점은 \u0026ldquo;감각\u0026quot;을 가르치지 않고 \u0026ldquo;재현 가능한 프로세스\u0026quot;를 제시한다는 점입니다.\n바이브 코딩의 본질은 빠른 생성이고, 빠른 생성의 약점은 일관성 붕괴입니다. 그래서 결국 승부는 더 멋진 프롬프트가 아니라 더 단순한 규칙을 먼저 고정하는 습관에서 갈립니다.\n마무리 바이브 코딩 결과물이 어색해 보이는 건 실력 부족이 아니라, 대부분 규칙 없는 상태에서 생성을 반복했기 때문입니다.\n이번 영상 기준으로는 색상 제한, 프롬프트 명확화, 토큰 관리, 컴포넌트 구조 선택까지 6가지 원칙만 지켜도 품질 체감이 분명히 달라집니다. 다음 프로젝트에서는 \u0026ldquo;한 번 더 잘 만들기\u0026quot;보다 \u0026ldquo;처음부터 같은 규칙으로 만들기\u0026quot;를 먼저 적용해 보시길 추천합니다.\n참고 YouTube: 바이브코딩 결과물, 3초만에 들통나는 이유 Coolors shadcn/ui ","date":"2026-02-17","permalink":"/post/2026/2026-02-18-vibe-coding-design-rules/","section":"post","summary":"바이브 코딩으로 기능은 빠르게 완성했는데, 화면을 여는 순간 \u0026ldquo;AI가 만든 티\u0026quot;가 나는 경험을 한 번쯤 해보셨을 겁니다.\n이번 글은 메이커 에반님의 영상 \u0026ldquo;바이브코딩 결과물, 3초만에 들통나는 이유\u0026ldquo;를 참고해서, 디자인 전공 지식 없이도 바로 적용 가능한 규칙 중심으로 재구성한 실전 요약입니다.\n","title":"바이브 코딩 디자인, 실무에서 바로 쓰는 6가지 규칙"},{"content":"Claude Code를 활용하는 개발자라면 토큰 최적화는 비용과 성능을 모두 좌우하는 핵심 요소입니다. Claude Code 토큰 최적화 전략을 한 번에 정리해보겠습니다.\n핵심 요약 Claude Code 토큰 최적화는 크게 두 축입니다.\n프롬프트/세션 습관 최적화 MCP 도구 로딩 최적화 기본 사용자는 1번만 제대로 해도 효과가 크고, MCP를 많이 쓰는 사용자라면 2번이 비용 차이를 크게 만듭니다.\n1) 프롬프트는 하이브리드로 작성하기 \u0026ldquo;명령은 영어, 설명은 한국어\u0026quot;입니다.\n명령어/기술 용어/파일명/함수명은 영어 유지 보충 설명만 짧게 한국어 사용 긴 문장 대신 작업 단위 불릿으로 요청 예시:\nCreate login feature - email/password 사용 - JWT auth - 로그인 실패 시 error message 한글 프롬프트는 영어 대비 토큰이 더 많이 소모될 수 있음 예시 비교: \u0026ldquo;이 코드를 리팩토링해주세요\u0026rdquo;(약 197토큰) vs \u0026ldquo;Please refactor this code\u0026rdquo;(약 39토큰) 의미: 같은 요청이라도 표현 방식에 따라 비용 차이가 크게 벌어질 수 있음 2) 프롬프트를 짧고 단위별로 쪼개기 한 번에 큰 요청을 보내면 입력 토큰도 늘고 출력도 길어집니다.\n인사말/중복 설명 제거 한 요청에 한 작업만 담기 \u0026ldquo;전체 리팩터링\u0026quot;보다 \u0026ldquo;파일 단위\u0026quot;로 나누기 핵심은 큰 작업을 작은 요청으로 분해하는 것입니다.\n3) 세션 컨텍스트를 계속 비우기 세션이 길어질수록 과거 문맥이 누적되어 토큰이 가파르게 증가합니다.\n/clear: 작업 단위 종료 후 초기화 /compact: 긴 대화를 요약 압축 /stats: 사용량을 수시로 확인 토큰 관리는 감이 아니라, 명령어로 확인하는 습관이 중요합니다.\n특히 유용한 부분은 \u0026ldquo;실수 방지\u0026quot;와 \u0026ldquo;재사용\u0026quot;입니다.\n너무 짧게 줄여 의미가 모호해지지 않게, 최소 맥락은 유지 반복 프롬프트는 .claude/commands/에 슬래시 명령으로 저장 큰 요청은 기능 단위로 분해해서 순차 처리 4) CLAUDE.md로 반복 설명 줄이기 프로젝트 규칙을 매번 프롬프트에 쓰지 말고 CLAUDE.md에 고정합니다.\n기술 스택 코드 스타일 자주 쓰는 명령어 프로젝트별 주의사항 반복 입력이 줄어들어 전체 토큰 사용량이 안정됩니다.\n5) MCP는 \u0026ldquo;많이 연결\u0026quot;보다 \u0026ldquo;선택 연결\u0026rdquo; MCP 서버가 많아질수록 세션 시작 시 도구 정의 토큰 오버헤드가 커진다는 점입니다.\n사용하지 않는 서버는 비활성화 필요할 때만 서버 활성화 작업별 MCP 구성을 분리해 최소 세트로 실행 실전 명령:\n/mcp /mcp disable \u0026lt;server-name\u0026gt; /mcp enable \u0026lt;server-name\u0026gt; 6) MCP 고급 최적화 포인트 MCP를 자주 쓰는 경우, 아래 순서로 점검하면 좋습니다.\n서버별 도구 수 확인 후 과다 서버 비활성화 중복/유사 도구를 통합해 설명 길이 축소 출력 토큰 상한(MAX_MCP_OUTPUT_TOKENS) 조정 단순 조회성 작업은 세션 외 직접 호출 방식 검토 참고로 Tool Search Tool/defer loading은 글 기준으로 API 베타 중심 내용이며, CLI 지원 범위는 시점에 따라 달라질 수 있습니다.\n\u0026ldquo;CLI에서 지금 당장 할 수 있는 최적화\u0026quot;입니다.\n--allowedTools/--disallowedTools로 불필요한 도구 노출을 제한 작업 성격별로 --mcp-config를 분리해 최소 서버 세트로 시작 단순 조회는 mcp-cli call로 세션 없이 직접 호출해 오버헤드 회피 Tool Search Tool은 API 베타 맥락이므로 CLI 기능과 구분해서 이해 통합 체크리스트 작업 시작 전에 아래 7가지를 확인하세요.\n명령어를 영어 중심으로 썼는가? 요청을 한 작업 단위로 쪼갰는가? 불필요한 인사말/중복 설명을 제거했는가? 필요한 파일만 선택해서 전달했는가? 새 작업 전에 /clear 또는 /compact를 실행했는가? /stats로 사용량을 점검했는가? 사용하지 않는 MCP 서버를 비활성화했는가? 마무리 요약하면, 일반 사용자는 프롬프트/세션 습관 최적화만으로도 체감 절감이 크고, MCP 중심 워크플로우에서는 도구 로딩 관리가 추가로 큰 차이를 만듭니다.\n두 전략을 함께 적용하면 비용, 속도, 정확도 균형을 가장 안정적으로 가져갈 수 있습니다.\n참고 https://twofootdog.tistory.com/422 https://goddaehee.tistory.com/445 https://www.anthropic.com/engineering/advanced-tool-use ","date":"2026-02-16","permalink":"/post/2026/2026-02-16-claude-code-token-optimize/","section":"post","summary":"Claude Code를 활용하는 개발자라면 토큰 최적화는 비용과 성능을 모두 좌우하는 핵심 요소입니다. Claude Code 토큰 최적화 전략을 한 번에 정리해보겠습니다.\n","title":"Claude Code 토큰 최적화 총정리: 프롬프트 습관부터 MCP 전략까지"},{"content":"Claude Code 사용자라면, 무엇을 해결해주는지, 어떤 상황에서 쓰면 좋은지, 시작할 때 주의할 점은 무엇인지까지 실무 기준으로 정리해봤습니다.\n먼저 한눈에: 어떤 사이트를 언제 쓰면 좋을까? 빠르게 실전 템플릿을 붙여서 시작하고 싶다 -\u0026gt; aitmpl.com/skills 스킬을 대량 탐색하고 싶다 -\u0026gt; skillsmp.com 오픈 스킬 생태계 표준 디렉터리부터 보고 싶다 -\u0026gt; skills.sh 멀티 에이전트 오케스트레이션을 본격 도입하고 싶다 -\u0026gt; oh-my-claudecode 생태계 전체 레퍼런스를 한곳에서 훑고 싶다 -\u0026gt; awesome-claude-code 명령/페르소나/모드 중심 프레임워크가 필요하다 -\u0026gt; SuperClaude_Framework 1) AITMPL Skills https://www.aitmpl.com/skills\n이 사이트는 무엇인가? Claude Code Templates를 중심으로, 스킬/에이전트/커맨드/설정/훅/MCP/템플릿을 탐색하고 조합하는 허브입니다.\n핵심은 \u0026ldquo;컴포넌트 조합형\u0026quot;입니다. 즉, 한두 개 기능만 설치하는 게 아니라 개발 스택을 묶어서 가져가는 방식이 강합니다.\n강점 탐색 카테고리가 명확합니다: skills, agents, commands, settings, hooks, mcps, templates 스택 빌더처럼 선택한 구성을 커맨드로 바로 생성하는 흐름이 빠릅니다 기업/플랫폼별 묶음(OpenAI, Anthropic, GitHub 등)처럼 큐레이션이 있어 처음 진입이 쉽습니다 이런 경우에 추천 팀 온보딩할 때 \u0026ldquo;기본 개발 환경\u0026quot;을 빠르게 맞춰야 할 때 빈 프로젝트에서 Claude Code 운영 구성을 한 번에 세팅할 때 개별 스킬보다 \u0026ldquo;조합 가능한 스택\u0026quot;이 필요한 경우 주의할 점 템플릿 중심 사이트라서, 각 구성요소의 품질은 원본 저장소별로 편차가 있습니다 설치 전에 실제로 어떤 파일/권한/훅이 들어오는지 반드시 확인해야 합니다 시작 팁 먼저 skills와 agents만 최소 구성으로 선택합니다 로컬 테스트 후 hooks, mcps를 단계적으로 추가합니다 팀 저장소 반영 전에는 개인 환경에서 충돌을 먼저 확인합니다 2) SkillsMP https://skillsmp.com\n이 사이트는 무엇인가? 공개 GitHub 기반의 Agent Skill을 모아 검색/분류해주는 마켓플레이스입니다.\nSKILL.md 생태계를 중심으로, Claude Code뿐 아니라 Codex/ChatGPT 계열과의 호환성을 강조합니다.\n강점 스킬 규모가 매우 커서 \u0026ldquo;비슷한 문제를 이미 푼 스킬\u0026quot;을 찾기 좋습니다 키워드 + 의미 기반 검색(AI search)로 탐색 효율이 좋습니다 카테고리/인기도/최근 업데이트 관점으로 후보를 빠르게 줄일 수 있습니다 이런 경우에 추천 \u0026ldquo;내가 지금 필요한 스킬이 이미 존재하는지\u0026quot;부터 확인하고 싶을 때 도메인별(테스트, DevOps, 데이터, 문서화)로 실전 예시를 수집할 때 팀 내부 커스텀 스킬 설계 전에 벤치마크가 필요할 때 주의할 점 커뮤니티 수집형이므로 공식 품질 보증 저장소가 아닙니다 설치 전 SKILL.md와 포함 스크립트의 동작/권한을 직접 검토해야 합니다 인기 순위만 보고 도입하면 내 워크플로우와 맞지 않을 수 있습니다 시작 팁 문제를 먼저 문장으로 정의합니다 (예: \u0026ldquo;PR 리뷰 자동화\u0026rdquo;) 상위 후보 3개만 골라 SKILL.md와 허용 도구를 비교합니다 프로젝트 루트(.claude/skills)에 넣기 전에 개인 영역에서 먼저 검증합니다 3) Skills.sh https://skills.sh/\n이 사이트는 무엇인가? 오픈 에이전트 스킬 생태계를 모아 보여주는 디렉터리/리더보드입니다.\n핵심은 \u0026ldquo;설치 가능한 스킬을 빠르게 발견하고, 바로 가져와 실험\u0026quot;하는 흐름이고, 단일 에이전트에 묶이지 않는 점이 강점입니다.\n2) SkillsMP와 비교하면? 공통점: 둘 다 공개 스킬을 탐색하고 후보를 추리는 용도로 좋습니다 SkillsMP는 GitHub 기반 스킬 마켓플레이스 성격이 강해 \u0026ldquo;스킬 카탈로그 탐색\u0026quot;에 유리합니다 Skills.sh는 리더보드와 설치 진입점(npx skills add \u0026lt;owner/repo\u0026gt;)이 강조되어 \u0026ldquo;빠른 실험/도입\u0026rdquo; 흐름이 더 직관적입니다 실무에서는 SkillsMP로 후보를 넓게 모은 뒤, Skills.sh에서 실제 사용량/설치 편의성을 보고 최종 압축하는 방식이 효율적입니다 강점 스킬 리더보드와 검색이 있어 \u0026ldquo;지금 실제로 많이 쓰는 스킬\u0026quot;을 빠르게 파악할 수 있습니다 npx skills add \u0026lt;owner/repo\u0026gt;처럼 설치 진입점이 단순해 실험 속도가 빠릅니다 Claude Code를 포함해 다양한 에이전트 생태계를 함께 다뤄 비교 탐색이 쉽습니다 이런 경우에 추천 특정 문제(예: 테스트 자동화, 문서화, 디버깅)에 맞는 검증된 스킬 후보를 빠르게 찾고 싶을 때 팀 표준 스킬 세트를 만들기 전에 실사용 지표를 참고하고 싶을 때 단일 저장소 큐레이션보다 더 넓은 생태계에서 후보를 고르고 싶을 때 주의할 점 설치 편의성이 높아도, 스킬 품질/권한 범위는 저장소마다 다르므로 사전 검토가 필요합니다 리더보드 상위 스킬이 내 코드베이스 제약(언어, 도구, 보안 정책)과 항상 맞는 것은 아닙니다 시작 팁 내 병목을 한 문장으로 먼저 정의합니다 (예: \u0026ldquo;Vitest flaky 테스트 분석\u0026rdquo;) 상위 후보 2~3개만 골라 SKILL.md, 도구 권한, 실행 예시를 비교합니다 팀 반영 전에 개인/샌드박스 프로젝트에서 먼저 재현성 검증을 합니다 4) Oh My ClaudeCode https://github.com/Yeachan-Heo/oh-my-claudecode\n이 저장소는 무엇인가? Claude Code를 팀 단위로 운용할 때 필요한 멀티 에이전트 오케스트레이션 프레임워크입니다.\n핵심 메시지는 \u0026ldquo;Zero learning curve, Team-first orchestration\u0026quot;에 가깝고, 팀 모드/자동 위임/검증 루프를 강하게 밀고 있습니다.\n강점 팀 파이프라인(계획 -\u0026gt; 실행 -\u0026gt; 검증 -\u0026gt; 보정)처럼 단계형 워크플로우가 명확합니다 여러 오케스트레이션 모드(autopilot, ultrawork, ralph 등)로 상황별 선택이 가능합니다 운영 편의 기능(상태 추적, 비용 최적화, 자동 재개 유틸리티)이 잘 정리되어 있습니다 이런 경우에 추천 단일 프롬프트보다 \u0026ldquo;역할 분리 + 검증 루프\u0026quot;가 중요한 팀 장기 리팩터링/마이그레이션처럼 대형 작업을 구조적으로 돌리고 싶은 경우 개인 실험 단계를 넘어 팀 표준 워크플로우를 만들고 싶은 경우 주의할 점 기능이 많은 만큼 초기 학습 없이 바로 전면 도입하면 오히려 복잡해질 수 있습니다 기존 팀 규칙(CLAUDE.md, 훅, 커맨드 체계)과 충돌하는지 먼저 봐야 합니다 프로젝트 브랜딩명과 패키지명 차이 같은 설치 포인트를 확인해야 합니다 시작 팁 처음부터 모든 모드를 켜지 말고 team 또는 autopilot 하나만 선택합니다 \u0026ldquo;작은 리포 하나\u0026quot;에서 1주일 정도 운영해보고 룰을 고정합니다 통과 기준(테스트/타입체크/리뷰 기준)을 먼저 정의한 뒤 확장합니다 5) Awesome Claude Code https://github.com/hesreallyhim/awesome-claude-code\n이 저장소는 무엇인가? Claude Code 생태계 리소스를 폭넓게 모은 큐레이션 리스트입니다.\n스킬, 훅, 슬래시 커맨드, 툴링, 워크플로우, CLAUDE.md 예시까지 \u0026ldquo;지도\u0026quot;처럼 탐색할 수 있는 레퍼런스 허브에 가깝습니다.\n강점 카테고리 분류가 좋아서 \u0026ldquo;무엇을 찾아야 하는지 모를 때\u0026rdquo; 출발점이 됩니다 최신 추가 항목을 통해 생태계 변화 속도를 빠르게 파악할 수 있습니다 특정 프레임워크에 락인되지 않고 비교 탐색이 가능합니다 이런 경우에 추천 지금 당장 도구를 설치하기보다, 먼저 지형도를 그리고 싶을 때 팀 표준을 만들기 전에 대안들을 비교하고 싶을 때 Claude Code 학습 로드맵/참고 자료를 한 번에 모으고 싶을 때 주의할 점 큐레이션 저장소 특성상 항목 수가 많아 \u0026ldquo;선택 피로\u0026quot;가 생길 수 있습니다 모든 링크가 내 프로젝트 성숙도와 맞는 것은 아닙니다 시작 팁 카테고리 1개만 정해(예: Hooks) 30분 타임박스로 탐색합니다 \u0026ldquo;이번 주에 적용할 후보 2개\u0026quot;만 선정합니다 적용 후 효과를 기록하고 다음 카테고리로 넘어갑니다 6) SuperClaude Framework https://github.com/SuperClaude-Org/SuperClaude_Framework\n이 저장소는 무엇인가? Claude Code를 명령 체계/전문화 에이전트/행동 모드로 확장하는 구성 프레임워크입니다.\n핵심은 \u0026ldquo;구조화된 개발 플랫폼\u0026quot;처럼 쓰게 만드는 것이고, 커맨드 중심 운영과 MCP 연동 전략이 잘 정리되어 있습니다.\n강점 슬래시 커맨드 기반 운영 문서가 잘 되어 있어 재현성이 좋습니다 전용 에이전트와 모드 개념이 분리되어 역할 설계가 쉽습니다 연구/구현/테스트/운영 흐름을 하나의 프레임에서 다루기 좋습니다 이런 경우에 추천 커맨드 기반 개발 습관을 팀에 강하게 정착시키고 싶은 경우 \u0026ldquo;문서화된 규칙 + 반복 가능한 실행\u0026quot;이 중요한 조직 MCP를 붙여 자동화 범위를 넓히고 싶은 경우 주의할 점 버전별 설치 경로와 기능 상태(예: 향후 플러그인 계획)가 바뀔 수 있습니다 기능 확장 전에 현재 안정 버전의 설치/운영 가이드를 먼저 확인해야 합니다 시작 팁 공식 설치 가이드의 \u0026ldquo;현재 안정 버전\u0026rdquo; 절차만 먼저 따릅니다 핵심 커맨드 3개만 선정해 팀 공통 루틴으로 고정합니다 운영 로그를 보며 모드/서버를 점진적으로 늘립니다 상황별 추천 조합 A. 입문자/개인 개발자 Awesome Claude Code로 지형 파악 AITMPL에서 최소 템플릿 도입 SkillsMP로 필요한 스킬 1~2개만 추가 B. 팀 단위 자동화 초입 Oh My ClaudeCode 또는 SuperClaude 중 하나를 핵심 프레임으로 선택 나머지는 보조 레퍼런스/스킬 공급원으로 사용 C. 도구 실험을 빠르게 반복해야 하는 팀 SkillsMP + Awesome Claude Code로 후보 발굴 Oh My ClaudeCode/SuperClaude로 운영 체계화 마무리 핵심은 \u0026ldquo;많이 깔기\u0026quot;가 아니라 \u0026ldquo;문제-도구 매칭\u0026quot;입니다.\n사이트 6개를 다 써야 하는 게 아니라, 지금 내 병목을 가장 빨리 푸는 순서로 들어가면 됩니다.\n추천 시작 순서 하나만 남기면:\nawesome-claude-code로 선택지 파악 skillsmp로 구체 스킬 후보 압축 skills.sh로 실사용 지표/설치 흐름 확인 aitmpl로 초기 스택 구성 팀 단계에서 oh-my-claudecode 또는 superclaude 중 하나를 채택 참고 링크 AITMPL Skills SkillsMP Skills.sh Oh My ClaudeCode Awesome Claude Code SuperClaude Framework ","date":"2026-02-16","permalink":"/post/2026/2026-02-16-claude-code-sites-deep-guide/","section":"post","summary":"Claude Code 사용자라면, 무엇을 해결해주는지, 어떤 상황에서 쓰면 좋은지, 시작할 때 주의할 점은 무엇인지까지 실무 기준으로 정리해봤습니다.\n","title":"Claude Code 사용자라면 꼭 알아둘 사이트 6선: 스킬/에이전트 생태계 실전 가이드"},{"content":"\u0026ldquo;에이전트는 많이 만들었는데, 왜 자꾸 컨텍스트가 오염되지?\u0026rdquo;\n\u0026ldquo;읽기 전용 조사 작업인데 왜 메인 세션에서 토큰을 이렇게 많이 먹지?\u0026rdquo;\nClaude Code를 오래 쓰다 보면 결국 Subagent 설계가 생산성을 결정합니다.\n이 글은 Claude 공식 문서의 sub-agents를 중심으로, 실제로 바로 적용 가능한 방식으로 정리했습니다. 추가로 Agent SDK 관점과 멀티 에이전트 운영 사례를 함께 묶어서, \u0026ldquo;어디서부터 어떻게 시작하면 되는지\u0026quot;를 한 번에 이해할 수 있게 구성했습니다.\n1) Subagent가 정확히 뭔가? Subagent는 특정 작업을 위임받아 처리하는 전문화된 AI 워커입니다.\n핵심은 4가지입니다.\n독립 컨텍스트에서 실행됨 자체 시스템 프롬프트를 가짐 사용할 **도구 권한(tools/disallowedTools)**을 분리 가능 필요하면 모델(haiku, sonnet, opus, inherit)도 분리 가능 즉, \u0026ldquo;탐색/검토/수정\u0026quot;을 메인 세션에 다 몰아 넣지 않고, 역할별로 컨텍스트를 분리해서 운영할 수 있습니다.\n2) Subagent vs Agent Teams, 뭐가 다른가? 둘 다 멀티 에이전트처럼 보이지만 목적이 다릅니다.\nSubagent: 단일 세션 안에서 특정 작업을 위임받아 처리한 뒤 결과를 반환 Agent Teams: 여러 에이전트가 병렬로 돌아가며 서로 통신하고 조율하는 협업 구조 간단히 말하면:\n\u0026ldquo;코드베이스 조사만 빨리 해줘\u0026rdquo; -\u0026gt; Subagent \u0026ldquo;보안/성능/테스트 리뷰어를 팀으로 동시에 돌려줘\u0026rdquo; -\u0026gt; Agent Teams 3) 가장 빠른 시작 방법 (/agents) 가장 쉬운 방법은 Claude Code에서 /agents를 쓰는 것입니다.\n/agents 추천 흐름:\nCreate new agent 선택 User-level 또는 Project-level 선택 Generate with Claude로 초안 생성 도구 권한(읽기 전용/전체)과 모델 선택 저장 후 바로 호출 User-level은 여러 프로젝트에서 재사용할 때 좋고, Project-level(.claude/agents/)은 팀과 함께 버전 관리할 때 좋습니다.\n4) 수동으로 만들 때: Subagent 파일 템플릿 Subagent는 Markdown + YAML frontmatter 파일입니다.\n예: .claude/agents/code-reviewer.md\n--- name: code-reviewer description: 코드 변경 직후 품질/보안/유지보수성을 검토한다. 필요할 때 적극적으로 사용한다. tools: Read, Grep, Glob, Bash model: sonnet permissionMode: default --- 당신은 시니어 코드 리뷰어다. 변경 파일 중심으로 검토하고, 우선순위(critical/warning/suggestion)로 결과를 정리하라. 자주 쓰는 frontmatter 필드 name (필수): 에이전트 식별자 description (필수): Claude가 언제 이 에이전트를 호출할지 판단 기준 tools: 허용 도구 목록 disallowedTools: 금지 도구 목록 model: haiku / sonnet / opus / inherit permissionMode: default, acceptEdits, dontAsk, bypassPermissions, plan skills: 시작 시 주입할 스킬 목록 hooks: PreToolUse/PostToolUse/Stop 등 라이프사이클 훅 memory: user, project, local 범위 메모리 5) 실무 설계 원칙 (이거 먼저 지키면 실패 확률이 줄어듦) 원칙 A: 설명(description)을 가장 공들여 써라 Claude는 설명을 보고 라우팅합니다. 설명이 모호하면 호출 타이밍이 흔들립니다.\n나쁜 예: \u0026ldquo;코드 잘 보는 에이전트\u0026rdquo; 좋은 예: \u0026ldquo;코드 변경 직후 보안/성능/테스트 누락을 점검하는 리뷰 에이전트\u0026rdquo; 원칙 B: 최소 권한으로 시작하라 처음부터 Write/Edit/Bash를 다 열지 말고, 읽기 전용으로 검증한 뒤 필요한 권한만 확장하세요.\n원칙 C: 단일 책임으로 쪼개라 하나의 Subagent가 기획+구현+리뷰+배포까지 다 하게 만들면 다시 범용 에이전트가 됩니다.\nexplorer (읽기 전용 탐색) implementer (수정) reviewer (검증) 이렇게 분리하면 훨씬 안정적입니다.\n원칙 D: 토큰 폭탄 작업은 Subagent로 격리하라 대규모 로그 분석, 테스트 전체 실행, 문서 수집 같은 작업은 Subagent에 위임해서 메인 컨텍스트를 보호하세요.\n6) 블로그 자동화 관점에서의 Subagent 설계 예시 질문이 자주 나옵니다.\n\u0026ldquo;블로그 자동화를 할 때도 Subagent를 써야 하나요?\u0026rdquo;\n답은 Yes입니다. 특히 다음처럼 나누면 좋습니다.\nkeyword-researcher (읽기 전용) content-planner (읽기 + 정리) post-writer (쓰기 허용) seo-reviewer (읽기 전용 검수) 여기서 핵심은, 작성(post-writer) 권한을 다른 에이전트와 분리하는 것입니다. 그래야 잘못된 수정/덮어쓰기 리스크를 줄일 수 있습니다.\n7) Hook으로 안전장치 걸기 (고급) 권한만으로 부족할 때는 PreToolUse 훅으로 명령을 필터링할 수 있습니다.\n예를 들어 Bash는 허용하지만 위험 명령은 차단하도록 만들 수 있습니다.\nhooks: PreToolUse: - matcher: \u0026#34;Bash\u0026#34; hooks: - type: command command: \u0026#34;./scripts/validate-command.sh\u0026#34; 검증 스크립트에서 금지 패턴을 감지하면 종료 코드 2로 차단합니다.\n8) Agent SDK는 언제 필요한가? Subagent를 CLI 안에서 운영하는 단계 다음으로, 백엔드 서비스/워크플로우에 내장하려면 Agent SDK를 고려할 수 있습니다.\n장점: 앱/서버 코드에서 에이전트 실행 흐름을 직접 제어 가능 용도: 장기 세션 운영, 외부 시스템 연동, 커스텀 툴 체인 구성 다만, 처음에는 SDK부터 시작하기보다 Claude Code 내 Subagent로 설계 검증을 먼저 하는 편이 빠릅니다. 구조가 검증된 후 SDK로 올리는 것이 실패 비용이 낮습니다.\n9) 바로 써먹는 체크리스트 새 Subagent를 만들 때 아래 7가지만 확인하세요.\ndescription이 구체적인가? 기본 도구 권한이 최소 권한인가? 모델 선택 이유가 명확한가? (속도/비용/품질) 단일 책임이 지켜졌는가? 결과 출력 형식(예: 우선순위/파일경로)이 정해졌는가? 실패 시 재시도 규칙이 있는가? 팀 공유가 필요하면 .claude/agents/에 버전 관리되는가? 마무리 Subagent를 잘 만들면 \u0026ldquo;AI가 잘 답한다\u0026quot;를 넘어 \u0026ldquo;AI 워크플로우가 재현 가능하게 굴러간다\u0026rdquo; 단계로 올라갑니다.\n처음에는 복잡하게 시작하지 말고,\n읽기 전용 explorer 하나 수정 전용 implementer 하나 검수 전용 reviewer 하나 이 3개만 먼저 만들어 보세요.\n그 다음에 hooks, memory, skills를 붙이면 됩니다.\n참고 자료 Claude Code 공식 문서 (Subagents): https://code.claude.com/docs/ko/sub-agents Bind AI 블로그 (Claude Agent SDK 개요): https://blog.getbind.co/how-to-create-agents-with-claude-agents-sdk/ zoeylog (클로드 코드 자동화 사례): https://zoey.day/blog?post=1q3vdn2px1w382xy49pr ","date":"2026-02-16","permalink":"/post/2026/2026-02-16-claude-code-subagents-guide/","section":"post","summary":"\u0026ldquo;에이전트는 많이 만들었는데, 왜 자꾸 컨텍스트가 오염되지?\u0026rdquo;\n\u0026ldquo;읽기 전용 조사 작업인데 왜 메인 세션에서 토큰을 이렇게 많이 먹지?\u0026rdquo;\nClaude Code를 오래 쓰다 보면 결국 Subagent 설계가 생산성을 결정합니다.\n이 글은 Claude 공식 문서의 sub-agents를 중심으로, 실제로 바로 적용 가능한 방식으로 정리했습니다. 추가로 Agent SDK 관점과 멀티 에이전트 운영 사례를 함께 묶어서, \u0026ldquo;어디서부터 어떻게 시작하면 되는지\u0026quot;를 한 번에 이해할 수 있게 구성했습니다.\n","title":"Claude Code Subagent 만들기: 실무에서 바로 쓰는 설계/구현 가이드"},{"content":"터미널 작업이 길어질수록 이런 상황이 자주 생깁니다.\nSSH 연결이 끊겨서 실행 중이던 작업이 날아감 프로젝트마다 터미널 창을 여러 개 열어두다가 관리가 안 됨 같은 명령을 여러 서버에 반복 입력해야 함 이때 가장 확실한 해결책이 tmux입니다. 이 글에서는 처음 쓰는 분도 바로 따라할 수 있게 기본 개념부터 실무 팁까지 정리했습니다.\n1. tmux가 정확히 뭐가 좋은가? tmux는 터미널 멀티플렉서입니다. 하나의 터미널 안에서 세션/윈도우/패널을 만들고, 분리(detach)했다가 다시 붙을(attach) 수 있습니다.\n핵심 구조는 3가지만 기억하면 됩니다.\nSession: 작업 공간(프로젝트 단위) Window: 탭 Pane: 탭 안 분할 화면 즉, 프로젝트마다 Session 하나씩 두고, 빌드/서버/로그를 Pane으로 분리하면 작업 흐름이 안정됩니다.\n2. 가장 먼저 익혀야 할 기본 명령 2.1 세션 생성/접속/목록 # 새 세션 생성 tmux new -s myproj # 세션 목록 tmux ls # 세션 다시 붙기 tmux attach -t myproj # 접속 중이던 클라이언트 강제 분리 후 붙기 tmux attach -d -t myproj 아래 한 줄은 실무에서 정말 많이 씁니다.\n# 있으면 붙고, 없으면 생성 tmux new -As myproj 2.2 분리(detach) tmux 내부에서:\nCtrl+b, d 서버 작업 중 SSH가 끊겨도 세션은 살아있어서 다시 attach하면 이어서 작업할 수 있습니다.\n3. 기본 단축키 치트시트 tmux 기본 prefix는 Ctrl+b입니다.\n3.1 빠른 시작 (자주 쓰는 핵심) 키 기능 설명 Ctrl+b c 새 윈도우 현재 세션에 새 window 생성 Ctrl+b n / Ctrl+b p 윈도우 이동 다음/이전 window로 전환 Ctrl+b % 좌우 분할 pane을 수평으로 분할 Ctrl+b \u0026quot; 상하 분할 pane을 수직으로 분할 Ctrl+b + 방향키 패널 이동 인접 pane으로 포커스 이동 Ctrl+b x 패널 종료 현재 pane 닫기 Ctrl+b z 패널 줌 현재 pane 확대/복원 Ctrl+b [ 복사 모드 copy mode 진입 Ctrl+b ] 붙여넣기 최근 버퍼 붙여넣기 Ctrl+b ? 도움말 전체 키바인딩 목록 표시 3.2 윈도우 관리 치트시트 키 기능 설명 Ctrl+b c 새 윈도우 window 생성 Ctrl+b 0~9 번호 이동 해당 번호 window로 즉시 전환 Ctrl+b ' 번호 입력 이동 window 번호를 입력해 전환 Ctrl+b n / Ctrl+b p 다음/이전 window 순서 이동 Ctrl+b l 마지막 윈도우 직전에 보던 window로 복귀 Ctrl+b , 이름 변경 현재 window 이름 변경 Ctrl+b \u0026amp; 윈도우 종료 현재 window 닫기(확인 프롬프트) Ctrl+b w 트리 선택 session/window/pane 트리에서 선택 Ctrl+b . 인덱스 이동 현재 window 번호 재배치 3.3 세션 관리 치트시트 키 기능 설명 Ctrl+b s 세션 목록 session 트리 열기 Ctrl+b $ 세션 이름 변경 현재 session 이름 변경 Ctrl+b d detach session은 유지하고 빠져나오기 Ctrl+b D 클라이언트 관리 붙어있는 client 목록/분리 Ctrl+b ( 이전 세션 이전 session으로 전환 Ctrl+b ) 다음 세션 다음 session으로 전환 3.4 패널/레이아웃 관리 치트시트 키 기능 설명 Ctrl+b % / Ctrl+b \u0026quot; 분할 좌우/상하 분할 Ctrl+b o 다음 패널 pane 순환 이동 Ctrl+b q 패널 번호 표시 번호 보고 숫자로 즉시 이동 Ctrl+b ; 마지막 패널 직전에 활성화한 pane으로 복귀 Ctrl+b { / Ctrl+b } 패널 위치 교환 이전/다음 pane과 스왑 Ctrl+b z 확대/복원 현재 pane zoom 토글 Ctrl+b Space 레이아웃 순환 pane layout 변경 Ctrl+b ! 패널 분리 현재 pane을 새 window로 분리 3.5 셸 명령 치트시트 (세션/윈도우) 명령 기능 설명 tmux ls 세션 목록 현재 살아있는 session 확인 tmux new -s myproj 세션 생성 이름 지정해 새 session 생성 tmux new -As myproj attach-or-create 있으면 붙고 없으면 생성 tmux attach -t myproj 세션 접속 특정 session에 붙기 tmux attach -d -t myproj 강제 접속 다른 client를 분리하고 붙기 tmux kill-session -t myproj 세션 종료 특정 session 종료 tmux kill-server 전체 종료 tmux server 및 모든 session 종료 4. 실무에서 바로 체감되는 꿀팁 4.1 여러 서버에 같은 명령 동시에 실행 패널 동기화:\n# tmux 명령 프롬프트(Ctrl+b :)에서 실행 setw synchronize-panes on 끄기:\nsetw synchronize-panes off 배포, 로그 확인, 동일 명령 반복 작업에서 매우 유용합니다.\n4.2 패널 번호 보면서 즉시 이동 Ctrl+b q 패널 번호가 잠깐 뜨고 숫자 키로 바로 이동할 수 있습니다.\n4.3 자주 쓰는 윈도우 레이아웃 회전 Ctrl+b Space 분할 레이아웃을 순환하면서 보기 편한 형태로 빠르게 전환할 수 있습니다.\n4.4 복잡한 패널에서 일시적으로 집중 Ctrl+b z 현재 패널을 전체 화면처럼 써서 디버깅/로그 추적에 좋습니다.\n4.5 tmux 설정 즉시 반영 .tmux.conf 수정 후 재실행 없이 반영:\ntmux source-file ~/.tmux.conf 5. 추천 .tmux.conf 시작 템플릿 아래는 입문자에게 무난한 시작점입니다.\n# prefix를 Ctrl+a로 변경 (선택) unbind C-b set -g prefix C-a bind C-a send-prefix # 마우스 사용 set -g mouse on # 인덱스를 1부터 set -g base-index 1 setw -g pane-base-index 1 # copy mode를 vi 스타일로 setw -g mode-keys vi # 설정 리로드 단축키 bind r source-file ~/.tmux.conf \\; display-message \u0026#34;tmux.conf reloaded\u0026#34; prefix 변경은 취향입니다. 기본 Ctrl+b가 익숙하면 그대로 써도 됩니다.\n6. 플러그인: 이것만 알아도 생산성 급상승 6.1 TPM (Tmux Plugin Manager) 설치:\ngit clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm .tmux.conf 하단:\nset -g @plugin \u0026#39;tmux-plugins/tpm\u0026#39; set -g @plugin \u0026#39;tmux-plugins/tmux-sensible\u0026#39; run \u0026#39;~/.tmux/plugins/tpm/tpm\u0026#39; 플러그인 설치/업데이트:\nprefix + I: 설치 prefix + U: 업데이트 6.2 tmux-resurrect: 세션 저장/복원 set -g @plugin \u0026#39;tmux-plugins/tmux-resurrect\u0026#39; prefix + Ctrl-s: 저장 prefix + Ctrl-r: 복원 재부팅 후 세션/윈도우/패널 레이아웃을 되살릴 때 유용합니다.\n6.3 tmux-continuum: 자동 저장/자동 복원 set -g @plugin \u0026#39;tmux-plugins/tmux-resurrect\u0026#39; set -g @plugin \u0026#39;tmux-plugins/tmux-continuum\u0026#39; set -g @continuum-restore \u0026#39;on\u0026#39; 주의할 점:\ncontinuum은 상태줄(status)이 켜져 있어야 주기 저장이 동작 일부 테마/플러그인이 status-right를 덮어쓰면 자동 저장이 멈출 수 있음 7. 복사/클립보드에서 자주 막히는 포인트 tmux 복사 모드와 시스템 클립보드 연동은 터미널 종류/버전에 따라 다르게 동작합니다.\n기본적으로 확인할 것:\ntmux show -s set-clipboard tmux info | grep Ms 일반적인 권장값:\nset -s set-clipboard external 왜 external을 권장하나?\non은 tmux 내부 앱이 클립보드 설정에 영향을 줄 수 있어 보안상 주의 필요 external은 그 범위를 제한해서 상대적으로 안전함 Linux에서 외부 도구를 쓰는 경우(예: xsel, xclip)는 DISPLAY나 툴 동작 이슈가 있을 수 있습니다. 환경에 따라 pbcopy(macOS) 등 OS별 방식으로 맞추는 것이 안전합니다.\n8. 실전 운영 패턴 (권장) 프로젝트마다 세션 하나를 고정해서 쓰면 좋습니다.\ntmux new -As backend tmux new -As frontend tmux new -As ops 각 세션에서 권장 패널 구성 예시:\npane 1: 앱 서버 실행 pane 2: 테스트/빌드 pane 3: 로그 tail pane 4: git 작업 이 패턴만 지켜도 터미널 창 난립이 거의 사라집니다.\n9. 마무리 tmux는 처음 1~2일만 어색하고, 그 이후에는 “없으면 불편한” 도구가 됩니다.\n시작은 간단히:\ntmux new -As myproj 습관화 Ctrl+b d로 분리/복귀 익히기 자주 쓰는 키 8~10개만 먼저 외우기 필요하면 TPM + resurrect/continuum 추가 이 순서로 가면 무리 없이 실전에 정착할 수 있습니다.\n참고 링크 tmux 공식 매뉴얼: https://man7.org/linux/man-pages/man1/tmux.1.html tmux 공식 위키(Home): https://github.com/tmux/tmux/wiki tmux Getting Started: https://github.com/tmux/tmux/wiki/Getting-Started tmux Clipboard 문서: https://github.com/tmux/tmux/wiki/Clipboard TPM: https://github.com/tmux-plugins/tpm tmux-resurrect: https://github.com/tmux-plugins/tmux-resurrect tmux-continuum: https://github.com/tmux-plugins/tmux-continuum ","date":"2026-02-14","permalink":"/post/2026/2026-02-14-tmux-guide/","section":"post","summary":"터미널 작업이 길어질수록 이런 상황이 자주 생깁니다.\nSSH 연결이 끊겨서 실행 중이던 작업이 날아감 프로젝트마다 터미널 창을 여러 개 열어두다가 관리가 안 됨 같은 명령을 여러 서버에 반복 입력해야 함 이때 가장 확실한 해결책이 tmux입니다. 이 글에서는 처음 쓰는 분도 바로 따라할 수 있게 기본 개념부터 실무 팁까지 정리했습니다.\n","title":"tmux 사용법 완전 정리: 세션 관리부터 생산성 꿀팁까지"},{"content":"Claude Opus 4.6 출시와 함께 Agent Teams(다중 에이전트 팀) 기능이 공개되었습니다. 이 기능을 통해 여러 개의 Claude 인스턴스가 실제 개발 팀처럼 병렬로 협업할 수 있게 되었죠. 많은 개발자분이 Agent Teams를 어떻게 활성화하는지, 어떻게 실행하는지, 그리고 기존 Subagent와는 무엇이 다른지 궁금해하고 계십니다.\n서론: Agent Teams 소개 단일 에이전트의 한계 기존의 AI 코딩 도구는 단일 모델이 모든 작업을 처리하는 방식이었습니다. 이는 복잡한 대형 프로젝트에서 다음과 같은 문제가 있었습니다:\n컨텍스트 제한: 단일 모델의 컨텍스트 윈도우로 대형 코드베이스 분석 어려움 직렬 처리: 한 번에 한 가지 작업만 가능하여 병렬 처리 불가 특화 부족: 범용적인 목적의 모델로 특정 도메인 지식 깊이 부족 확장성 부재: 팀 단위 협업 시 지각이 공유하는 지식 관리 어려움 Agent Teams의 해결책 Claude Code Agent Teams는 다음과 같은 문제들을 해결합니다:\n분산 처리: 여러 에이전트가 병렬로 작업하여 시간 단축 역할 분담: 각 에이전트가 특정 역할에 특화된 전문가 역할 지식 공유: 팀원 간 자연스러운 의사소통과 지식 공유 통합 관리: 팀 리더가 전체 작업 흐름을 조정하고 관리 핵심 가치 이 글을 읽고 나면 활성화 설정부터 명령어 실행, 작업 할당, 팀 협업에 이르기까지 Agent Teams의 전체 사용 프로세스를 마스터하여 즉시 다중 에이전트 프로그래밍을 시작할 수 있습니다.\nAgent Teams 아키텍처 다이어그램 graph TB\rsubgraph Lead[\"Lead Agent (팀 리더)\"]\rL1[\"팀 생성\"]\rL2[\"작업 할당\"]\rL3[\"결과 요약\"]\rL4[\"조율 및 관리\"]\rend\rsubgraph TaskList[\"Task List (공유 작업 목록)\"]\rT1[\"작업 생성\"]\rT2[\"의존성 추적\"]\rT3[\"상태 관리\"]\rT4[\"파일 잠금\"]\rend\rsubgraph Teammates[\"Teammates (팀원)\"]\rM1[\"작업 수락\"]\rM2[\"결과 보고\"]\rM3[\"상태 업데이트\"]\rend\rsubgraph Mailbox[\"Mailbox (메시지 시스템)\"]\rB1[\"개별 메시지\"]\rB2[\"브로드캐스트\"]\rend\rL1 --\u003e T1\rL2 --\u003e T2\rL3 --\u003e T4\rM1 --\u003e T3\rM2 --\u003e L3\rM1 -.-\u003e|P2P 통신| B1\rM2 -.-\u003e|P2P 통신| B2\rstyle Lead fill:#3fa4ff,stroke:#036,stroke-width:2px\rstyle TaskList fill:#ffeb3b,stroke:#036,stroke-width:2px\rstyle Teammates fill:#4caf50,stroke:#036,stroke-width:2px\rstyle Mailbox fill:#ff5722,stroke:#036,stroke-width:2px핵심 개념: 4가지 구성 요소 Agent Teams는 4가지 핵심 구성 요소로 이루어져 있습니다.\n구성 요소 역할 설명 Lead Agent 팀 리더 메인 Claude Code 세션으로, 팀 생성, 작업 할당, 결과 요약을 담당합니다. Teammate 팀원 독립된 Claude Code 인스턴스로, 할당된 작업을 각자 수행합니다. Task List 공유 작업 목록 모든 구성원이 볼 수 있는 작업 보드로, 할당, 의존성, 상태 추적을 지원합니다. Mailbox 메시지 시스템 팀원 간의 통신 채널로, 개인 메시지와 브로드캐스트를 지원합니다. Subagent와의 비교 비교 항목 Subagent(하위 에이전트) Agent Teams(팀) 통신 방식 메인 에이전트에게만 결과 보고 팀원 간 직접 통신 가능 조율 방식 메인 에이전트가 모든 것을 관리 공유 작업 목록 + 자율적 할당 컨텍스트 독립된 컨텍스트, 결과를 호출자에게 반환 독립된 컨텍스트, 완전한 자율성 최적 시나리오 결과만 필요한 집중 작업 토론과 협업이 필요한 복잡한 작업 토큰 소모 비교적 낮음 (결과만 메인 컨텍스트로 취합) 높음 (각 팀원이 독립된 Claude 인스턴스임) 💡 중요 차이점: Subagent가 \u0026lsquo;상하 보고\u0026rsquo; 모델이라면, Agent Teams는 \u0026lsquo;팀 협업\u0026rsquo; 모델입니다. 작업에 여러 명의 토론, 관점 교환, 또는 서로 다른 모듈의 병렬 처리가 필요하다면 Agent Teams가 더 나은 선택입니다.\nSubagent vs Agent Teams 시각적 비교 graph LR\rsubgraph Subagent[\"Subagent (하위 에이전트)\"]\rS1[Main Agent]\rS2[Subagent 1]\rS3[Subagent 2]\rS1 -.-\u003e|결과만 보고| S2\rS1 -.-\u003e|결과만 보고| S3\rS2 --\u003e|결과 반환| S1\rS3 --\u003e|결과 반환| S1\rend\rsubgraph Teams[\"Agent Teams (팀)\"]\rT1[Lead Agent팀 리더]\rT2[Teammate 1]\rT3[Teammate 2]\rT4[Teammate 3]\rT5[Task List공유 작업 목록]\rT1 --\u003e|작업 할당| T5\rT2 --\u003e|작업 선택| T5\rT3 --\u003e|작업 선택| T5\rT4 --\u003e|작업 선택| T5\rT2 \u003c-.-\u003e|P2P 직접 통신| T3\rT3 \u003c-.-\u003e|P2P 직접 통신| T4\rT2 \u003c-.-\u003e|P2P 직접 통신| T4\rT2 -.-\u003e|보고| T1\rT3 -.-\u003e|보고| T1\rT4 -.-\u003e|보고| T1\rend\rstyle Subagent fill:#f5f5f5,stroke:#036,stroke-width:2px\rstyle Teams fill:#e8f5e9,stroke:#036,stroke-width:2px\rstyle S1 fill:#ffcc80,stroke:#036\rstyle T1 fill:#3fa4ff,stroke:#036\rstyle T5 fill:#fff59d,stroke:#036활성화 방법: 3단계 Agent Teams는 기본적으로 비활성화되어 있으며, 수동으로 활성화해야 합니다.\n1단계: 실험적 기능 활성화하기 방법 A — 설정 파일 (권장)\nClaude Code의 settings.json 파일에 다음 내용을 추가하세요.\n{ \u0026#34;env\u0026#34;: { \u0026#34;CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS\u0026#34;: \u0026#34;1\u0026#34; } } 방법 B — 환경 변수\n# .bashrc 또는 .zshrc 파일에 추가 export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1 방법 C — 단일 세션\nCLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1 claude 2단계: 자연어로 Agent Teams 트리거하기 /agent-teams와 같은 별도의 슬래시 명령어는 없습니다. 기능을 활성화한 후에는 원하는 팀 구성을 자연어로 설명하기만 하면 됩니다.\nPR #142를 검토하기 위한 에이전트 팀을 생성해줘. 다음 세 명의 검토자를 만들어줘:\r- 보안 취약점 집중 검토자\r- 성능 영향 확인자\r- 테스트 커버리지 검증자\r각자 검토 후 발견된 사항을 보고하게 해줘. 또는 더 간단하게 요청할 수도 있습니다.\nCreate a team with 4 teammates to refactor these modules in parallel.\rUse Sonnet for each teammate. Claude가 자동으로 팀을 생성하고, 팀원을 배정하며, 업무를 할당합니다. 또한 Claude가 판단하기에 현재 작업이 병렬 처리에 적합하다고 생각되면 먼저 팀 생성을 제안할 수도 있습니다. 이 경우 사용자의 확인을 거친 후 진행됩니다.\n3단계: 표시 모드 선택하기 표시 모드 설명 적용 환경 in-process (기본값) 모든 팀원이 메인 터미널에서 실행됨 VS Code를 포함한 모든 터미널 tmux 각 팀원이 독립된 패널에서 실행됨 tmux 또는 iTerm2 필요 auto 자동 판단 tmux 환경이면 화면 분할, 아니면 in-process # 명령행에서 지정 claude --teammate-mode tmux # 또는 settings.json에서 설정 { \u0026#34;teammateMode\u0026#34;: \u0026#34;tmux\u0026#34; } 💡 팁: 처음 사용하신다면 in-process 모드로 시작해 보시고, 익숙해지면 tmux 화면 분할 모드를 시도해 보시는 것을 추천합니다.\n활성화 3단계 플로우차트 flowchart LR\rA[시작] --\u003e B[1단계실험적 기능 활성화]\rB --\u003e C{활성화 방법 선택}\rC --\u003e C1[설정 파일]\rC --\u003e C2[환경 변수]\rC --\u003e C3[단일 세션]\rC1 --\u003e D[2단계자연어 팀 생성]\rC2 --\u003e D\rC3 --\u003e D\rD --\u003e E[3단계표시 모드 선택]\rE --\u003e F{모드 선택}\rF --\u003e F1[in-process]\rF --\u003e F2[tmux]\rF --\u003e F3[auto]\rF1 --\u003e G[✅ Agent Teams 준비 완료]\rF2 --\u003e G\rF3 --\u003e G\rstyle B fill:#e3f2fd,stroke:#036\rstyle D fill:#fff3e0,stroke:#036\rstyle E fill:#e8f5e9,stroke:#036\rstyle G fill:#c8e6c9,stroke:#036,stroke-width:2px조작 가이드 키보드 단축키 요약 Agent Teams가 실행 중일 때 다음 단축키를 사용할 수 있어요.\n단축키 기능 Shift+Up/Down 다른 팀원 전환/선택 Enter 선택한 팀원의 대화 상세 내용 보기 Escape 팀원의 현재 작업 중단 Ctrl+T 작업 목록 보기 전환 Shift+Tab 위임 모드 전환 (리더는 코딩 없이 조율만 수행) 작업 할당 메커니즘 Agent Teams의 작업 시스템은 3가지 상태와 의존 관계를 지원합니다.\n작업 상태: pending(대기 중) → in_progress(진행 중) → completed(완료)\n의존성 메커니즘: 작업에 blockedBy 의존성을 설정할 수 있습니다. 의존하는 작업이 완료되면 하위 작업이 자동으로 잠금 해제되어 수동 개입 없이 진행됩니다.\n수락 방식:\n리더(Lead) 지정 할당: 리더에게 특정 작업을 특정 팀원에게 맡기라고 명확하게 지시합니다. 팀원 자율 수락: 현재 작업을 마친 팀원이 할당되지 않은 다음 가용 작업을 자동으로 가져옵니다. 파일 잠금(File Lock)을 통한 충돌 방지: 여러 팀원이 동시에 같은 작업을 가져가려 할 때, 시스템은 파일 잠금을 사용하여 충돌을 방지합니다. 작업 크기 권장 사항: 팀원당 5~6개의 작업을 할당하는 것입니다. 작업이 너무 작으면 조율 비용이 이득보다 커지고, 너무 크면 팀원이 오랫동안 진행 상황을 보고하지 않게 됩니다.\n작업 상태 다이어그램 stateDiagram-v2\r[*] --\u003e pending: 작업 생성\rpending --\u003e in_progress: 팀원이 작업 선택\rin_progress --\u003e completed: 작업 완료\rin_progress --\u003e pending: 작업 실패/재시도\rpending --\u003e blocked: 의존성 있는 작업 대기\rblocked --\u003e pending: 의존 작업 완료\rcompleted --\u003e [*]: 아카이브\rnote right of pending\r모든 작업은 기본적으로\rpending 상태로 시작됩니다.\rend note\rnote right of blocked\rblockedBy가 설정된 작업은\r의존하는 작업이 완료될 때까지\r잠금 상태로 유지됩니다.\rend note팀원 간 통신 방식 통신 유형 설명 사용 시나리오 write (개별 메시지) 특정 팀원에게 메시지 전송 구체적인 문제 조율 broadcast (브로드캐스트) 모든 팀원에게 메시지 전송 중요 공지 (주의해서 사용, 팀 규모에 따라 비용 증가) 통신은 P2P(점대점) 방식이며, 리더를 거칠 필요가 없습니다. 어떤 팀원이든 다른 팀원에게 직접 메시지를 보낼 수 있어요.\n팀원 간 통신 시퀀스 다이어그램 sequenceDiagram\rparticipant L as Lead Agent(팀 리더)\rparticipant M1 as Teammate 1(팀원1)\rparticipant M2 as Teammate 2(팀원2)\rparticipant M3 as Teammate 3(팀원3)\rparticipant MB as Mailbox(메시지 시스템)\rL-\u003e\u003eM1: 작업 할당 (Task 1)\rL-\u003e\u003eM2: 작업 할당 (Task 2)\rL-\u003e\u003eM3: 작업 할당 (Task 3)\rM1-\u003e\u003eMB: 개별 메시지 (write)M2에게 질문\rMB-\u003e\u003eM2: 메시지 전달\rM2-\u003e\u003eMB: 응답\rMB-\u003e\u003eM1: 응답 전달\rNote over M1,M3: 작업 진행 중...\rM1-\u003e\u003eM1: Task 1 완료\rM1-\u003e\u003eL: 작업 완료 보고\rM2-\u003e\u003eMB: 브로드캐스트 (broadcast)\"중요 공지: API 변경사항\"\rMB-\u003e\u003eM1: 공지 전달\rMB-\u003e\u003eM3: 공지 전달\rMB-\u003e\u003eL: 공지 전달\rM2-\u003e\u003eM2: Task 2 완료\rM2-\u003e\u003eL: 작업 완료 보고\rM3-\u003e\u003eM3: Task 3 완료\rM3-\u003e\u003eL: 작업 완료 보고\rL-\u003e\u003eL: 모든 작업 종합 및 요약Agent Teams에서 가장 중요한 규칙은 두 명의 팀원이 동일한 파일을 편집하면 내용이 덮어씌워질 수 있다는 점입니다.\n추천하는 파일 분업 전략은 다음과 같아요.\n# 풀스택 기능 개발 예시\r백엔드 팀원 → src/api/ 및 src/migrations/ 담당\r프론트엔드 팀원 → src/components/ 담당\r테스트 팀원 → tests/ 담당 ⚠️ 중요: Agent Teams의 팀원들은 동일한 작업 디렉토리를 공유하며, 자동으로 git worktree를 사용하지 않습니다. 각 팀원이 서로 다른 파일 집합을 담당하도록 하는 것이 충돌을 피하는 핵심입니다.\n5대 실전 시나리오 시나리오 1: 다각도 코드 리뷰 이 PR을 리뷰할 에이전트 팀을 생성해줘:\r- 보안 리뷰어: 인젝션, XSS, 권한 등 보안 문제 점검\r- 성능 리뷰어: N+1 쿼리, 메모리 누수, 캐싱 전략 분석\r- 테스트 리뷰어: 테스트 커버리지 및 경계 사례 검증\r각자 리뷰를 마친 후 발견 사항을 보고하게 해줘. Agent Teams에 적합한 이유: 세 가지 리뷰 관점이 완전히 독립적이므로 파일 충돌이 발생하지 않으며 병렬로 실행할 수 있습니다.\n시나리오 2: 신기능 모듈 병렬 개발 사용자 알림 시스템을 구축할 팀을 생성해줘:\r- 팀원 1: 백엔드 API 구축 (src/api/notifications/)\r- 팀원 2: 프론트엔드 컴포넌트 구축 (src/components/notifications/)\r- 팀원 3: 통합 테스트 작성 (tests/notifications/) 적합한 이유: 각 팀원이 서로 다른 디렉토리를 담당하여 자연스럽게 격리되며, 작업 완료 후 합치기만 하면 됩니다.\n시나리오 3: 가설 검증 디버깅 간헐적으로 발생하는 버그가 있어. 서로 다른 가설로 디버깅할 팀을 만들어줘:\r- 팀원 A: 레이스 컨디션(Race Condition) 여부 조사\r- 팀원 B: 메모리 누수 여부 조사\r- 팀원 C: 서드파티 API 타임아웃 여부 조사\r각자 독립적으로 가설을 검증하고 보고해줘. 적합한 이유: 대항적 디버깅 방식으로, 여러 단서를 동시에 추적하여 누가 먼저 근본 원인을 찾는지 경쟁할 수 있습니다.\n시나리오 4: 계층 간 수정 조율 프론트엔드, 백엔드, 데이터베이스를 모두 가로지르는 수정이 필요할 때, Agent Teams를 통해 각 계층의 전문가가 역할을 분담하고 메시지 시스템을 통해 인터페이스 정의를 조율할 수 있습니다.\n시나리오 5: 탐색적 연구 코드 내 TODO 주석을 추적하는 CLI 도구를 설계하고 있어.\r다양한 관점에서 탐색할 팀을 만들어줘:\r- 한 명은 사용자 경험(UX) 설계 담당\r- 한 명은 기술 아키텍처 담당\r- 한 명은 \u0026#39;비판자(Devil\u0026#39;s Advocate)\u0026#39; 역할 수행 적합한 이유: 다각도의 관점이 충돌하면서 서로의 가설과 결론에 도전하고 보완할 수 있습니다.\nSubagent와 비교: 선택 가이드표 판단 기준 Subagent 선택 Agent Teams 선택 팀원 간 소통이 필요한가요? ❌ 아니요 ✅ 네 작업을 병렬로 처리할 수 있나요? 부분적으로 가능 ✅ 고도의 병렬 처리 가능 여러 파일을 동시에 편집하나요? ✅ 동일 파일 작업 시 안전 ⚠️ 충돌 방지를 위한 역할 분담 필요 작업의 복잡도는 어떤가요? 단일 목표에 집중 다각도, 다중 모듈 토큰 예산은? 💰 더 절약됨 💸 약 3~7배 소모 토론이나 피드백이 필요한가요? ❌ 아니요 ✅ 네 비용 참고: 3인 구성의 Agent Teams 팀을 30분 동안 실행할 경우, 토큰 소모량은 단일 세션의 약 3~4배 정도입니다. Plan 모드에서는 약 7배까지 늘어날 수 있습니다.\n고급 팁 팁 1: 하이브리드 모델로 비용 절감하기 리드(Lead)는 Opus를 사용하고, 팀원 4명은 Sonnet을 사용하는 팀을 구성해 줘. 리더는 전략적인 의사결정을 위해 Opus 4.6을 사용하여 품질을 보장하고, 팀원들은 구체적인 실행 작업을 위해 Sonnet을 사용하여 비용을 효율적으로 관리하는 방식이에요.\n팁 2: Plan 승인 워크플로우 활용하기 인증 모듈을 리팩토링할 아키텍트 팀원을 생성해 줘.\r수정 작업을 시작하기 전에 먼저 방안을 제출하고 승인을 기다리도록 해줘. 이렇게 하면 팀원이 먼저 읽기 전용인 \u0026lsquo;Plan 모드\u0026rsquo;로 진입하여 방안을 완성한 뒤, 리더에게 승인 요청을 보냅니다. 리더가 승인한 후에야 팀원이 실제 구현 단계에 들어갑니다.\n팁 3: 리더의 직접 개입을 방지하는 위임 모드 Shift+Tab을 눌러 위임 모드를 켜보세요. 이 모드에서는 리더가 작업 조율과 할당만 담당하고, 직접 코드를 작성하지 않게 됩니다. 리더가 팀원의 \u0026lsquo;일을 가로채는\u0026rsquo; 상황을 방지할 수 있죠.\n팁 4: 품질 게이트 훅(Quality Gate Hooks) 훅(Hook) 메커니즘을 통해 작업 품질을 자동으로 관리할 수 있습니다.\nTeammateIdle: 팀원이 유휴 상태가 되기 직전에 트리거됩니다. 종료 코드 2를 반환하면 팀원에게 피드백을 보내 작업을 계속하게 할 수 있습니다. TaskCompleted: 작업이 완료로 표시될 때 트리거됩니다. 종료 코드 2를 반환하면 완료 처리를 중단하고 수정을 요구할 수 있습니다. 주의사항 및 베스트 프랙티스 알려진 제한 사항 대화 복구 미지원: /resume 및 /rewind 명령어를 사용해도 종료된 팀원을 복구할 수 없습니다. 세션당 하나의 팀: 리더(Lead)는 한 번에 하나의 팀만 관리할 수 있습니다. 중첩 팀 미지원: 팀원이 다시 자신의 팀을 생성할 수는 없습니다. 권한 상속: 팀원은 리더의 권한 모드를 상속받으며, 생성된 후에는 개별적으로 조정할 수 있습니다. 분할 화면 모드 제한: tmux 분할 화면은 VS Code 내장 터미널, Windows Terminal, Ghostty를 지원하지 않습니다. 팀원 충돌(Crash): 팀원이 충돌하면 5분의 하트비트(Heartbeat) 타임아웃이 발생하며, 해당 작업은 다른 팀원이 이어받을 수 있습니다. 베스트 프랙티스 팀 규모: 2~5명의 팀원을 권장하며, 보통 6명보다 3명이 더 효과적인 경우가 많습니다. 인원수보다 중요한 작업 분할: 작업 분할이 제대로 되지 않은 6인 팀보다 잘 분할된 3인 팀이 더 낫습니다. 읽기 집약적 작업(코드 리뷰, 리서치 등)이 에이전트 팀의 강점(Sweet spot)입니다. 쓰기 집약적 동시 편집은 여전히 어려운 과제이며, 엄격한 파일 분업이 필요합니다. FAQ Q1: 에이전트 팀을 사용하려면 어떤 구독이 필요한가요? 에이전트 팀은 Claude Code의 실험적 기능으로, 충분한 Opus 4.6 사용량을 확보하려면 Claude Max 구독(월 $100-200)이 필요합니다. API 사용자는 표준 Opus 4.6 요율(백만 토큰당 $5/$25)에 따라 과금됩니다.\nQ2: 에이전트 팀은 Opus 4.6만 사용할 수 있나요? 아니요, 그렇지 않습니다. 에이전트 팀은 Opus 4.6과 함께 출시되었지만, 여러 모델을 혼합해서 사용할 수 있습니다. 리더는 전략적 의사결정을 위해 Opus 4.6을 사용하고, 팀원은 구체적인 작업을 수행하기 위해 Sonnet을 사용하는 방식을 추천합니다. 이렇게 하면 협업의 품질을 유지하면서 비용을 효율적으로 관리할 수 있습니다.\nQ3: 에이전트 팀을 VS Code에서 사용할 수 있나요? 네, 가능하지만 몇 가지 제한이 있습니다. VS Code 내장 터미널은 인프로세스(In-process) 모드(모든 팀원이 동일한 터미널에서 실행됨)를 지원합니다. 하지만 tmux 분할 화면 모드는 VS Code에서 사용할 수 없으므로, 이 기능을 쓰려면 외부 터미널을 사용해야 합니다.\n결론 및 요약 Agent Teams 전체 프로세스 플로우차트 flowchart TB\rsubgraph Setup[\"🔧 1. 환경 설정\"]\rS1[\"CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1\"]\rS2[\"표시 모드 선택(in-process/tmux/auto)\"]\rend\rsubgraph Create[\"👥 2. 팀 생성\"]\rC1[\"자연어 팀 구성 설명\"]\rC2[\"Claude 자동 팀 생성\"]\rC3[\"팀원 배정 및 역할 분담\"]\rend\rsubgraph Work[\"⚙️ 3. 작업 실행\"]\rW1[\"작업 목록 생성\"]\rW2[\"의존성 설정\"]\rW3[\"팀원별 작업 할당\"]\rW4[\"병렬 작업 진행\"]\rend\rsubgraph Comm[\"💬 4. 팀 협업\"]\rCM1[\"개별 메시지 (write)\"]\rCM2[\"브로드캐스트 (broadcast)\"]\rCM3[\"P2P 직접 통신\"]\rend\rsubgraph Complete[\"✅ 5. 완료 및 종합\"]\rF1[\"개별 작업 완료 보고\"]\rF2[\"리더 결과 종합\"]\rF3[\"팀 종료 및 정리\"]\rend\rSetup --\u003e Create\rCreate --\u003e Work\rWork --\u003e Comm\rComm --\u003e Work\rWork --\u003e Complete\rstyle Setup fill:#e3f2fd,stroke:#036\rstyle Create fill:#fff3e0,stroke:#036\rstyle Work fill:#e8f5e9,stroke:#036\rstyle Comm fill:#fce4ec,stroke:#036\rstyle Complete fill:#c8e6c9,stroke:#036,stroke-width:2px핵심 요약 Claude 4.6 Agent Teams의 핵심 요약:\n활성화 방법: 환경 변수 CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1을 설정한 후, 자연어로 팀 구성을 설명하세요. 아키텍처 모델: 리더 에이전트(Lead Agent)가 전체를 조율하고 팀원 에이전트(Teammate Agent)가 병렬로 작업하며, 공유 작업 목록과 메시징 시스템을 통해 협업합니다. 최적의 활용 시나리오: 코드 리뷰, 새로운 모듈의 병렬 개발, 경쟁 가설 디버깅, 계층 간 조율, 탐색적 연구 등. 핵심 원칙: 인원수보다 작업을 어떻게 나누느냐가 더 중요합니다. 보통 6명보다는 3명의 팀원이 더 효과적이에요. 비용 관리: 하이브리드 모델(리더는 Opus + 팀원은 Sonnet) 구성이 가성비 면에서 가장 좋은 선택입니다. Agent Teams는 AI 프로그래밍을 \u0026lsquo;솔로 플레이\u0026rsquo;에서 \u0026lsquo;팀 협업\u0026rsquo; 시대로 진화시켰습니다. 아직 연구 프리뷰 단계이지만, 이미 강력한 병렬 개발 능력을 보여주고 있죠.\n","date":"2026-02-12","permalink":"/post/2026/2026-02-12-claude-4-6-agent-teams-guide/","section":"post","summary":"Claude Opus 4.6 출시와 함께 Agent Teams(다중 에이전트 팀) 기능이 공개되었습니다. 이 기능을 통해 여러 개의 Claude 인스턴스가 실제 개발 팀처럼 병렬로 협업할 수 있게 되었죠. 많은 개발자분이 Agent Teams를 어떻게 활성화하는지, 어떻게 실행하는지, 그리고 기존 Subagent와는 무엇이 다른지 궁금해하고 계십니다.\n","title":"Claude 4.6 Agent Teams 완전 가이드: 활성화 방법, 트리거 기법 및 5대 실전 시나리오"},{"content":"Claude Code의 플러그인 시스템을 사용하면 프로젝트와 팀 전체에서 공유할 수 있는 사용자 정의 기능으로 Claude Code를 확장할 수 있습니다.\n마켓플레이스에서 미리 빌드된 플러그인을 설치하거나, 워크플로우 자동화를 위해 자신만의 플러그인을 만들 수 있습니다.\n플러그인이란? 플러그인은 다음 구성 요소를 포함할 수 있는 확장 가능한 단위입니다:\n명령(Commands): 슬래시 명령어로 실행되는 사용자 정의 기능 에이전트(Agents): 특정 작업에 특화된 전문화된 AI 어시스턴트 스킬(Skills): 모델의 기능을 확장하는 재사용 가능한 지식 베이스 훅(Hooks): 이벤트 핸들러를 통한 워크플로우 자동화 MCP 서버: 외부 도구와 서비스에 연결 플러그인 구조 기본 플러그인 구조는 다음과 같습니다:\nmy-plugin/\r├── .claude-plugin/ # 필수: 플러그인 메타데이터\r│ └── plugin.json # 플러그인 매니페스트\r├── commands/ # 선택: 슬래시 명령어\r│ └── my-command.md\r├── agents/ # 선택: 사용자 정의 에이전트\r│ └── specialist.md\r├── skills/ # 선택: 에이전트 스킬\r│ └── my-skill/\r│ └── SKILL.md\r│ ├── README.md # 추가 문서 (선택)\r│ └── examples/ # 예제 파일 (선택)\r├── hooks/ # 선택: 이벤트 핸들러\r│ └── hooks.json\r│ └── pre-commit.py # 핸 스크립트\r├── .mcp.json # 선택: MCP 서버 설정\r└── README.md # 플러그인 문서 plugin.json 구조 플러그인 매니페스트 파일은 플러그인의 메타데이터를 정의합니다:\n{ \u0026#34;name\u0026#34;: \u0026#34;my-plugin\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;플러그인에 대한 간단한 설명\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;작성자 이름\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;email@example.com\u0026#34; }, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;claude\u0026#34;: { \u0026#34;minVersion\u0026#34;: \u0026#34;1.0.0\u0026#34; } } Commands (명령어) 사용자가 슬래시(/)로 실행하는 기능입니다.\nFrontmatter 옵션:\n--- description: \u0026#34;명령어에 대한 간단한 설명\u0026#34; argument-hint: \u0026#34;\u0026lt;required-arg\u0026gt; [optional-arg]\u0026#34; allowed-tools: [Read, Glob, Grep, Bash] model: \u0026#34;opus\u0026#34; --- # 명령어 제목 명령어가 실행될 때 수행할 작업을 설명합니다... ## Arguments 사용자가 제공한 인수: $ARGUMENTS 주요 Frontmatter 필드:\ndescription: /help에 표시될 설명 argument-hint: 인수 힌트 표시 allowed-tools: 미리 승인된 도구 목록 model: 사용할 모델 (haiku, sonnet, opus) Agents (에이전트) 특정 작업에 특화된 전문 AI 어시스턴트입니다.\n에이전트 구조:\n--- name: specialist description: \u0026#34;에이전트를 사용할 시기 설명\u0026#34; model: inherit color: yellow tools: [\u0026#34;Read\u0026#34;, \u0026#34;Grep\u0026#34;, \u0026#34;Bash\u0026#34;] --- 당신은 전문 분야 전문가입니다... **작업:** 1. 첫 번째 단계 2. 두 번째 단계 ... 주요 Frontmatter 필드:\nname: 에이전트 식별자 description: 에이전트를 언제 사용할지 설명 (매우 중요!) model: 사용할 모델 (inherit, haiku, sonnet, opus) color: UI 표시 색상 tools: 에이전트가 사용할 수 있는 도구 Skills (스킬) Claude가 자동으로 사용하는 재사용 가능한 지식 베이스입니다.\n스킬 구조:\nskills/\r└── my-skill/\r└── SKILL.md # 필수\r├── README.md # 선택\r├── references/ # 참고 자료\r└── examples/ # 예제 파일 Hooks (훅) 특정 이벤트 발생 시 자동으로 실행되는 핸들러입니다.\nhooks.json 구조:\n{ \u0026#34;description\u0026#34;: \u0026#34;훅 플러그인 설명\u0026#34;, \u0026#34;hooks\u0026#34;: { \u0026#34;PreToolUse\u0026#34;: [ { \u0026#34;hooks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;command\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py\u0026#34;, \u0026#34;timeout\u0026#34;: 10 } ] } ], \u0026#34;PostToolUse\u0026#34;: [...], \u0026#34;UserPromptSubmit\u0026#34;: [...], \u0026#34;Stop\u0026#34;: [...] } } 지원되는 훅 이벤트:\nPreToolUse: 도구 사용 전 PostToolUse: 도구 사용 후 UserPromptSubmit: 사용자 프롬프트 제출 시 Stop: 세션 중지 시 환경 변수:\n${CLAUDE_PLUGIN_ROOT}: 플러그인 루트 경로 MCP 서버 외부 도구와 서비스에 연결합니다.\n.mcp.json 구조:\n{ \u0026#34;my-server\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://api.example.com/mcp\u0026#34; }, \u0026#34;local-server\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;command\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;server.js\u0026#34;] } } 플러그인 설치 및 관리 마켓플레이스 추가 플러그인을 발견하고 설치하기 위해 마켓플레이스를 추가합니다:\n/plugin marketplace add your-org/claude-plugins 플러그인 설치 # 특정 플러그인 설치 /plugin install formatter@your-org # 플러그인 활성화 /plugin enable plugin-name@marketplace-name # 플러그인 비활성화 (제거하지 않음) /plugin disable plugin-name@marketplace-name # 플러그인 완전 제거 /plugin uninstall plugin-name@marketplace-name 첫 번째 플러그인 만들기 간단한 인사말 명령을 추가하는 플러그인을 만들어 봅시다.\n1. 플러그인 폴더 생성 mkdir -p hello-plugin/.claude-plugin cd hello-plugin 2. plugin.json 작성 { \u0026#34;name\u0026#34;: \u0026#34;hello-plugin\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;간단한 인사말 명령을 제공합니다\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;your-name\u0026#34; } 3. 명령 추가 commands/hello.md 파일을 생성합니다:\n--- description: \u0026#34;친결한 인사말을 출력합니다\u0026#34; --- 안녕하세요! Claude Code 플러그인 개발에 온 것을 환영합니다! 4. 로컬에서 테스트 /plugin marketplace add ./ /plugin install hello-plugin /hello 스킬 추가하기 플러그인에 에이전트 스킬을 추가하여 Claude의 기능을 확장할 수 있습니다.\n스킬 구조 skills/\r└── code-review/\r└── SKILL.md SKILL.md 예제 --- description: \u0026#34;코드를 리뷰하고 개선 사항을 제안합니다\u0026#34; parameters: - name: code description: \u0026#34;리뷰할 코드\u0026#34; required: true --- # 코드 리뷰 제공된 코드를 분석하고 다음 측면에서 리뷰합니다: 1. **버그 및 잠니ial 오류** 2. **성능 최적화 기회** 3. **코드 스타일 일치성** 4. **보안 문제** ... 팀 플러그인 설정 저장소 수준에서 플러그인을 구성하면 팀 전체에서 일관된 도구를 사용할 수 있습니다.\n.claude/settings.json 구성 { \u0026#34;marketplaces\u0026#34;: [ \u0026#34;your-org/shared-plugins\u0026#34; ], \u0026#34;plugins\u0026#34;: { \u0026#34;shared-formatter\u0026#34;: { \u0026#34;source\u0026#34;: \u0026#34;marketplace\u0026#34;, \u0026#34;marketplace\u0026#34;: \u0026#34;your-org/shared-plugins\u0026#34;, \u0026#34;enabled\u0026#34;: true } } } 활용 예제 예제 1: 코드 포멧팅 플러그인 프로젝트의 코딩 스타일을 자동으로 적용하는 플러그인:\n{ \u0026#34;name\u0026#34;: \u0026#34;project-formatter\u0026#34;, \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;format-code\u0026#34; } } 예제 2: API 문서 생성 스킬 API 엔드포인트에서 자동으로 문서를 생성하는 스킬:\n--- description: \u0026#34;API 엔드포인트에서 문서를 생성합니다\u0026#34; --- 엔드포인트를 분석하고 OpenAPI 스펵명을 생성합니다... 예제 3: 배포 자동화 CI/CD 파이프라인과 연동하여 자동으로 배포하는 훅:\n{ \u0026#34;hooks\u0026#34;: { \u0026#34;after-success\u0026#34;: \u0026#34;deploy-to-production\u0026#34; } } MCP 개발 베스트 프랙티스 MCP 도구 개발 시 다음 원칙을 따르면 더 효과적인 플러그인을 만들 수 있습니다:\n1. 더 적은, 더 초점화된 도구 하나의 API 엔드포인트마다 별도의 도구를 만들지 마세요. 대신 다단계 오퍼레이션을 하나의 도구로 통합하세요.\n나쁜 예제:\n// 나쁜: 엔드포인트마다 분리된 도구 { \u0026#34;name\u0026#34;: \u0026#34;list_users\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;사용자 목록을 가져옵니다\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;create_event\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;이벤트를 생성합니다\u0026#34; } 좋은 예제:\n// 좋은: 하나의 도구로 다단계 오퍼레이션 처리 { \u0026#34;name\u0026#34;: \u0026#34;schedule_event\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;사용자를 탐색하고 이벤트를 예약합니다\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;user_query\u0026#34;: \u0026#34;사용자 탐색 쿼리\u0026#34;, \u0026#34;event_details\u0026#34;: \u0026#34;이벤트 세부 정보\u0026#34; } } 2. 서비스/리소스별 네임스페이스 도구 이름을 서비스나 리소스별로 네임스페이스하세요:\n{ \u0026#34;asana_search\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Asana에서 탐색\u0026#34; }, \u0026#34;asana_create\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Asana에 생성\u0026#34; }, \u0026#34;jira_search\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Jira에서 탐색\u0026#34; }, \u0026#34;jira_create\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Jira에 생성\u0026#34; } } 3. 의미 있는 컨텍스트 반환 기술적 세부사항보다 시그널을 우선시하세요. uuid 대신 name을 사용하세요:\n// 나쁜 { \u0026#34;result\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;a1b2c3d4-e5f6-7890-abcd-ef1234567890\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;active\u0026#34; } } // 좋은 { \u0026#34;result\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;프로젝트 알파\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;진행 중\u0026#34;, \u0026#34;assignee\u0026#34;: \u0026#34;김개발\u0026#34; } } 4. 응답 포멷 지원 에이전트가 \u0026ldquo;간결한\u0026rdquo; 또는 \u0026ldquo;상세한\u0026rdquo; 응답을 선택할 수 있도록 하세요:\n{ \u0026#34;name\u0026#34;: \u0026#34;get_repository_info\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;format\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;concise\u0026#34;, \u0026#34;detailed\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;응답 형식\u0026#34; } } } 5. 토큰 효율 최적화 Claude Code는 최대 25,000 토큰 제한이 있습니다:\n페이지네이션 구현 필터링 옵션 제공 결과 길이 자르기 관련 정보만 반환 시큐리티 베스트 프랙티스 플러그인 개발 시 다음 시큐리티 원칙을 따르세요:\n1. 훅 기본 비활성화 모든 훅을 기본적으로 비활성화 상태로 시작하세요:\n{ \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: { \u0026#34;enabled\u0026#34;: false, \u0026#34;command\u0026#34;: \u0026#34;security-scan\u0026#34; } } } 2. MCP 서버 명시적 승인 알 수 없는 MCP 서버를 자동으로 연결하지 마세요:\n{ \u0026#34;mcpServers\u0026#34;: { \u0026#34;database\u0026#34;: { \u0026#34;enabled\u0026#34;: false, \u0026#34;requireApproval\u0026#34;: true, \u0026#34;description\u0026#34;: \u0026#34;프로덕션 데이터베이스 접속\u0026#34; } } } 3. 에러 메시지 검토 에러 메시지에 민간한 정보를 포함하지 않도록 주의하세요. 에러 로그를 검토하여 시큐리티 문제를 확인하세요.\n일반적인 실수 피하기 다음과 같은 실수를 피하세요:\n❌ 하나의 API 엔드포인트마다 도구 생성 ❌ 너무 많은 저수준 기술적 세부사항 반환 ❌ 모호하거나 불확실한 도구 이름 사용 ❌ 도구 설명 품질 간과 ❌ 실제 에이전트 워크플로우 테스트 없음 베스트 프랙티스 버전 관리: plugin.json에서 의미 있는 버전 관리를 사용하세요 문서화: README.md에 설치 및 사용 지침을 포함하세요 테스트: 로컬 마켓플레이스에서 변경 사항을 반복적으로 테스트하세요 커뮤니티 기여: 플러그인 컬렉션에 기여하는 것을 고려하세요 참고자료 Claude Code 플러그인 공식 문서 Claude Code 플러그인 구조 완전 정복 - Vitalholic roboco-io/plugins: Claude Code 플러그인 모음 - GitHub Claude Code Survival Guide 2026 - LinkedIn ","date":"2026-02-12","permalink":"/post/2026/2026-02-12-claude-code-plugin-guide/","section":"post","summary":"Claude Code의 플러그인 시스템을 사용하면 프로젝트와 팀 전체에서 공유할 수 있는 사용자 정의 기능으로 Claude Code를 확장할 수 있습니다.\n마켓플레이스에서 미리 빌드된 플러그인을 설치하거나, 워크플로우 자동화를 위해 자신만의 플러그인을 만들 수 있습니다.\n","title":"Claude Code 플러그인 완전 가이드: 개발부터 활용까지"},{"content":"Windows Terminal(wt) 내 Git Bash에서 한글이 깨지는 문제는 주로 Git 설정의 유니코드(UTF-8) 처리 미흡 때문입니다. git status, git log 명령어에서 한글 파일명이나 커밋 메시지가 깨져서 표시되는 경험이 있으실 겁니다.\n이 문제는 Git 설정, .bashrc, .inputrc 파일 수정을 통해 해결할 수 있습니다. 가장 효과적인 방법은 git config 명령어를 사용하여 core.quotepath를 false로 설정하고, 쉘 환경에서 LANG 환경 변수를 UTF-8로 설정하는 것입니다.\n문제 현상 Windows Terminal의 Git Bash에서 다음과 같은 한글 깨짐 현상이 발생합니다:\ngit status 명령어에서 한글 파일명이 이스케이프 문자로 표시됨 git log 명령어에서 한글 커밋 메시지가 깨져서 보임 ls 명령어로 한글 파일명 확인 시 깨짐 터미널 입력 시 한글이 정상적으로 표시되지 않음 해결 방법 1. Git 파일명/메시지 한글 깨짐 해결 git status, git log에서 한글이 정상적으로 표시되도록 Git의 core.quotepath 설정을 변경합니다. 이 설정은 0x80 이상의 문자(한글 등)를 이스케이프할지 여부를 결정합니다.\ngit config --global core.quotepath false 2. ls 명령어 한글 파일명 깨짐 해결 ~/.bashrc 파일에 환경 변수 설정을 추가하여 로케일을 UTF-8로 설정합니다. Git Bash에서 다음 명령어를 실행하세요:\necho \u0026#39;export LANG=\u0026#34;ko_KR.UTF-8\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export LC_ALL=\u0026#34;ko_KR.UTF-8\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 3. 입력 시 한글 깨짐 해결 (Inputrc 설정) ~/.inputrc 파일을 생성하거나 수정하여 8비트 문자 입력을 허용하도록 설정합니다:\necho \u0026#34;set output-meta on\u0026#34; \u0026gt;\u0026gt; ~/.inputrc echo \u0026#34;set convert-meta off\u0026#34; \u0026gt;\u0026gt; ~/.inputrc set output-meta on: 8비트 문자(Meta 키 + 문자 조합 등)를 직접 출력 set convert-meta off: 8비트 문자를 이스케이프 시퀀스로 변환하지 않음 적용 확인 모든 설정을 완료한 후 Git Bash를 재시작하면 다음과 같이 한글이 정상적으로 표시됩니다:\n$ git status 현재 브랜치 main 브랜치가 \u0026#39;origin/main\u0026#39;과 일치합니다 커밋하도록 정리하지 않은 변경 사항들: (git add/rm을 사용하여 커밋할 것을 표시하십시오) (git restore를 사용하여 작업 디렉토리 변경 사항을 폐기하십시오) 수정됨: 한글파일명.md 함께 보기 Git 공식 문서 - git-config Windows Terminal 공식 문서 ","date":"2026-02-05","permalink":"/post/2026/2026-02-05-windows-terminal-utf-8-hangul/","section":"post","summary":"Windows Terminal(wt) 내 Git Bash에서 한글이 깨지는 문제는 주로 Git 설정의 유니코드(UTF-8) 처리 미흡 때문입니다. git status, git log 명령어에서 한글 파일명이나 커밋 메시지가 깨져서 표시되는 경험이 있으실 겁니다.\n이 문제는 Git 설정, .bashrc, .inputrc 파일 수정을 통해 해결할 수 있습니다. 가장 효과적인 방법은 git config 명령어를 사용하여 core.quotepath를 false로 설정하고, 쉘 환경에서 LANG 환경 변수를 UTF-8로 설정하는 것입니다.\n","title":"Windows Terminal Git Bash 한글 깨짐 해결하기"},{"content":"mpv는 강력한 오픈소스 동영상 플레이어로, 다양한 기능을 플러그인 형태로 확장할 수 있습니다. 이번 글에서는 mpv에서 자막을 실시간으로 번역해주는 Lua 스크립트를 소개합니다. 이 스크립트는 trans 명령줄 도구를 사용하여 자막을 번역하며, Linux 환경에서 mpv와 함께 사용할 수 있습니다.\n설치 방법과 사용법은 다음과 같습니다.\n사전 준비 mpv 설치: Linux 배포판에 따라 패키지 관리자를 사용하여 mpv를 설치합니다. sudo apt install mpv # Ubuntu/Debian sudo dnf install mpv # Fedora trans 도구 설치: trans는 다양한 번역 서비스를 지원하는 명령줄 번역기입니다. 다음 명령어로 설치할 수 있습니다. sudo apt install translate-shell # Ubuntu/Debian 또는 공식 GitHub 저장소에서 최신 버전을 확인할 수 있습니다。 스크립트 설치 및 설정 아래 Lua 스크립트를 ~/.config/mpv/scripts/ 디렉토리에 auto_translate.lua라는 이름으로 저장합니다.\nlocal mp = require \u0026#39;mp\u0026#39; local enabled = false -- OSD 오버레이 생성 local ov = mp.create_osd_overlay(\u0026#34;ass-events\u0026#34;) function translation_callback(success, result, error) if success and result.status == 0 then -- [[ 스타일 설정 ]] -- \\an2 : 하단 중앙 정렬 -- \\fs60 : 글자 크기 -- \\bord2 : 테두리 두께 (검은색) -- \\1c\u0026amp;HFFFFFF\u0026amp; : 글자색 (흰색) local style = \u0026#34;{\\\\an2}{\\\\fs60}{\\\\bord2}\u0026#34; -- 줄바꿈을 공백으로 변경 local clean_text = result.stdout:gsub(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;) ov.data = style .. clean_text ov:update() end end function on_subtitle_change(name, text) if not enabled then return end if not text or text == \u0026#34;\u0026#34; then ov.data = \u0026#34;\u0026#34; ov:update() return end text = text:gsub(\u0026#34;\\n\u0026#34;, \u0026#34; \u0026#34;) local cmd = { name = \u0026#34;subprocess\u0026#34;, args = { \u0026#34;trans\u0026#34;, \u0026#34;-b\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;ko\u0026#34;, text }, capture_stdout = true } mp.command_native_async(cmd, translation_callback) end function toggle_translation() enabled = not enabled if enabled then mp.set_property(\u0026#34;sub-visibility\u0026#34;, \u0026#34;no\u0026#34;) mp.osd_message(\u0026#34;자동 번역 ON (Shift+t로 끄기)\u0026#34;, 2) local current_text = mp.get_property(\u0026#34;sub-text\u0026#34;) if current_text then on_subtitle_change(\u0026#34;sub-text\u0026#34;, current_text) end else mp.set_property(\u0026#34;sub-visibility\u0026#34;, \u0026#34;yes\u0026#34;) ov.data = \u0026#34;\u0026#34; ov:update() mp.osd_message(\u0026#34;자동 번역 OFF\u0026#34;, 2) end end mp.observe_property(\u0026#34;sub-text\u0026#34;, \u0026#34;string\u0026#34;, on_subtitle_change) -- [[ 단축키 변경됨: Shift + t (대문자 T) ]] mp.add_key_binding(\u0026#34;T\u0026#34;, \u0026#34;toggle_auto_translation\u0026#34;, toggle_translation) 사용법 mpv로 동영상을 재생합니다. 자막이 표시되는 동안 Shift + t 키를 눌러 자동 번역 기능을 켜거나 끕니다. 자막이 번역되어 화면 하단에 표시됩니다. 함께 보기 mpv 공식 문서 translate-shell GitHub ","date":"2026-01-16","permalink":"/post/2026/2026-01-16-mpv-translate/","section":"post","summary":"mpv는 강력한 오픈소스 동영상 플레이어로, 다양한 기능을 플러그인 형태로 확장할 수 있습니다. 이번 글에서는 mpv에서 자막을 실시간으로 번역해주는 Lua 스크립트를 소개합니다. 이 스크립트는 trans 명령줄 도구를 사용하여 자막을 번역하며, Linux 환경에서 mpv와 함께 사용할 수 있습니다.\n","title":"linux mpv 자막 번역기"},{"content":"Python 생태계는 매년 새로운 도구와 라이브러리로 진화하고 있습니다. Tryolabs에서 발표한 2025년 주요 Python 라이브러리들을 살펴보면, 개발자 경험 개선과 성능 최적화에 초점이 맞춰져 있음을 알 수 있습니다. 이번 글에서는 일반 개발에 유용한 Top 10 라이브러리를 소개합니다.\n1. ty - Rust 기반의 초고속 타입 체커 GitHub Stars: 16,000+ | GitHub | 공식 사이트\n모던 Python 개발에서 타입 시스템은 필수입니다. 하지만 기존 타입 체커들은 느린 속도가 문제였죠.\nty의 특징:\nRuff와 uv의 개발사인 Astral에서 만들었습니다 Rust로 구축되어 기존 도구보다 훨씬 빠릅니다 개발 환경을 자동 감지하고 광범위한 설정 없이도 전체 프로젝트 분석이 가능합니다 Salsa를 사용한 함수 단위 증분 분석으로 IDE의 반응성을 극대화합니다 현재 미리보기 단계이지만, Python의 타입 체킹 미래를 주도할 도구입니다.\n2. complexipy - 인지 복잡도 측정 도구 GitHub Stars: 508 | GitHub\n\u0026ldquo;복잡도가 높으면 코드도 복잡하다\u0026quot;는 생각은 사실이 아닙니다. complexipy는 SonarSource의 인지 복잡도(Cognitive Complexity) 개념을 기반으로 합니다.\n주요 기능:\n수학적으로는 단순하지만 읽기 어려운 코드를 식별합니다 Rust 구현으로 대규모 코드베이스도 빠르게 분석합니다 GitHub Actions, VS Code 확장, TOML 설정 파일을 지원합니다 명령줄 및 Python API를 모두 제공합니다 complexipy path/to/code.py --max-complexity-allowed 10 코드 유지보수성 표준을 강제하고 싶은 팀에 최적입니다.\n3. Kreuzberg - 50개 이상 파일 포맷 지원 데이터 추출 GitHub Stars: 3,200+ | GitHub | 공식 사이트\nPDF, Office 문서, 이미지, HTML, XML 등 다양한 형식의 파일에서 데이터를 추출해야 한다면 Kreuzberg가 답입니다.\n특징:\n50개 이상의 파일 포맷을 지원합니다 Rust 기반 프레임워크로 Python, TypeScript, Ruby, Go, Rust 모두에서 사용 가능합니다 라이브러리, CLI 도구, REST API, Docker 이미지 등 다양한 형태로 배포됩니다 Tesseract, EasyOCR, PaddleOCR 등의 OCR 엔진을 지원합니다 지능형 테이블 탐지 및 메모리 효율적인 스트리밍 파서를 제공합니다 문서 처리가 필요한 프로젝트라면 필수 도구입니다.\n4. throttled-py - 고성능 속도 제한 라이브러리 GitHub Stars: 551 | GitHub | PyPI\nAPI 서버를 운영한다면 속도 제한(Rate Limiting)은 필수입니다. throttled-py는 5가지 알고리즘을 지원하는 고성능 솔루션입니다.\n지원 알고리즘:\nFixed Window (최소 오버헤드) Sliding Window Token Bucket Leaky Bucket Generic Cell Rate Algorithm (GCRA) 장점:\n기본 딕셔너리 작업보다 2.5~4.5배 빠릅니다 Redis 백업으로 분산 시스템을 지원합니다 데코레이터, 컨텍스트 관리자 등 다양한 사용법을 제공합니다 스레드 안전성이 내장되어 있습니다 프로덕션 애플리케이션에 꼭 필요한 도구입니다.\n5. httptap - HTTP 요청 성능 분석 도구 GitHub Stars: 439 | GitHub | PyPI\nAPI 통합 시 성능 문제 디버깅은 얼마나 어렵습니까? httptap이 해결해줍니다.\n주요 기능:\nHTTP 요청을 단계별로 분석합니다 (DNS, TCP, TLS, 서버 처리 등) 폭포수 형태의 타임라인으로 시각화합니다 JSON 출력으로 프로그래밍 분석이 가능합니다 httptap https://api.example.com/data httptap --json https://api.example.com/data \u0026gt; metrics.json curl과 호환되는 플래그를 제공하므로 기존 curl 사용자도 쉽게 적응할 수 있습니다.\n6. fastapi-guard - FastAPI 보안 미들웨어 GitHub Stars: 566 | GitHub | PyPI\nFastAPI는 훌륭하지만, 기본적인 보안 기능은 따로 구현해야 합니다. fastapi-guard가 그 일을 해줍니다.\n보안 기능:\nIP 화이트리스팅/블랙리스팅 속도 제한 사용자 에이전트 필터링 SQL injection, path traversal, XSS 탐지 IP 위치 기반 지오펜싱 OWASP 가이드라인 준수 HTTP 보안 헤더 배포:\n단일 인스턴스는 메모리 기반으로 동작합니다 분산 시스템은 Redis와 통합 가능합니다 아키텍처 변경 없이 기본적인 보안 기능을 추가할 수 있습니다.\n7. modshim - 몽키 패칭 없이 모듈 개선하기 GitHub Stars: 414 | GitHub | PyPI\n제3자 라이브러리의 동작을 수정해야 한다면 보통 포크하거나 몽키 패칭을 사용합니다. modshim은 더 나은 방법을 제시합니다.\n개선 사항:\nPython의 임포트 시스템을 활용합니다 기존 모듈을 수정하지 않고도 개선 기능을 추가합니다 몽키 패칭의 전역 네임스페이스 오염 문제를 해결합니다 멀티스레드 안전성이 내장되어 있습니다 신중하게 사용하면 매우 강력한 도구입니다.\n8. Spec Kit - AI 시대의 명세서 기반 개발 GitHub Stars: 59,000+ | GitHub | 공식 사이트\nAI 코딩 어시스턴트는 막연한 프롬프트를 받으면 불완전한 코드를 생성합니다. Spec Kit은 구조화된 명세서로 이 문제를 해결합니다.\n워크플로우:\n프로젝트 구성 정의 (개발 원칙 코드화) 상세 명세서 작성 (\u0026ldquo;what\u0026quot;과 \u0026ldquo;why\u0026rdquo; 포함) 기술 계획 생성 실행 가능한 작업으로 분해 AI 에이전트가 계획대로 구현 uvx --from git+https://github.com/github/spec-kit.git specify init my-project 특별한 점:\nGitHub Copilot, Claude Code, Gemini CLI 등 모든 AI 어시스턴트와 호환됩니다 동일 명세서로 여러 구현을 생성할 수 있습니다 AI로 개발하는 방식을 재정의하는 도구입니다.\n9. skylos - 데드 코드와 보안 취약점 탐지 GitHub Stars: 252 | GitHub | PyPI\n코드베이스에는 항상 사용되지 않는 코드가 쌓입니다. skylos는 이를 탐지하고 보안 취약점도 찾아줍니다.\n탐지 기능:\n사용되지 않는 함수, 메서드, 클래스, 임포트 SQL injection, command injection 취약점 약한 암호화 해시 사용 AI 생성 코드의 일반적 취약점 패턴 신뢰도 기반 시스템:\n절대적 확실성 대신 신뢰도 점수(0-100)를 제공합니다 Flask 라우트, Django 모델 같은 프레임워크 코드는 낮은 신뢰도를 부여합니다 VS Code 확장과 GitHub Actions 통합으로 편하게 사용할 수 있습니다.\n10. FastOpenAPI - 모든 프레임워크를 위한 OpenAPI 문서화 GitHub Stars: 479 | GitHub | PyPI\nFastAPI의 자동 OpenAPI 스키마 생성은 편리합니다. FastOpenAPI는 이 편의성을 다른 프레임워크로 확장합니다.\n지원 프레임워크:\nAioHTTP, Falcon, Flask, Quart Sanic, Starlette, Tornado, Django 작동 방식:\nFastAPI 같은 데코레이터 문법을 사용합니다 Pydantic 모델로 요청 검증을 자동화합니다 /docs, /redoc에서 인터랙티브 문서를 제공합니다 기존 프레임워크를 재구축하지 않고도 FastAPI 수준의 개발 경험을 얻을 수 있습니다.\n2025년 Python 생태계의 트렌드 이 10개 라이브러리에서 보이는 트렌드들:\n성능 우선: Rust 기반 도구들이 Python 생태계에 급속도로 진입하고 있습니다 개발자 경험: 보일러플레이트 코드를 줄이고 자동화를 높입니다 보안 강화: 보안 기능의 접근성과 사용성이 개선되고 있습니다 코드 품질: 자동화된 코드 분석과 유지보수 도구들이 발전하고 있습니다 AI 시대 대응: 구조화된 명세서와 AI 기반 개발을 지원하는 도구들이 등장하고 있습니다 마치며 이 도구들은 단순한 라이브러리가 아닙니다. 이들은 Python 개발의 생산성을 한 단계 올려주고, 코드 품질을 보장하며, 보안을 강화하는 필수 도구들입니다.\n2025년 Python 프로젝트를 시작한다면, 이 라이브러리들을 살펴보고 팀의 필요에 맞는 것들을 도입해보세요. 분명히 개발 효율성이 향상될 것입니다.\n참고: 이 글은 Tryolabs의 \u0026ldquo;Top Python libraries of 2025\u0026rdquo;를 기반으로 작성되었습니다.\n","date":"2026-01-02","permalink":"/post/2026/2026-01-02-top-python-libraries-2025/","section":"post","summary":"Python 생태계는 매년 새로운 도구와 라이브러리로 진화하고 있습니다. Tryolabs에서 발표한 2025년 주요 Python 라이브러리들을 살펴보면, 개발자 경험 개선과 성능 최적화에 초점이 맞춰져 있음을 알 수 있습니다. 이번 글에서는 일반 개발에 유용한 Top 10 라이브러리를 소개합니다.\n","title":"2025년 주목해야 할 Python 라이브러리 Top 10"},{"content":"Claude code에서 commit 명령을 간단하게 실행하는 방법을 공유합니다.\n아래 내용을 ~/.claude-code/commands/ 디렉터리에 commit.md 파일로 저장하세요.\n--- description: \u0026#34;현재까지의 작업을 논리적 단위별로 나눠서 커밋\u0026#34; --- 현재까지 작업한 내용을 작업 단위별로 나눠서 커밋해주세요. ## 수행 단계 ### 1. **현재 변경사항 확인** - `git status`로 staged/unstaged 변경사항 확인 - `git diff`로 각 파일의 변경 내용 파악 - `git diff --cached`로 스테이징된 변경사항 확인 ### 2. **작업을 논리적 단위로 분류** - 관련된 변경사항끼리 그룹화 - 각 그룹이 하나의 완성된 기능/수정 단위가 되도록 구성 - 예: 기능 추가, 버그 수정, 리팩토링, 문서 수정 등으로 분류 ### 3. **각 단위별로 순차 커밋** - 가장 핵심적인 변경부터 시작 - 각 작업 단위별로: - `git add [관련 파일들]` - 해당 단위의 파일만 추가 - 컨벤션에 맞는 커밋 메시지 작성 - 메시지 형식: `[타입] 제목` - feat: 새로운 기능 - fix: 버그 수정 - docs: 문서 수정 - refactor: 코드 리팩토링 - style: 스타일 변경 (공백, 세미콜론 등) - test: 테스트 추가/수정 - chore: 빌드, 의존성 업데이트 등 ### 4. **커밋 완료 확인** - `git log --oneline -10`으로 커밋 이력 확인 - `git status`로 남은 변경사항 확인 (모두 커밋되어야 함) ## 주의사항 - 각 커밋은 독립적으로 의미가 있어야 함 - 너무 큰 단위도, 너무 작은 단위도 피하기 - 커밋 메시지는 명확하고 간결하게 - 미스테이징된 파일이 없는지 확인하기 - .env, credentials 등 민감한 파일은 커밋하지 않음 이제 Claude Code에서 /commit 명령을 실행하면, 위 가이드에 따라 변경사항을 논리적 단위로 나눠서 커밋할 수 있습니다.\n그리고, 굿이 claude 명령어를 매번 입력하지 않아도 되도록 단축 프롬프트를 설정할 수 있습니다. 예를 들어, 터미널에서 아래와 같이 입력하면 됩니다.\nclaude -p \u0026#34;/commit\u0026#34; 추가로 commit and push 명령도 만들어 두면, 커밋 후 바로 원격 저장소에 푸시하는 작업도 자동화할 수 있습니다.\n--- description: \u0026#34;현재까지의 작업을 논리적 단위별로 나눠서 커밋과 푸시\u0026#34; --- 현재까지 작업한 내용을 작업 단위별로 나눠서 커밋해주세요. ## 수행 단계 ### 1. **현재 변경사항 확인** - `git status`로 staged/unstaged 변경사항 확인 - `git diff`로 각 파일의 변경 내용 파악 - `git diff --cached`로 스테이징된 변경사항 확인 ### 2. **작업을 논리적 단위로 분류** - 관련된 변경사항끼리 그룹화 - 각 그룹이 하나의 완성된 기능/수정 단위가 되도록 구성 - 예: 기능 추가, 버그 수정, 리팩토링, 문서 수정 등으로 분류 ### 3. **각 단위별로 순차 커밋** - 가장 핵심적인 변경부터 시작 - 각 작업 단위별로: - `git add [관련 파일들]` - 해당 단위의 파일만 추가 - 컨벤션에 맞는 커밋 메시지 작성 - 메시지 형식: `[타입] 제목` - feat: 새로운 기능 - fix: 버그 수정 - docs: 문서 수정 - refactor: 코드 리팩토링 - style: 스타일 변경 (공백, 세미콜론 등) - test: 테스트 추가/수정 - chore: 빌드, 의존성 업데이트 등 ### 4. **커밋 완료 확인** - `git log --oneline -10`으로 커밋 이력 확인 - `git status`로 남은 변경사항 확인 (모두 커밋되어야 함) ### 5. **원격 저장소에 푸시** - `git push`로 원격 저장소에 푸시 - 푸시 실패 시 원인 파악 및 해결 (충돌, 권한 등) - 새 브랜치인 경우 `git push -u origin [branch-name]` 사용 ## 주의사항 - 각 커밋은 독립적으로 의미가 있어야 함 - 너무 큰 단위도, 너무 작은 단위도 피하기 - 커밋 메시지는 명확하고 간결하게 - 미스테이징된 파일이 없는지 확인하기 - .env, credentials 등 민감한 파일은 커밋하지 않음 - 푸시 전 원격 브랜치와의 충돌 여부 확인 ","date":"2026-01-01","permalink":"/post/2026/2026-01-01-claude-code-commit/","section":"post","summary":"Claude code에서 commit 명령을 간단하게 실행하는 방법을 공유합니다.\n","title":"효율적인 Git 커밋 전략: 작업을 논리적 단위로 나누기"},{"content":"Anthropic에서 공유한 Claude Code의 생산성 향상 팁을 정리했습니다. Claude Code를 더욱 효율적으로 사용하기 위한 실용적인 가이드입니다.\n1. ! 프리픽스로 터미널 바로 실행 핵심 개념: 명령어 입력 시간과 토큰 소모를 최소화하는 기술 Claude Code에서 명령을 실행할 때 전통적으로 \u0026ldquo;git status 실행해줘\u0026quot;라고 자연어로 요청했다면, 이제는 더 빠른 방법이 있습니다. 프롬프트 앞에 느낌표(!)를 붙여서 !git status처럼 입력하면 bash가 즉시 실행됩니다.\n이 방식의 장점은 다음과 같습니다:\n속도 향상: 자연어 처리 없이 즉시 명령 실행 토큰 절약: 모델 추론 과정이 없어 토큰 소비 감소 대기시간 단축: 실행 결과가 바로 대화 맥락에 반영 작업 흐름 유지: 개발 리듬이 끊어지지 않음 예시: !npm install, !python script.py, !yarn build\n2. Esc 두 번으로 이전 상태 되돌리기 핵심 개념: 실험적 개발의 안전장치 아이디어를 여러 번 시도하다가 코드 흐름이 꼬였을 때, Esc 키를 두 번 누르면 깔끔한 지점으로 바로 복구할 수 있습니다. 이것은 Git의 undo 개념과 유사하지만 더 세분화되어 있습니다.\n활용 방식:\n대화 내용만 되감기 생성된 코드만 되감기 대화 내용과 코드 모두 되감기 이 기능은 \u0026ldquo;만약 이렇게 했다면?\u0026ldquo;이라는 가정 하에 여러 방향으로 실험할 수 있게 해줍니다. 리팩토링 작업이나 아키텍처 개선 때 유용합니다.\n3. API에서 Extended Thinking 켜기 핵심 개념: 복잡한 문제에 대한 깊이 있는 사고 활성화 Claude API를 사용할 때, 요청에 thinking 파라미터를 추가하면 Extended Thinking 기능을 활성화할 수 있습니다:\n{ \u0026#34;thinking\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;enabled\u0026#34;, \u0026#34;budget_tokens\u0026#34;: 5000 } } 이는 Claude가 답변을 주기 전에 \u0026ldquo;thinking blocks\u0026quot;라는 내부 추론 과정을 거치게 합니다. 수학 문제, 알고리즘 설계, 복잡한 로직 분석 같은 작업에서 훨씬 더 정확한 결과를 얻을 수 있습니다.\n언제 사용할까:\n복잡한 알고리즘 구현 아키텍처 설계 검토 버그 원인 분석 성능 최적화 전략 4. \u0026ndash;continue와 \u0026ndash;resume으로 세션 이어가기 핵심 개념: 작업 연속성 보장\n노트북을 닫거나 터미널을 종료해도 작업을 이어갈 수 있습니다.\n두 가지 옵션:\nclaude --continue: 직전 대화를 그대로 이어서 진행\n$ claude --continue 이전 세션의 컨텍스트가 완전히 복원되어 마지막 지점에서 계속 작업할 수 있습니다.\nclaude --resume: 과거 세션 목록에서 선택\n$ claude --resume 저장된 모든 세션을 보고 원하는 것을 선택하여 재개할 수 있습니다. 여러 프로젝트를 동시에 진행 중일 때 유용합니다.\n실용적 사용 사례:\n장시간 실행되는 작업 중단 후 재개 다양한 프로젝트 간 빠른 전환 세션 기반 작업 관리 5. # 프리픽스로 메모리 바로 저장 핵심 개념: 파일 편집 없이 설정 정보 저장\n반복적으로 사용되는 설정이나 규칙을 메모리에 저장할 수 있습니다. 프롬프트 앞에 해시(#)를 붙여 입력하면:\n# Always use bun instead of npm # Always create TypeScript files # Use async/await patterns exclusively 이러한 규칙들은 Claude의 메모리에 저장되어 이후 모든 대화에서 자동으로 적용됩니다. 복잡한 설정 파일을 편집할 필요가 없습니다.\n장점:\n즉각적인 규칙 적용 프로젝트별 관례 통일 수정이 간편함 6. /vim으로 프롬프트 편집을 키보드로 핵심 개념: 마우스 없는 편집 경험\nClaude Code에서 /vim을 입력하면 vim 에디터 방식으로 프롬프트를 편집할 수 있습니다. 이는 다음과 같은 이점이 있습니다:\nvim 명령어 지원:\nh j k l: 상하좌우 이동 i: 입력 모드 dd: 한 줄 삭제 cw: 단어 바꾸기 esc: 명령 모드 복귀 터미널에서 vim에 익숙한 개발자들에게 매우 효율적입니다. 복잡한 다중 라인 프롬프트를 작성할 때 특히 유용합니다.\n7. -p 옵션으로 Headless 모드 사용 핵심 개념: 스크립트와 자동화 파이프라인 통합 Claude Code 실행 시 -p 옵션을 붙이면 대화형 인터페이스 없이 순수 명령어처럼 작동합니다:\nclaude -p \u0026#34;create a util logging function\u0026#34; 사용 사례:\nCI/CD 파이프라인 통합 자동화된 코드 생성 스크립트 배치 작업 Git hooks 연동 이는 Claude Code를 기존의 개발 워크플로우에 자연스럽게 통합할 수 있게 합니다.\n8. /context로 토큰 사용 내역 확인 핵심 개념: 컨텍스트 윈도우 관리\nClaude Code에서 /context를 입력하면 현재 사용 중인 토큰을 상세히 분석할 수 있습니다:\n시스템 프롬프트가 사용하는 토큰 MCP 서버 연결에 사용되는 토큰 메모리 파일이 차지하는 공간 대화 이력이 차지하는 공간 이 정보를 통해:\n토큰 한도 내에서 최적 성능 유지 불필요한 메모리 정리 파일 첨부 관리 대화 이력 압축 9. 원격 세션으로 웹과 터미널 오가며 작업 핵심 개념: 다중 환경에서의 작업 동시화\n프롬프트 앞에 앰퍼샌드(\u0026amp;)를 붙이면 작업을 Claude Code의 웹 인터페이스로 보내 백그라운드에서 실행할 수 있습니다:\n\u0026amp; npm run build \u0026amp; python manage.py migrate 장점:\n브라우저 기반 작업 모니터링 터미널과 웹 인터페이스 간 자유로운 전환 장시간 실행 작업 진행 상황 추적 터미널 리소스 절약 10. /stats로 Claude Code 사용 기록 보기 핵심 개념: 사용 패턴 분석\n/stats 명령으로 Claude Code의 사용 통계를 확인할 수 있습니다:\n전체 작업 수행 횟수 일일/주간/월간 사용량 가장 자주 사용되는 명령어 코드 작성 대 코드 실행 비율 가장 오래 지속된 세션 이 데이터는 자신의 개발 습관을 이해하고 생산성을 개선하는 데 도움이 됩니다. GitHub의 잔디 같은 시각적 피드백도 제공됩니다.\n11. 세션에 이름 붙여서 관리하기 핵심 개념: 작업별 세션 조직화\n/rename 명령으로 현재 세션에 의미 있는 이름을 붙일 수 있습니다:\n/rename api-migration /rename database-refactor /rename performance-optimization 이후 /resume를 사용할 때 이름으로 검색하여 원하는 세션을 빠르게 찾을 수 있습니다. 여러 프로젝트를 동시에 관리할 때 매우 유용합니다.\n12. 키워드로 생각 깊이 조절하기 핵심 개념: 사고 깊이 맞춤화\n프롬프트에 특정 단어를 포함하면 Claude가 사용하는 사고 토큰의 양이 달라집니다:\n\u0026ldquo;think\u0026rdquo;: 기본 수준의 사고 \u0026ldquo;think hard\u0026rdquo;: 더 깊은 분석 \u0026ldquo;ultrathink\u0026rdquo;: 최대 깊이의 사고 \u0026ldquo;이 알고리즘을 생각 hard으로 최적화해줘\u0026rdquo; 복잡한 문제에는 \u0026ldquo;ultrathink\u0026quot;를 사용하여 Claude가 더 오래 생각하게 하고, 간단한 작업에는 기본 \u0026ldquo;think\u0026quot;를 사용하여 속도를 높입니다.\n13. 프롬프트 임시 저장하기 핵심 개념: 초안 자동 보관 입력 중인 프롬프트에서 Ctrl+S를 누르면 초안이 자동으로 저장됩니다:\n다른 메시지를 보내도 자동으로 복원 메모장이나 외부 저장소 불필요 복잡한 멀티라인 프롬프트 안전 보관 생각이 정리되지 않은 상태에서도 작업 중단 가능 14. /statusline으로 하단 정보 바 꾸미기 핵심 개념: 화면 정보 맞춤 설정 /statusline 명령으로 Claude Code 화면 아래의 상태 바를 설정할 수 있습니다:\n표시 가능한 정보:\n현재 시간 토큰 사용량 활성 세션 이름 프로젝트 상태 마지막 명령 실행 시간 자신이 중요하게 생각하는 정보만 선택하여 표시하므로 작업 중 필요한 정보를 한눈에 파악할 수 있습니다.\n15. YOLO 모드로 권한 확인 없이 실행 핵심 개념: 신뢰할 수 있는 환경에서의 빠른 작업 --dangerously-skip-permissions 플래그를 사용하면 파일 생성, 명령 실행, 수정마다 묻지 않고 바로 진행합니다:\nclaude --dangerously-skip-permissions 주의사항:\n신뢰할 수 있는 프로젝트에서만 사용 자신이 작성한 코드만 함께 작업할 때 안전 외부 코드를 실행할 때는 비활성화 이 모드를 사용하면 반복적인 승인 화면을 거치지 않아 개발 속도가 크게 향상됩니다.\n16. Hooks로 실행 흐름 직접 제어하기 핵심 개념: 자동화된 작업 흐름\nHooks는 특정 시점에 자동으로 실행되는 쉘 명령입니다. /hooks 또는 .claude/settings.json에서 설정할 수 있습니다:\n예시:\non-start: npm install on-before-save: eslint . on-after-execute: npm test 이를 통해:\n세션 시작 시 자동으로 의존성 설치 코드 저장 전 린트 검사 명령 실행 후 자동 테스트 17. @ 멘션으로 컨텍스트 빠르게 추가 핵심 개념: 대화 맥락 빠른 로딩\nClaude Code에서 @를 입력하면 다양한 항목을 즉시 대화에 포함할 수 있습니다:\n@src/utils.ts - 특정 파일 @/src - 전체 디렉터리 @mcp-server - MCP 서버 @subagent - 서브에이전트 파일을 일일이 첨부할 필요 없이 간단한 입력으로 필요한 컨텍스트를 모두 로드합니다.\n18. 다음 프롬프트 자동 제안 받기 핵심 개념: 워크플로우 최적화 제안 작업이 완료되면 Claude가 회색 글씨로 다음 단계를 제안합니다:\n테스트 작성 제안 리팩토링 권장 문서화 필요성 지적 관련 기능 구현 제안 이 제안에:\nTab: 불러와서 수정 후 사용 Enter: 바로 실행 Esc: 무시 19. /chrome으로 브라우저 직접 제어 핵심 개념: 웹 개발 자동화 Claude Code에서 /chrome을 실행하면 브라우저를 직접 제어할 수 있습니다:\n가능한 작업:\n페이지 이동 및 로딩 버튼 클릭 및 입력 콘솔 에러 확인 DOM 검사 및 수정 스크린샷 캡처 웹 애플리케이션 개발 시 실시간으로 브라우저 상태를 확인하고 조정할 수 있습니다.\n20. Agent Skills로 작업 방식 재사용하기 핵심 개념: 재사용 가능한 작업 패턴 Agent Skills는 특정 작업 방법을 폴더 단위로 정의하여 Claude에게 가르치는 방식입니다.\n한 번 설정하면:\n다른 프로젝트에서 동일한 작업 패턴 재사용 팀 전체와 최적의 작업 방법 공유 시간이 지나도 일관된 품질 유지 예: 데이터베이스 마이그레이션 패턴, API 작성 규칙, 테스트 전략 등\n21. 플러그인으로 설정 한 번에 공유하기 핵심 개념: 작업 환경 포장화 여러 파일과 설정을 따로 주고받지 않고 플러그인으로 패킹합니다:\nplugin install my-project-setup 이는 다음을 포함합니다:\n프로젝트 설정 파일 린트 규칙 포매터 설정 테스트 프레임워크 구성 커스텀 명령어 새로운 개발자가 한 줄 명령어로 동일한 환경을 구성할 수 있습니다.\n22. Ctrl+R로 이전 프롬프트 다시 쓰기 핵심 개념: 명령어 히스토리 검색\nClaude Code에서 Ctrl+R을 누르면 bash의 역방향 검색처럼 과거 프롬프트를 검색할 수 있습니다:\n입력하며 검색: 자동으로 일치하는 프롬프트 제시 Enter: 바로 실행 Tab: 프롬프트를 불러와 수정 자주 사용하는 복잡한 프롬프트를 빠르게 재사용할 수 있습니다.\n23. /init으로 자동 온보딩 문서 만들기 핵심 개념: 프로젝트 문서 자동화\nClaude Code에서 /init을 실행하면 코드베이스를 자동으로 분석하여 CLAUDE.md 문서를 생성합니다:\n포함 내용:\n프로젝트 구조 설명 빌드 명령어 테스트 실행 방법 주요 디렉터리별 역할 환경 설정 방법 핵심 기술 스택 새로운 팀원이나 다른 개발자가 프로젝트에 빠르게 적응할 수 있도록 돕습니다.\n24. /export로 대화 기록 문서화 핵심 개념: 작업 기록 자동 저장\n/export를 실행하면 현재 대화의 모든 내용을 마크다운 파일로 내보냅니다:\n포함 항목:\n모든 프롬프트와 응답 실행된 명령어와 결과 도구 호출 이력 시간 기록 이는 다음에 유용합니다:\n작업 회고 및 분석 팀 간의 지식 공유 프로젝트 진행 과정 문서화 미래 참고 자료 25. Subagents로 작업 나눠 병렬 처리 핵심 개념: 분산 작업 처리\nSubagents는 각각 200k 토큰의 독립적인 컨텍스트를 가진 보조 에이전트입니다:\n@subagent1: API 엔드포인트 구현 @subagent2: 데이터베이스 스키마 설계 @subagent3: 테스트 케이스 작성 장점:\n복잡한 작업을 병렬로 처리 서브에이전트 간 자동 결과 통합 대규모 프로젝트의 개발 시간 단축 각 에이전트가 분야별로 최적화 26. 프롬프트를 명령어로 저장하기 핵심 개념: 자주 쓰는 작업의 단축키화\n반복되는 프롬프트를 마크다운 파일로 저장하면 슬래시 명령어로 변환됩니다:\n.claude/commands/explain.md:\n# explain 설명해줘: {selected_code} - 목적 분석 - 핵심 로직 설명 - 주의사항 지적 사용: /explain\n인자 지원:\n/review --strict /generate --typescript 27. Sandbox 모드로 권한 한 번에 설정하기 핵심 개념: 보안과 효율성의 균형\nSandbox 모드를 활성화하면 실행 가능한 범위를 미리 정의합니다:\nsandbox: - allow: src/** (코드 편집) - allow: npm run* (스크립트 실행) - deny: rm -rf (위험 작업 차단) 이 범위 내에서 Claude는 반복적인 권한 확인 없이 작업합니다:\n빠른 개발 속도: 승인 화면 최소화 안전성: 위험 작업 사전 차단 효율적 관리: 권한 정책 중앙 관리\n28. /usage로 사용 한도 확인하기 핵심 개념: 토큰 한도 관리\n/usage 명령으로 현재 상태를 확인합니다:\n사용한 토큰 수 남은 토큰 수 한도까지의 남은 비율 추가 사용 요청 옵션 토큰 한도에 가까워지면 /extra-usage로 추가 요청을 할 수 있습니다.\n29. Plan Mode로 수정 전 전체 흐름 파악 핵심 개념: 읽기 전용 분석 모드\nShift+Tab 두 번으로 Plan Mode를 활성화합니다:\nPlan Mode의 특징:\n코드는 수정하지 않음 읽기, 검색, 분석만 진행 구조와 흐름을 파악 구현 전 전략 수립 이 모드에서:\n코드 구조 파악 의존성 관계 분석 리팩토링 계획 수립 잠재적 문제점 식별 30. LSP로 코드 이해도 높이기 핵심 개념: IDE 수준의 개발 환경 Claude Code에 Language Server Protocol(LSP)을 연결하면:\nIDE 기능 활용:\n실시간 오류 및 경고 표시 정의로 이동 (Go to Definition) 모든 참조 찾기 변수명 리팩토링 타입 정보 자동 완성 TypeScript, Python, Go 등 주요 언어를 지원하여 IDE 수준의 개발 경험을 제공합니다.\n31. Claude Agent SDK로 에이전트 직접 만들기 핵심 개념 커스텀 AI 에이전트 개발 Claude Code에서 사용되던 에이전트 구조(루프, 도구 사용, 컨텍스트 관리)가 SDK 형태로 제공됩니다:\nSDK로 가능한 것:\nfrom anthropic import Anthropic client = Anthropic() # 에이전트 루프 구현 # 도구 정의 및 사용 # 컨텍스트 관리 활용 사례:\n자동화된 데이터 처리 에이전트 고객 지원 챗봇 코드 리뷰 자동화 시스템 모니터링 에이전트 단 몇 줄 코드로 강력한 커스텀 에이전트를 만들 수 있습니다.\n","date":"2026-01-01","permalink":"/post/2026/2026-01-01-claude-code-31-tips/","section":"post","summary":"Anthropic에서 공유한 Claude Code의 생산성 향상 팁을 정리했습니다. Claude Code를 더욱 효율적으로 사용하기 위한 실용적인 가이드입니다.\n","title":"Claude Code 완벽 활용 가이드: 31가지 필수 꿀팁"},{"content":"문제 상황: 개발자의 일상적인 고민 PyCharm에서 IdeaVim을 사용하며 개발하다 보면 정말 자주 마주치는 상황이 있습니다. 한글로 주석을 쓰다가 ESC 키를 눌러 Normal 모드로 나온 후, 다시 명령어를 입력하려고 할 때 입력기가 여전히 한글 상태라 명령어가 제대로 작동하지 않는 것이죠.\n왜 이런 문제가 발생할까요? IdeaVim의 특성: IdeaVim은 영문 키 입력만을 Normal 모드에서 명령어로 해석합니다 한글 상태의 문제: 한글 입력 상태에서는 Normal 모드 명령어가 제대로 동작하지 않습니다 번거로운 작업: ESC → 한/영 키 → 명령어 입력이라는 반복적인 패턴 \u0026ldquo;ESC 한 번 누르고 한/영 한 번 누르면 되지 않나?\u0026ldquo;라고 생각할 수 있지만, 이는 생각보다 엄청나게 짜증나고 거슬리는 작업입니다.\n해결책: AutoHotkey로 자동화하기 핵심 아이디어 ESC 키가 눌리면 무조건 영문으로 전환시킨다!\n이 문제를 해결하기 위해 Windows의 강력한 자동화 도구인 AutoHotkey를 사용하겠습니다.\n1단계: AutoHotkey 설치 AutoHotkey 스크립트를 실행하려면 먼저 AutoHotkey를 설치해야 합니다.\n설치 링크: https://www.autohotkey.com\nAutoHotkey는 Windows에서 키 입출력 관련 기능에 특화된 스크립트 언어로, 다양한 자동화 작업을 수행할 수 있습니다.\n2단계: IME 상태 확인 코드 현재 입력기가 한글인지 영문인지 확인하는 기능이 필요합니다. 다음 코드를 사용하여 IME 상태를 확인할 수 있습니다:\n/* IME check */ IME_CHECK(WinTitle) { WinGet,hWnd,ID,%WinTitle% Return Send_ImeControl(ImmGetDefaultIMEWnd(hWnd),0x005,\u0026#34;\u0026#34;) } Send_ImeControl(DefaultIMEWnd, wParam, lParam) { DetectSave := A_DetectHiddenWindows DetectHiddenWindows,ON SendMessage 0x283, wParam,lParam,,ahk_id %DefaultIMEWnd% if (DetectSave \u0026lt;\u0026gt; A_DetectHiddenWindows) DetectHiddenWindows,%DetectSave% return ErrorLevel } ImmGetDefaultIMEWnd(hWnd) { return DllCall(\u0026#34;imm32\\ImmGetDefaultIMEWnd\u0026#34;, Uint,hWnd, Uint) } 3단계: ESC 키 자동 전환 스크립트 이제 ESC 키를 누르면 항상 영문 입력으로 전환되도록 하는 완전한 스크립트를 작성해보겠습니다:\n$Esc:: ret := IME_CHECK(\u0026#34;A\u0026#34;) if %ret% \u0026lt;\u0026gt; 0 ; 1 means IME is in Hangul(Korean) mode now. { Send, {Esc} Send, {vk15} ; 한글인 경우 Esc키를 입력하고 한영키를 입력해 준다. } else if %ret% = 0 ; 0 means IME is in English mode now. { Send, {Esc} ; 영문인 경우 Esc키만 입력한다. } return /* IME check */ IME_CHECK(WinTitle) { WinGet,hWnd,ID,%WinTitle% Return Send_ImeControl(ImmGetDefaultIMEWnd(hWnd),0x005,\u0026#34;\u0026#34;) } Send_ImeControl(DefaultIMEWnd, wParam, lParam) { DetectSave := A_DetectHiddenWindows DetectHiddenWindows,ON SendMessage 0x283, wParam,lParam,,ahk_id %DefaultIMEWnd% if (DetectSave \u0026lt;\u0026gt; A_DetectHiddenWindows) DetectHiddenWindows,%DetectSave% return ErrorLevel } ImmGetDefaultIMEWnd(hWnd) { return DllCall(\u0026#34;imm32\\ImmGetDefaultIMEWnd\u0026#34;, Uint,hWnd, Uint) } 코드 동작 원리 IME 상태 확인: 현재 입력기가 한글(1) 또는 영문(0) 상태인지 확인 조건부 처리: 한글 상태라면: ESC + 한/영 키 전송 영문 상태라면: ESC 키만 전송 결과: 어떤 상태든 ESC 후에는 항상 영문 입력 상태가 됨 4단계: 스크립트 실행 및 테스트 위 코드를 esc_force_english.ahk 파일로 저장합니다 파일을 더블클릭하여 실행합니다 Windows 우측 하단에 AutoHotkey 아이콘이 나타나면 실행 완료입니다 테스트 결과 스크립트 실행 후 테스트해보면:\n한글 입력 상태에서 ESC를 누르면 → 자동으로 영문 상태로 전환 영문 입력 상태에서 ESC를 누르면 → 영문 상태 유지 정말 \u0026ldquo;개비스콘이 따로 없는\u0026rdquo; 효과입니다!\n5단계: 시스템 시작 시 자동 실행 설정 매번 부팅할 때마다 스크립트를 수동으로 실행하는 것은 번거롭습니다. Windows 시작 시 자동으로 실행되도록 설정해보겠습니다.\nStartup 폴더 활용 Windows에는 Startup 이라는 특수 폴더가 있습니다. 이 폴더에 저장된 바로가기 파일은 Windows 부팅 시 자동으로 실행됩니다.\nStartup 폴더 경로:\nC:\\Users\\[사용자명]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 빠른 접근 방법:\nWindows + R 키를 누릅니다 shell:startup을 입력합니다 Enter를 누르면 Startup 폴더가 열립니다 바로가기 파일 생성 esc_force_english.ahk 파일을 우클릭합니다 \u0026ldquo;바로가기 만들기\u0026quot;를 선택합니다 생성된 바로가기를 Startup 폴더에 복사합니다 완성! 이제 컴퓨터를 켜면 ESC 키가 항상 영문 전환! 설정을 완료하면:\n✅ Windows 부팅 시 자동으로 스크립트 실행 ✅ ESC 키를 누르면 항상 영문 입력 상태로 전환 ✅ 개발 시 한/영 키를 수동으로 누를 필요가 없음 추가 팁 및 주의사항 다른 환경에서의 응용 이 방법은 Windows 환경에서만 사용 가능합니다. 다른 운영체제의 경우:\nmacOS: Hammerspoon이나 Karabiner-Elements 사용 Linux: xkb-switch나 fcitx-remote 명령어 활용 스크립트 수정 및 확장 필요에 따라 스크립트를 수정할 수 있습니다:\n; 다른 키에도 동일한 기능 적용 $F1:: ret := IME_CHECK(\u0026#34;A\u0026#34;) if %ret% \u0026lt;\u0026gt; 0 Send, {vk15} Send, {F1} return 성능 고려사항 AutoHotkey는 가벼운 프로그램이므로 시스템 성능에 큰 영향을 주지 않습니다 메모리 사용량도 매우 적습니다 (보통 1-2MB 수준) exe 파일 다운로드 받기 바이너리로 컴파일 된 auto-hotkey 파일은 아래 주소에서 받을 수 있습니다.\nDownload Link 마무리 이제 더 이상 ESC 키를 누른 후 한/영 키를 따로 누를 필요가 없습니다!\nIdeaVim이나 다른 Vim 에뮬레이터를 사용하는 개발자라면 이 설정으로 인해 개발 효율성이 크게 향상될 것입니다. 작은 자동화 하나가 개발 경험을 얼마나 개선시킬 수 있는지 보여주는 좋은 예시라고 생각합니다.\n개발자의 시간은 소중하니까요! 이런 반복적인 작업은 자동화로 해결하고, 더 중요한 코딩에 집중하시길 바랍니다.\n참고: 이 글은 실제 개발 환경에서 겪은 불편함을 해결하기 위한 실용적인 방법을 소개합니다. AutoHotkey의 더 많은 활용법이 궁금하시다면 공식 문서를 참고해보세요!\n","date":"2025-07-25","permalink":"/post/2025/2025-07-25-vim-esc/","section":"post","summary":"문제 상황: 개발자의 일상적인 고민 PyCharm에서 IdeaVim을 사용하며 개발하다 보면 정말 자주 마주치는 상황이 있습니다. 한글로 주석을 쓰다가 ESC 키를 눌러 Normal 모드로 나온 후, 다시 명령어를 입력하려고 할 때 입력기가 여전히 한글 상태라 명령어가 제대로 작동하지 않는 것이죠.\n","title":"Windows에서 ESC 키를 누르면 자동으로 영어 입력 상태로 전환하는 방법"},{"content":"Vim에서 Neovim으로 전향한 이유 VSCode에서 Vim extension을 오랫동안 사용해왔습니다. Vim의 강력한 편집 기능을 VSCode에서도 사용할 수 있다는 점은 매우 매력적이었죠. 하지만 한 가지 치명적인 문제가 있었습니다. 바로 한글 입력 시 타이밍이 밀리는 현상이었습니다.\n한글을 빠르게 타이핑하다 보면 글자가 제대로 입력되지 않거나, 입력 순서가 뒤바뀌는 등의 문제가 자주 발생했습니다. 이는 작업 효율성을 크게 떨어뜨렸고, 결국 대안을 찾게 되었습니다. 그 대안이 바로 VSCode Neovim Extension입니다.\nNeovim Extension은 실제 Neovim 프로세스를 백그라운드에서 실행하여 VSCode와 통신하는 방식으로 작동합니다. 이로 인해 Vim extension보다 더 안정적이고, 한글 입력 문제도 해결되었습니다.\nmacOS에서 Neovim 설치하기 1. Homebrew를 통한 설치 macOS에서는 Homebrew를 통해 쉽게 Neovim을 설치할 수 있습니다.\n# Homebrew가 설치되어 있지 않다면 먼저 설치 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # Neovim 설치 brew install neovim 2. 설치 확인 nvim --version 정상적으로 설치되었다면 Neovim 버전 정보가 출력됩니다.\nWindows에서 Neovim 설치하기 1. Chocolatey를 통한 설치 Windows에서는 Chocolatey 패키지 매니저를 사용하는 것이 가장 간편합니다.\n# PowerShell을 관리자 권한으로 실행 후 # Chocolatey가 설치되어 있지 않다면 먼저 설치 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) # Neovim 설치 choco install neovim 2. Scoop을 통한 설치 (대안) Scoop을 선호한다면 다음과 같이 설치할 수 있습니다.\n# Scoop 설치 iwr -useb get.scoop.sh | iex # Neovim 설치 scoop install neovim 3. 수동 설치 공식 GitHub 릴리즈 페이지에서 직접 다운로드할 수도 있습니다.\nNeovim GitHub Releases에서 최신 Windows 버전 다운로드 zip 파일 압축 해제 시스템 환경 변수 PATH에 nvim.exe가 있는 폴더 경로 추가 VSCode Neovim Extension 설치 및 설정 1. Extension 설치 VSCode Extension 마켓플레이스에서 \u0026ldquo;vscode-neovim\u0026quot;을 검색하여 설치합니다.\n2. Extension 설정 settings.json에 다음 설정을 추가합니다:\n{ // Neovim 실행 파일 경로 (필요한 경우) \u0026#34;vscode-neovim.neovimExecutablePaths.darwin\u0026#34;: \u0026#34;/opt/homebrew/bin/nvim\u0026#34;, \u0026#34;vscode-neovim.neovimExecutablePaths.win32\u0026#34;: \u0026#34;C:\\\\tools\\\\neovim\\\\nvim-win64\\\\bin\\\\nvim.exe\u0026#34;, // 기타 유용한 설정 \u0026#34;vscode-neovim.neovimInitVimPaths.darwin\u0026#34;: \u0026#34;$HOME/.config/nvim/init.lua\u0026#34;, \u0026#34;vscode-neovim.neovimInitVimPaths.win32\u0026#34;: \u0026#34;$HOME/AppData/Local/nvim/init.lua\u0026#34; } Neovim 설정 파일 작성 1. 설정 파일 위치 macOS/Linux: ~/.config/nvim/init.lua Windows: ~/AppData/Local/nvim/init.lua 2. 기본 설정 파일 생성 # macOS/Linux mkdir -p ~/.config/nvim touch ~/.config/nvim/init.lua # Windows (PowerShell) New-Item -Path \u0026#34;$env:LOCALAPPDATA\\nvim\u0026#34; -ItemType Directory -Force New-Item -Path \u0026#34;$env:LOCALAPPDATA\\nvim\\init.lua\u0026#34; -ItemType File -Force 3. Packer 플러그인 매니저 설치 Neovim의 플러그인을 관리하기 위해 Packer를 먼저 설치해야 합니다:\n# macOS/Linux git clone --depth 1 https://github.com/wbthomason/packer.nvim \\ ~/.local/share/nvim/site/pack/packer/start/packer.nvim # Windows (PowerShell) git clone --depth 1 https://github.com/wbthomason/packer.nvim ` \u0026#34;$env:LOCALAPPDATA\\nvim-data\\site\\pack\\packer\\start\\packer.nvim\u0026#34; 4. init.lua 작성 다음은 제가 사용하는 init.lua 설정입니다:\n-- Packer 설치 (플러그인 매니저) local ensure_packer = function() local fn = vim.fn local install_path = fn.stdpath(\u0026#39;data\u0026#39;)..\u0026#39;/site/pack/packer/start/packer.nvim\u0026#39; if fn.empty(fn.glob(install_path)) \u0026gt; 0 then fn.system({\u0026#39;git\u0026#39;, \u0026#39;clone\u0026#39;, \u0026#39;--depth\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;https://github.com/wbthomason/packer.nvim\u0026#39;, install_path}) vim.cmd [[packadd packer.nvim]] return true end return false end local packer_bootstrap = ensure_packer() -- 플러그인 설정 require(\u0026#39;packer\u0026#39;).startup(function(use) use \u0026#39;wbthomason/packer.nvim\u0026#39; use { \u0026#39;easymotion/vim-easymotion\u0026#39; } end) -- OS별 클립보드 설정 if vim.fn.has(\u0026#39;win32\u0026#39;) == 1 then vim.opt.clipboard = \u0026#34;unnamed,unnamedplus\u0026#34; elseif vim.fn.has(\u0026#39;macunix\u0026#39;) == 1 then vim.opt.clipboard = \u0026#34;unnamedplus\u0026#34; end vim.g.mapleader = \u0026#34;,\u0026#34; -- Leader 키 설정 -- EasyMotion 키맵 설정 local opts = { noremap = true, silent = true } -- EasyMotion 키맵들 vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;\u0026lt;leader\u0026gt;f\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(easymotion-bd-f)\u0026#39;, {}) vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;\u0026lt;leader\u0026gt;w\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(easymotion-w)\u0026#39;, {}) vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;\u0026lt;leader\u0026gt;b\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(easymotion-b)\u0026#39;, {}) vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;\u0026lt;leader\u0026gt;j\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(easymotion-j)\u0026#39;, {}) vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;\u0026lt;leader\u0026gt;k\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(easymotion-k)\u0026#39;, {}) -- Y를 누르면 라인 yank가 되도록 설정 vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;yy\u0026#39;, { noremap = true }) -- Visual Block 모드를 위한 여러 키 바인딩 vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;C-q\u0026gt;\u0026#39;, \u0026#39;\u0026lt;C-v\u0026gt;\u0026#39;, opts) vim.api.nvim_set_keymap(\u0026#39;v\u0026#39;, \u0026#39;\u0026lt;C-q\u0026gt;\u0026#39;, \u0026#39;\u0026lt;C-v\u0026gt;\u0026#39;, opts) -- 추가 대안 (leader 키 사용) vim.api.nvim_set_keymap(\u0026#39;n\u0026#39;, \u0026#39;\u0026lt;leader\u0026gt;v\u0026#39;, \u0026#39;\u0026lt;C-v\u0026gt;\u0026#39;, opts) -- 상태라인에 모드 표시 (선택사항) vim.opt.showmode = true -- 완성 메뉴 메시지 숨기기 vim.opt.shortmess:append(\u0026#34;c\u0026#34;) vim.opt.ignorecase = true vim.opt.smartcase = true 5. 플러그인 설치 init.lua 파일을 작성한 후, Neovim을 실행하여 플러그인을 설치해야 합니다:\n# Neovim 실행 nvim # Neovim 내에서 다음 명령어 입력 :PackerInstall 처음 실행 시 Packer가 자동으로 설치되며, 이후 hop.nvim을 포함한 설정된 플러그인들이 설치됩니다. 설치가 완료되면 Neovim을 재시작하세요.\nhop.nvim 플러그인 사용법 왜 hop.nvim인가? VSCode의 Vim Extension을 사용할 때는 EasyMotion이라는 훌륭한 기능이 내장되어 있었습니다. 하지만 Neovim Extension으로 전환하면서 이 기능이 없어진 것을 발견했습니다. EasyMotion은 화면에 보이는 텍스트로 빠르게 이동할 수 있게 해주는 필수적인 기능이었기에, 이를 대체할 플러그인이 필요했습니다.\nhop.nvim은 EasyMotion의 Neovim 버전으로, 동일한 기능을 제공합니다. 화면의 특정 위치로 빠르게 이동할 수 있게 해주는 이 플러그인은 생산성 향상에 큰 도움이 됩니다.\n사용법 ,,f: 화면의 모든 단어로 점프 ,,w: 커서 이후의 단어로 점프 ,,b: 커서 이전의 단어로 점프 ,,j: 아래쪽 라인으로 점프 ,,k: 위쪽 라인으로 점프 키맵 및 클립보드 설정 설명 Leader 키 ,를 Leader 키로 설정했습니다. 이는 사용자 정의 단축키의 prefix로 사용됩니다.\n클립보드 통합 OS별로 시스템 클립보드와 Neovim의 클립보드를 통합했습니다. 이제 y로 복사한 내용을 다른 프로그램에서도 붙여넣을 수 있습니다.\nVisual Block 모드 일부 터미널에서 Ctrl+V가 붙여넣기로 사용되는 경우를 위해 Ctrl+Q를 Visual Block 모드로 매핑했습니다.\n마무리 VSCode Neovim Extension을 사용하면 Vim의 강력한 기능을 VSCode에서 안정적으로 사용할 수 있습니다. 특히 한글 입력 문제가 해결되어 한국어로 작업하는 개발자들에게 큰 도움이 될 것입니다.\n설정이 완료되면 VSCode를 재시작하고, Neovim의 모든 기능을 VSCode에서 즐기세요!\n","date":"2025-07-24","permalink":"/post/2025/2025-07-24-vscode-neovim-extension/","section":"post","summary":"Vim에서 Neovim으로 전향한 이유 VSCode에서 Vim extension을 오랫동안 사용해왔습니다. Vim의 강력한 편집 기능을 VSCode에서도 사용할 수 있다는 점은 매우 매력적이었죠. 하지만 한 가지 치명적인 문제가 있었습니다. 바로 한글 입력 시 타이밍이 밀리는 현상이었습니다.\n","title":"VSCode에서 Neovim Extension 설정하기: macOS \u0026 Windows 가이드"},{"content":"지난포스트에서는 Next.js 프로젝트를 진행하면서 유용하게 사용할 수 있는 자작 커스텀 훅, useFormUrlSync을 개선한 버전에 대해서 이야기 해 봅니다.\n전체 소스 코드 \u0026#34;use client\u0026#34;; import type { AliasAny } from \u0026#34;@/types/alias.types\u0026#34;; import { isNumber } from \u0026#34;es-toolkit/compat\u0026#34;; import { useRouter, useSearchParams } from \u0026#34;next/navigation\u0026#34;; import { useCallback, useEffect, useRef } from \u0026#34;react\u0026#34;; import { type DefaultValues, type FieldValues, type UseFormProps, type UseFormReturn, useForm } from \u0026#34;react-hook-form\u0026#34;; /** * useFormUrlSync 훅의 옵션 타입 * @template T - 폼 필드 값들의 타입 */ type UseFormUrlSyncOptions\u0026lt;T extends FieldValues\u0026gt; = Omit\u0026lt;UseFormProps\u0026lt;T\u0026gt;, \u0026#34;defaultValues\u0026#34;\u0026gt; \u0026amp; { /** URL 동기화에서 제외할 필드명들 */ excludeFromUrl?: (keyof T)[]; /** URL 변경 시 replace 사용 여부 (기본값: true) */ replace?: boolean; /** 폼의 기본값들 */ defaultValues: DefaultValues\u0026lt;T\u0026gt;; /** URL 실시간 동기화 여부 (기본값: true) */ sync?: boolean; }; /** * useFormUrlSync 훅의 반환 타입 * @template T - 폼 필드 값들의 타입 */ type UseFormUrlSyncReturn\u0026lt;T extends FieldValues\u0026gt; = UseFormReturn\u0026lt;T\u0026gt; \u0026amp; { /** URL을 수동으로 동기화하는 함수 */ syncToUrl: () =\u0026gt; void; }; /** * URL 파라미터 값을 적절한 타입으로 파싱합니다. * @param value - 파싱할 문자열 값 * @returns 파싱된 값 (string | number | boolean) */ function parseUrlValue(value: string): string | number | boolean { if (value === \u0026#34;\u0026#34;) return value; if (value === \u0026#34;true\u0026#34;) return true; if (value === \u0026#34;false\u0026#34;) return false; const numValue = Number(value); if (isNumber(numValue) \u0026amp;\u0026amp; !Number.isNaN(numValue)) { return numValue; } return value; } /** * URL 검색 파라미터에서 초기값을 추출합니다. * @template T - 폼 필드 값들의 타입 * @param searchParams - URL 검색 파라미터 * @param excludeFromUrl - URL 동기화에서 제외할 필드명들 * @returns URL에서 추출한 초기값들 */ function extractInitialValuesFromUrl\u0026lt;T extends FieldValues\u0026gt;( searchParams: URLSearchParams, excludeFromUrl: (keyof T)[], ): Partial\u0026lt;T\u0026gt; { const urlValues: Partial\u0026lt;T\u0026gt; = {}; for (const [key, value] of searchParams.entries()) { if (!excludeFromUrl.includes(key as keyof T)) { (urlValues as AliasAny)[key] = parseUrlValue(value); } } return urlValues; } /** * 폼 값들로부터 URL 파라미터를 생성합니다. * @template T - 폼 필드 값들의 타입 * @param values - 폼 값들 * @param currentParams - 현재 URL 파라미터 * @param excludeFromUrl - URL 동기화에서 제외할 필드명들 * @returns 새로운 URLSearchParams 객체 */ function createUrlParamsFromValues\u0026lt;T extends FieldValues\u0026gt;( values: T, currentParams: URLSearchParams, excludeFromUrl: (keyof T)[], ): URLSearchParams { const params = new URLSearchParams(currentParams); for (const [key, value] of Object.entries(values)) { if (excludeFromUrl.includes(key as keyof T)) { continue; } if (value !== undefined \u0026amp;\u0026amp; value !== null \u0026amp;\u0026amp; value !== \u0026#34;\u0026#34;) { params.set(key, String(value)); } else { params.delete(key); } } return params; } /** * 두 객체의 깊은 비교를 수행합니다. * @param obj1 - 비교할 첫 번째 객체 * @param obj2 - 비교할 두 번째 객체 * @returns 객체들이 동일한지 여부 */ function deepEqual(obj1: AliasAny, obj2: AliasAny): boolean { return JSON.stringify(obj1) === JSON.stringify(obj2); } /** * React Hook Form과 URL 검색 파라미터를 양방향으로 동기화하는 커스텀 훅입니다. * * @template T - 폼 필드 값들의 타입, FieldValues를 확장해야 함 * @param options - 훅 설정 옵션 * @returns React Hook Form의 UseFormReturn 객체 * * @remarks * URL 파라미터는 자동으로 적절한 타입(string, number, boolean)으로 파싱됩니다. * 빈 문자열, null, undefined 값은 URL에서 제거됩니다. * Next.js의 useRouter와 useSearchParams를 사용하므로 Next.js 환경에서만 동작합니다. */ export function useFormUrlSync\u0026lt;T extends FieldValues\u0026gt;(options: UseFormUrlSyncOptions\u0026lt;T\u0026gt;): UseFormUrlSyncReturn\u0026lt;T\u0026gt; { const router = useRouter(); const searchParams = useSearchParams(); const { excludeFromUrl = [], replace = true, defaultValues, sync = true, ...formOptions } = options; const isUpdatingFromUrl = useRef(false); const getUrlValues = useCallback(() =\u0026gt; { return extractInitialValuesFromUrl\u0026lt;T\u0026gt;(searchParams, excludeFromUrl as (keyof T)[]); }, [searchParams, excludeFromUrl]); const initialValues = { ...defaultValues, ...getUrlValues(), } as DefaultValues\u0026lt;T\u0026gt;; const form = useForm({ ...formOptions, defaultValues: initialValues, }); const { watch, reset, getValues } = form; const updateUrl = useCallback( (values: T) =\u0026gt; { const params = createUrlParamsFromValues(values, searchParams, excludeFromUrl as (keyof T)[]); const newSearchString = params.toString(); const currentSearchString = new URLSearchParams(window.location.search).toString(); if (newSearchString !== currentSearchString) { const newUrl = `${window.location.pathname}?${newSearchString}`; if (replace) { router.replace(newUrl, { scroll: false }); } else { router.push(newUrl, { scroll: false }); } } }, [router, searchParams, excludeFromUrl, replace], ); const syncToUrl = useCallback(() =\u0026gt; { const values = getValues(); updateUrl(values); }, [getValues, updateUrl]); useEffect(() =\u0026gt; { if (sync) { const subscription = watch(values =\u0026gt; { if (isUpdatingFromUrl.current) { return; } updateUrl(values as T); }); return () =\u0026gt; subscription.unsubscribe(); } }, [watch, updateUrl, sync]); useEffect(() =\u0026gt; { const urlValues = getUrlValues(); const currentFormValues = getValues(); const relevantFormValues: Partial\u0026lt;T\u0026gt; = {}; for (const key in urlValues) { if (Object.prototype.hasOwnProperty.call(urlValues, key)) { relevantFormValues[key as keyof T] = currentFormValues[key as keyof T]; } } if (!deepEqual(urlValues, relevantFormValues)) { isUpdatingFromUrl.current = true; reset({ ...currentFormValues, ...urlValues, } as DefaultValues\u0026lt;T\u0026gt;); setTimeout(() =\u0026gt; { isUpdatingFromUrl.current = false; }, 0); } }, [getUrlValues, reset, getValues]); return { ...form, syncToUrl: syncToUrl, }; } 웹 애플리케이션에서 필터나 검색 기능을 구현할 때, 사용자가 설정한 상태를 URL에 반영하고 싶은 경우가 많습니다. 예를 들어, 사용자가 상품 목록에서 카테고리를 선택하고 가격 범위를 설정했을 때, 이 정보가 URL에 반영되어 페이지를 새로고침하거나 다른 사람과 공유해도 동일한 필터 상태를 유지할 수 있어야 합니다.\n이런 요구사항을 해결하기 위해 React Hook Form과 URL 검색 파라미터를 양방향으로 동기화하는 useFormUrlSync 커스텀 훅을 소개합니다.\n주요 기능 1. 양방향 동기화 폼 → URL: 폼 값이 변경되면 자동으로 URL이 업데이트됩니다 URL → 폼: URL 파라미터가 변경되면 폼 상태도 자동으로 업데이트됩니다 2. 타입 안전성 URL 파라미터는 기본적으로 문자열이지만, 이 훅은 자동으로 적절한 타입으로 변환합니다:\n\u0026quot;true\u0026quot; → true (boolean) \u0026quot;false\u0026quot; → false (boolean) \u0026quot;42\u0026quot; → 42 (number) \u0026quot;hello\u0026quot; → \u0026quot;hello\u0026quot; (string) 3. 선택적 필드 제외 특정 필드를 URL 동기화에서 제외할 수 있습니다. 예를 들어, 비밀번호나 임시 상태 같은 민감한 정보는 URL에 노출되지 않도록 할 수 있습니다.\n4. 실시간 동기화 제어 sync 옵션으로 실시간 동기화를 활성화/비활성화할 수 있으며, 수동으로 동기화할 수 있는 syncToUrl 함수도 제공됩니다.\n사용 방법 기본 사용법 import { useFormUrlSync } from \u0026#39;./useFormUrlSync\u0026#39;; type FilterForm = { category: string; minPrice: number; maxPrice: number; inStock: boolean; }; function ProductFilter() { const form = useFormUrlSync\u0026lt;FilterForm\u0026gt;({ defaultValues: { category: \u0026#39;\u0026#39;, minPrice: 0, maxPrice: 1000, inStock: false, }, }); const { register, watch } = form; const values = watch(); return ( \u0026lt;form\u0026gt; \u0026lt;select {...register(\u0026#39;category\u0026#39;)}\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;전체 카테고리\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;electronics\u0026#34;\u0026gt;전자제품\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;clothing\u0026#34;\u0026gt;의류\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; {...register(\u0026#39;minPrice\u0026#39;, { valueAsNumber: true })} placeholder=\u0026#34;최소 가격\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; {...register(\u0026#39;maxPrice\u0026#39;, { valueAsNumber: true })} placeholder=\u0026#34;최대 가격\u0026#34; /\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; {...register(\u0026#39;inStock\u0026#39;)} /\u0026gt; 재고 있는 상품만 \u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt; ); } 옵션 상세 설명 excludeFromUrl 특정 필드를 URL 동기화에서 제외합니다:\nconst form = useFormUrlSync\u0026lt;FilterForm\u0026gt;({ defaultValues: { /* ... */ }, excludeFromUrl: [\u0026#39;password\u0026#39;, \u0026#39;temporaryState\u0026#39;], }); replace URL 변경 시 브라우저 히스토리 관리 방식을 결정합니다:\nconst form = useFormUrlSync\u0026lt;FilterForm\u0026gt;({ defaultValues: { /* ... */ }, replace: false, // push 사용 (기본값: true) }); sync 실시간 동기화 여부를 제어합니다:\nconst form = useFormUrlSync\u0026lt;FilterForm\u0026gt;({ defaultValues: { /* ... */ }, sync: false, // 실시간 동기화 비활성화 }); // 수동으로 동기화 const { syncToUrl } = form; const handleSubmit = () =\u0026gt; { syncToUrl(); }; 구현 상세 설명 1. URL 값 파싱 (parseUrlValue) function parseUrlValue(value: string): string | number | boolean { if (value === \u0026#34;\u0026#34;) return value; if (value === \u0026#34;true\u0026#34;) return true; if (value === \u0026#34;false\u0026#34;) return false; const numValue = Number(value); if (isNumber(numValue) \u0026amp;\u0026amp; !Number.isNaN(numValue)) { return numValue; } return value; } 이 함수는 URL의 문자열 파라미터를 적절한 타입으로 변환합니다. 문자열이 boolean이나 number로 변환 가능한지 확인하고, 그렇지 않으면 원본 문자열을 반환합니다.\n2. 초기값 추출 (extractInitialValuesFromUrl) function extractInitialValuesFromUrl\u0026lt;T extends FieldValues\u0026gt;( searchParams: URLSearchParams, excludeFromUrl: (keyof T)[], ): Partial\u0026lt;T\u0026gt; { const urlValues: Partial\u0026lt;T\u0026gt; = {}; for (const [key, value] of searchParams.entries()) { if (!excludeFromUrl.includes(key as keyof T)) { (urlValues as AliasAny)[key] = parseUrlValue(value); } } return urlValues; } 페이지 로드 시 URL에서 초기값을 추출하여 폼의 기본값과 병합합니다. excludeFromUrl에 포함된 필드는 제외됩니다.\n3. URL 파라미터 생성 (createUrlParamsFromValues) function createUrlParamsFromValues\u0026lt;T extends FieldValues\u0026gt;( values: T, currentParams: URLSearchParams, excludeFromUrl: (keyof T)[], ): URLSearchParams { const params = new URLSearchParams(currentParams); for (const [key, value] of Object.entries(values)) { if (excludeFromUrl.includes(key as keyof T)) { continue; } if (value !== undefined \u0026amp;\u0026amp; value !== null \u0026amp;\u0026amp; value !== \u0026#34;\u0026#34;) { params.set(key, String(value)); } else { params.delete(key); } } return params; } 폼 값들을 URL 파라미터로 변환합니다. 빈 값(undefined, null, \u0026quot;\u0026quot;)은 URL에서 제거되어 깔끔한 URL을 유지합니다.\n4. 무한 루프 방지 const isUpdatingFromUrl = useRef(false); useEffect(() =\u0026gt; { if (sync) { const subscription = watch(values =\u0026gt; { if (isUpdatingFromUrl.current) { return; } updateUrl(values as T); }); return () =\u0026gt; subscription.unsubscribe(); } }, [watch, updateUrl, sync]); useRef를 사용하여 URL 업데이트로 인한 폼 변경과 폼 변경으로 인한 URL 업데이트를 구분합니다. 이를 통해 무한 루프를 방지합니다.\n5. 깊은 비교 (deepEqual) function deepEqual(obj1: AliasAny, obj2: AliasAny): boolean { return JSON.stringify(obj1) === JSON.stringify(obj2); } 객체의 깊은 비교를 통해 실제로 값이 변경되었을 때만 폼을 업데이트하여 불필요한 렌더링을 방지합니다.\n실제 활용 예시 검색 필터 페이지 type SearchFilters = { query: string; category: string; sortBy: \u0026#39;price\u0026#39; | \u0026#39;name\u0026#39; | \u0026#39;date\u0026#39;; priceRange: [number, number]; isAvailable: boolean; }; function SearchPage() { const form = useFormUrlSync\u0026lt;SearchFilters\u0026gt;({ defaultValues: { query: \u0026#39;\u0026#39;, category: \u0026#39;\u0026#39;, sortBy: \u0026#39;name\u0026#39;, priceRange: [0, 1000], isAvailable: false, }, excludeFromUrl: [\u0026#39;priceRange\u0026#39;], // 복잡한 객체는 URL에서 제외 }); const { register, watch } = form; const filters = watch(); // 필터 변경 시 자동으로 URL 업데이트되고 // 검색 결과도 자동으로 업데이트됨 const { data: products } = useQuery({ queryKey: [\u0026#39;products\u0026#39;, filters], queryFn: () =\u0026gt; fetchProducts(filters), }); return ( \u0026lt;div\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input {...register(\u0026#39;query\u0026#39;)} placeholder=\u0026#34;검색어 입력\u0026#34; /\u0026gt; \u0026lt;select {...register(\u0026#39;category\u0026#39;)}\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;전체\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;electronics\u0026#34;\u0026gt;전자제품\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;books\u0026#34;\u0026gt;도서\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select {...register(\u0026#39;sortBy\u0026#39;)}\u0026gt; \u0026lt;option value=\u0026#34;name\u0026#34;\u0026gt;이름순\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;price\u0026#34;\u0026gt;가격순\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;date\u0026#34;\u0026gt;날짜순\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; {...register(\u0026#39;isAvailable\u0026#39;)} /\u0026gt; 구매 가능한 상품만 \u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;ProductList products={products} /\u0026gt; \u0026lt;/div\u0026gt; ); } 주의사항 및 한계 1. Next.js 클라이언트 컴포넌트 전용 이 훅은 Next.js의 useRouter와 useSearchParams를 사용하므로:\n클라이언트 컴포넌트에서만 동작합니다 컴포넌트 상단에 \u0026quot;use client\u0026quot; 지시어가 필요합니다 2. 복잡한 객체 타입 제한 URL 파라미터의 특성상 복잡한 객체나 배열은 직접 지원하지 않습니다. 이런 경우 excludeFromUrl 옵션을 사용하거나 별도의 직렬화 로직을 구현해야 합니다.\n3. 히스토리 관리 기본적으로 replace: true로 설정되어 있어 뒤로 가기 버튼으로 필터 변경 이력을 탐색할 수 없습니다. 필요에 따라 replace: false로 설정할 수 있습니다.\n4. 성능 고려사항 실시간 동기화가 활성화되어 있으면 모든 폼 변경이 URL 업데이트를 트리거합니다. 성능이 중요한 경우 sync: false로 설정하고 수동으로 동기화하는 것을 고려해보세요.\n마무리 useFormUrlSync 훅은 React Hook Form과 URL 상태를 간편하게 동기화할 수 있는 강력한 도구입니다. 특히 검색이나 필터 기능이 있는 페이지에서 사용자 경험을 크게 향상시킬 수 있습니다.\n주요 장점:\n공유 가능한 URL: 사용자가 설정한 필터 상태를 URL로 공유 가능 새로고침 안정성: 페이지 새로고침 후에도 설정 유지 타입 안전성: TypeScript를 통한 완전한 타입 지원 유연한 설정: 다양한 옵션으로 프로젝트 요구사항에 맞게 조정 가능 이 훅을 활용하여 더 나은 사용자 경험을 제공하는 웹 애플리케이션을 만들어보세요!\n","date":"2025-07-16","permalink":"/post/2025/2025-07-16-react-hook-form-sync-with-url-2/","section":"post","summary":"지난포스트에서는 Next.js 프로젝트를 진행하면서 유용하게 사용할 수 있는 자작 커스텀 훅, useFormUrlSync을 개선한 버전에 대해서 이야기 해 봅니다.\n","title":"Next.js에서 react-hook-form과 URL을 우아하게 동기화하는 법 2 🚀"},{"content":"이번 포스트에서는 Next.js 프로젝트를 진행하면서 유용하게 사용할 수 있는 자작 커스텀 훅, useFormUrlSync에 대해 이야기하고자 합니다.\n검색 필터나 정렬 기능이 있는 페이지를 개발할 때 이러한 경험이 있으실 겁니다. 사용자가 필터 값을 설정하고 검색 결과 페이지에서 특정 아이템을 클릭했다가 뒤로 가기 버튼을 누르면, 설정했던 필터 값들이 전부 초기화되는 상황 말입니다. 사용자 입장에서는 매우 불편한 순간이 아닐 수 없습니다.\n이러한 문제를 해결하는 가장 효과적인 방법은 폼(Form)의 상태를 URL 쿼리 파라미터(Query Parameter)에 실시간으로 동기화하는 것입니다. 이렇게 하면 사용자가 설정한 필터 값이 URL에 그대로 남아, 페이지를 새로고침하거나 링크를 공유해도 동일한 상태가 유지됩니다.\n이번 글에서는 이 기능을 구현하는 useFormUrlSync 커스텀 훅을 만들고, 사용법을 자세히 알아보겠습니다.\n왜 URL과의 동기화가 필요합니까? 🤔 본격적으로 코드를 살펴보기 전에, 왜 폼 상태를 URL과 동기화해야 하는지 짚고 넘어갈 필요가 있습니다.\n향상된 사용자 경험 (UX): 사용자가 뒤로 가기/앞으로 가기 버튼을 사용해도 필터링된 상태가 그대로 유지됩니다. 공유 가능한 링크: 필터나 검색 조건이 포함된 URL을 다른 사람에게 그대로 공유할 수 있습니다. 북마크 가능: 사용자는 특정 검색 결과 페이지를 북마크하고 나중에 다시 방문할 수 있습니다. 이 모든 것이 사소해 보일 수 있지만, 잘 만들어진 웹 애플리케이션의 디테일을 결정하는 중요한 요소입니다.\nuseFormUrlSync 전체 코드 훑어보기 🧐 먼저 우리가 만들 커스텀 훅의 전체 코드를 살펴보겠습니다. Next.js(App Router 기준) 환경과 react-hook-form 라이브러리를 사용한다는 점을 참고해 주시기 바랍니다.\nimport type { AliasAny } from \u0026#34;@/types/alias.types\u0026#34;; import { isNumber } from \u0026#34;es-toolkit/compat\u0026#34;; import { useRouter, useSearchParams } from \u0026#34;next/navigation\u0026#34;; import { useCallback, useEffect, useRef } from \u0026#34;react\u0026#34;; import { type DefaultValues, type FieldValues, type UseFormProps, type UseFormReturn, useForm } from \u0026#34;react-hook-form\u0026#34;; /** * useFormUrlSync 훅의 옵션 타입 * @template T - 폼 필드 값들의 타입 */ type UseFormUrlSyncOptions\u0026lt;T extends FieldValues\u0026gt; = Omit\u0026lt;UseFormProps\u0026lt;T\u0026gt;, \u0026#34;defaultValues\u0026#34;\u0026gt; \u0026amp; { /** URL 동기화에서 제외할 필드명들 */ excludeFromUrl?: (keyof T)[]; /** URL 변경 시 replace 사용 여부 (기본값: true) */ replace?: boolean; /** 폼의 기본값들 */ defaultValues: DefaultValues\u0026lt;T\u0026gt;; }; /** * URL 파라미터 값을 적절한 타입으로 파싱합니다. * @param value - 파싱할 문자열 값 * @returns 파싱된 값 (string | number | boolean) */ function parseUrlValue(value: string): string | number | boolean { if (value === \u0026#34;\u0026#34;) return value; if (value === \u0026#34;true\u0026#34;) return true; if (value === \u0026#34;false\u0026#34;) return false; const numValue = Number(value); if (isNumber(numValue) \u0026amp;\u0026amp; !Number.isNaN(numValue)) { return numValue; } return value; } /** * URL 검색 파라미터에서 초기값을 추출합니다. * @template T - 폼 필드 값들의 타입 * @param searchParams - URL 검색 파라미터 * @param excludeFromUrl - URL 동기화에서 제외할 필드명들 * @returns URL에서 추출한 초기값들 */ function extractInitialValuesFromUrl\u0026lt;T extends FieldValues\u0026gt;( searchParams: URLSearchParams, excludeFromUrl: (keyof T)[], ): Partial\u0026lt;T\u0026gt; { const urlValues: Partial\u0026lt;T\u0026gt; = {}; for (const [key, value] of searchParams.entries()) { if (!excludeFromUrl.includes(key as keyof T)) { (urlValues as AliasAny)[key] = parseUrlValue(value); } } return urlValues; } /** * 폼 값들로부터 URL 파라미터를 생성합니다. * @template T - 폼 필드 값들의 타입 * @param values - 폼 값들 * @param currentParams - 현재 URL 파라미터 * @param excludeFromUrl - URL 동기화에서 제외할 필드명들 * @returns 새로운 URLSearchParams 객체 */ function createUrlParamsFromValues\u0026lt;T extends FieldValues\u0026gt;( values: T, currentParams: URLSearchParams, excludeFromUrl: (keyof T)[], ): URLSearchParams { const params = new URLSearchParams(currentParams); for (const [key, value] of Object.entries(values)) { if (excludeFromUrl.includes(key as keyof T)) { continue; } if (value !== undefined \u0026amp;\u0026amp; value !== null \u0026amp;\u0026amp; value !== \u0026#34;\u0026#34;) { params.set(key, String(value)); } else { params.delete(key); } } return params; } /** * 두 객체의 깊은 비교를 수행합니다. * @param obj1 - 비교할 첫 번째 객체 * @param obj2 - 비교할 두 번째 객체 * @returns 객체들이 동일한지 여부 */ function deepEqual(obj1: AliasAny, obj2: AliasAny): boolean { return JSON.stringify(obj1) === JSON.stringify(obj2); } /** * React Hook Form과 URL 검색 파라미터를 양방향으로 동기화하는 커스텀 훅입니다. * * @template T - 폼 필드 값들의 타입, FieldValues를 확장해야 함 * @param options - 훅 설정 옵션 * @returns React Hook Form의 UseFormReturn 객체 * * @remarks * URL 파라미터는 자동으로 적절한 타입(string, number, boolean)으로 파싱됩니다. * 빈 문자열, null, undefined 값은 URL에서 제거됩니다. * Next.js의 useRouter와 useSearchParams를 사용하므로 Next.js 환경에서만 동작합니다. */ export function useFormUrlSync\u0026lt;T extends FieldValues\u0026gt;(options: UseFormUrlSyncOptions\u0026lt;T\u0026gt;): UseFormReturn\u0026lt;T\u0026gt; { const router = useRouter(); const searchParams = useSearchParams(); const { excludeFromUrl = [], replace = true, defaultValues, ...formOptions } = options; const isUpdatingFromUrl = useRef(false); const getUrlValues = useCallback(() =\u0026gt; { return extractInitialValuesFromUrl\u0026lt;T\u0026gt;(searchParams, excludeFromUrl as (keyof T)[]); }, [searchParams, excludeFromUrl]); const initialValues = { ...defaultValues, ...getUrlValues(), } as DefaultValues\u0026lt;T\u0026gt;; const form = useForm({ ...formOptions, defaultValues: initialValues, }); const { watch, reset, getValues } = form; const updateUrl = useCallback( (values: T) =\u0026gt; { const params = createUrlParamsFromValues(values, searchParams, excludeFromUrl as (keyof T)[]); const newSearchString = params.toString(); const currentSearchString = new URLSearchParams(window.location.search).toString(); if (newSearchString !== currentSearchString) { const newUrl = `${window.location.pathname}?${newSearchString}`; if (replace) { router.replace(newUrl, { scroll: false }); } else { router.push(newUrl, { scroll: false }); } } }, [router, searchParams, excludeFromUrl, replace], ); useEffect(() =\u0026gt; { const subscription = watch(values =\u0026gt; { if (isUpdatingFromUrl.current) { return; } updateUrl(values as T); }); return () =\u0026gt; subscription.unsubscribe(); }, [watch, updateUrl]); useEffect(() =\u0026gt; { const urlValues = getUrlValues(); const currentFormValues = getValues(); const relevantFormValues: Partial\u0026lt;T\u0026gt; = {}; for (const key in urlValues) { if (Object.prototype.hasOwnProperty.call(urlValues, key)) { relevantFormValues[key as keyof T] = currentFormValues[key as keyof T]; } } if (!deepEqual(urlValues, relevantFormValues)) { isUpdatingFromUrl.current = true; reset({ ...currentFormValues, ...urlValues, } as DefaultValues\u0026lt;T\u0026gt;); setTimeout(() =\u0026gt; { isUpdatingFromUrl.current = false; }, 0); } }, [getUrlValues, reset, getValues]); return form; } 코드가 다소 길어 보일 수 있지만, 핵심 로직은 간단합니다. 이제부터 하나씩 분석해 보겠습니다.\n핵심 로직 파헤치기 💡 이 훅은 양방향 동기화를 구현하는 것이 핵심입니다.\n폼 상태 변경 → URL 업데이트 URL 변경 (예: 뒤로 가기) → 폼 상태 업데이트 이 두 가지 흐름이 어떻게 구현되었는지 살펴보겠습니다.\n1. 폼 변경 → URL 업데이트 이 부분은 react-hook-form의 watch 함수와 useEffect를 사용하여 구현합니다.\n// ... useEffect(() =\u0026gt; { const subscription = watch(values =\u0026gt; { // isUpdatingFromUrl 플래그에 대해서는 잠시 후에 설명하겠습니다. if (isUpdatingFromUrl.current) { return; } updateUrl(values as T); // 폼 값이 변경되면 URL을 업데이트하는 함수 호출 }); return () =\u0026gt; subscription.unsubscribe(); }, [watch, updateUrl]); // ... watch는 폼의 모든 값 변경을 감지하는 구독(subscription)을 생성합니다. 값이 바뀔 때마다 updateUrl 함수를 호출하여 변경된 값을 URL 쿼리 파라미터로 만들어줍니다.\n2. URL 변경 → 폼 상태 업데이트 이것은 사용자가 브라우저의 뒤로 가기/앞으로 가기 버튼을 눌렀을 때를 위한 기능입니다. useSearchParams 훅이 URL의 변경을 감지하면, useEffect가 실행됩니다.\n// ... useEffect(() =\u0026gt; { const urlValues = getUrlValues(); // URL에서 현재 폼 관련 값들을 가져옴 const currentFormValues = getValues(); // react-hook-form의 현재 값들을 가져옴 // ... (비교 로직) ... // URL의 값과 폼의 값이 다를 경우 if (!deepEqual(urlValues, relevantFormValues)) { isUpdatingFromUrl.current = true; // 무한 루프 방지 플래그 ON // URL 값으로 폼 상태를 리셋(업데이트) reset({ ...currentFormValues, ...urlValues, } as DefaultValues\u0026lt;T\u0026gt;); // 아주 잠깐의 딜레이 후 플래그 OFF setTimeout(() =\u0026gt; { isUpdatingFromUrl.current = false; }, 0); } }, [getUrlValues, reset, getValues]); // URL이 변경될 때마다 실행 URL이 바뀌면 searchParams 객체가 변경되고, 이를 의존하는 getUrlValues가 새로운 값을 반환하면서 이 useEffect가 다시 실행됩니다. 그리고 URL에서 가져온 값(urlValues)과 현재 폼의 값(currentFormValues)을 비교해서, 다르다면 form.reset을 호출하여 폼을 업데이트해줍니다.\n3. 무한 루프 방지: isUpdatingFromUrl ⚠️ 여기서 매우 중요한 부분은 바로 isUpdatingFromUrl이라는 useRef 값입니다. 이것이 왜 필요합니까?\n만약 이 플래그가 없다면 다음과 같은 무한 루프에 빠질 수 있습니다.\nURL 변경 → useEffect 실행 → form.reset() 호출 (폼 업데이트) 폼 업데이트 → watch 감지 → updateUrl() 호출 (URL 업데이트) URL 업데이트 → useEffect 실행 → form.reset() 호출 (폼 업데이트) \u0026hellip; 무한 반복 \u0026hellip; isUpdatingFromUrl.current = true는 \u0026ldquo;지금은 URL 변경 때문에 폼을 강제로 업데이트하는 중이니, watch는 잠시 반응하지 말라\u0026quot;고 알려주는 신호탄과 같습니다. 폼을 reset 한 직후 setTimeout으로 플래그를 다시 false로 바꿔서, 그 이후의 사용자 입력에는 정상적으로 반응하도록 만듭니다. 매우 효율적인 방법입니다.\n실제로 사용해보기 📝 이제 이 훅을 실제 컴포넌트에서 어떻게 사용하는지 살펴보겠습니다. 간단한 검색 폼을 예시로 들어보겠습니다.\n// components/SearchForm.tsx \u0026#34;use client\u0026#34;; import { useFormUrlSync } from \u0026#34;@/hooks/useFormUrlSync\u0026#34;; // 우리가 만든 훅 interface SearchFormValues { keyword: string; category: string; inStockOnly: boolean; page: number; } export function SearchForm() { const { register, handleSubmit, formState: { errors } } = useFormUrlSync\u0026lt;SearchFormValues\u0026gt;({ // 폼의 기본값 설정 defaultValues: { keyword: \u0026#34;\u0026#34;, category: \u0026#34;all\u0026#34;, inStockOnly: false, page: 1, }, // URL에 포함시키고 싶지 않은 필드 excludeFromUrl: [\u0026#34;page\u0026#34;], // URL 변경 시 히스토리를 남기고 싶을 때 replace: false, }); const onSubmit = (data: SearchFormValues) =\u0026gt; { // 실제 검색 로직 수행 console.log(\u0026#34;검색 실행:\u0026#34;, data); }; return ( \u0026lt;form onSubmit={handleSubmit(onSubmit)} className=\u0026#34;space-y-4\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;keyword\u0026#34;\u0026gt;검색어\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;keyword\u0026#34; {...register(\u0026#34;keyword\u0026#34;)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;category\u0026#34;\u0026gt;카테고리\u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;category\u0026#34; {...register(\u0026#34;category\u0026#34;)}\u0026gt; \u0026lt;option value=\u0026#34;all\u0026#34;\u0026gt;전체\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;electronics\u0026#34;\u0026gt;전자기기\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;books\u0026#34;\u0026gt;도서\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;inStockOnly\u0026#34; {...register(\u0026#34;inStockOnly\u0026#34;)} /\u0026gt; \u0026lt;label htmlFor=\u0026#34;inStockOnly\u0026#34;\u0026gt;재고 있음\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;검색\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); } 사용법은 기존 react-hook-form의 useForm과 거의 동일합니다. 단순히 useForm 대신 useFormUrlSync를 쓰고, 몇 가지 옵션만 추가하면 됩니다.\n📌 팁: replace 옵션은 언제 사용합니까?\nuseFormUrlSync 훅의 replace 옵션은 URL을 업데이트할 때 Next.js의 router.replace()를 쓸지, router.push()를 쓸지 결정하는 중요한 키입니다.\n✅ replace: true (기본값)\n사용 시나리오: 실시간으로 변하는 필터 값(체크박스, 검색어 입력 등)에 적합합니다. 장점: router.replace()는 브라우저의 히스토리 스택에 새 기록을 추가하지 않고 현재 URL을 대체합니다. 만약 사용자가 검색어를 한 글자씩 입력할 때마다 히스토리가 쌓인다면, 뒤로 가기 버튼을 누를 때마다 한 글자씩 지워지는 불편한 경험을 하게 될 것입니다. replace는 이런 불필요한 히스토리를 방지합니다. ❌ replace: false\n사용 시나리오: 사용자의 명시적인 액션(예: \u0026lsquo;검색\u0026rsquo; 버튼 클릭, \u0026lsquo;다음 페이지\u0026rsquo; 버튼 클릭)으로 URL이 변경될 때 적합합니다. 장점: router.push()는 브라우저 히스토리 스택에 새 기록을 추가합니다. 예를 들어, \u0026lsquo;검색 조건 A\u0026rsquo;로 검색했다가 \u0026lsquo;검색 조건 B\u0026rsquo;로 다시 검색했을 때, 사용자는 뒤로 가기 버튼을 눌러 \u0026lsquo;검색 조건 A\u0026rsquo;의 결과로 돌아가고 싶을 수 있습니다. 이때 replace: false (즉, router.push)를 사용하면 자연스러운 브라우저 탐색 경험을 제공할 수 있습니다. 이 옵션을 통해 우리는 사용자의 행동 의도에 맞는 최적의 URL 업데이트 방식을 선택할 수 있습니다.\n이제 이 폼에 값을 입력하면, URL이 실시간으로 변하고 브라우저 히스토리에도 차곡차곡 쌓이는 것을 볼 수 있습니다.\nhttp://localhost:3000/search?keyword=Next.js\u0026amp;category=books\u0026amp;inStockOnly=true\n마무리하며 이번 글에서는 Next.js 환경에서 react-hook-form의 상태를 URL 쿼리 파라미터와 동기화하는 useFormUrlSync 커스텀 훅에 대해 알아보았습니다.\n이 훅 하나만 잘 만들어두면, 앞으로 필터나 검색 기능이 필요한 모든 페이지에서 사용자 경험을 크게 향상시킬 수 있을 것입니다. 상태 유지를 위해 더 이상 복잡한 전역 상태 관리 라이브러리에 의존할 필요가 없습니다.\n독자 여러분께서는 프로젝트에서 폼 상태를 어떻게 관리하고 계십니까? 더 좋은 아이디어나 방법이 있다면 댓글을 통해 공유해 주시기 바랍니다. 😊\n","date":"2025-06-13","permalink":"/post/2025/2025-06-13-react-hook-form-sync-with-url/","section":"post","summary":"이번 포스트에서는 Next.js 프로젝트를 진행하면서 유용하게 사용할 수 있는 자작 커스텀 훅, useFormUrlSync에 대해 이야기하고자 합니다.\n","title":"Next.js에서 react-hook-form과 URL을 우아하게 동기화하는 법 🚀"},{"content":"Obsidian을 쓰다 보면, 쫍은 편집창의 폭 때문에 불편 할 수 있습니다.\n편집창의 넓이를 방법을 소개 합니다.\nObsidian의 설정 → 외관 → CSS 스니펫에서 커스텀 CSS를 추가하여 편집창의 넓이를 조절할 수 있습니다.\ncss 파일의 이름은 원하는 이름으로 설정 후, 아래와 같이 입력 해 줍니다.\n.markdown-source-view { --file-line-width: 900px; /* 기본값은 보통 700px 정도입니다 */ } /* 또는 전체 콘텐츠 영역의 최대 너비를 설정할 수도 있습니다 */ .markdown-preview-view { --file-line-width: 900px; } 이 값을 더 크게 설정하면 편집창의 넓이가 더 넓어집니다.\n편집을 완료 하면, css 파일이 목록에 나옵니다. 옆에 체크 박스를 켜주면, css가 적용 됩니다\n","date":"2025-05-06","permalink":"/post/2025/2025-05-06-obsidian-editor-width/","section":"post","summary":"Obsidian을 쓰다 보면, 쫍은 편집창의 폭 때문에 불편 할 수 있습니다.\n","title":"옵시디언에서 편집창 폭 넓히기"},{"content":"UV는 현대적이고 고성능 파이썬 패키지 관리자이며 Rust로 작성된 설치 프로그램입니다. PIP과 같은 전통적인 Python 패키지 관리 도구의 드롭 인 교체 역할을하며 속도, 신뢰성 및 종속성 해상도가 크게 향상됩니다.\n1. uv의 등장 배경: 왜 새로운 도구가 필요했나? 1.1. 기존 도구들의 한계 pip의 속도 문제: 대규모 패키지 설치 시 10분 이상 소요되는 경우 빈번(uv는 동일 작업을 10초 내 완료) 환경 관리의 복잡성: venv + pip + pip-tools + virtualenvwrapper 조합 필요 의존성 해결 충돌: 복잡한 의존성 그래프에서 종종 ResolutionError 발생 멀티플랫폼 지원 부족: Windows 환경에서의 성능 저하 문제 1.2. Astral팀의 접근 방식 Rust 기반 구현: 메모리 안정성과 네이티브 성능 확보 병렬 처리 최적화: 의존성 해결과 패키지 다운로드를 동시 진행 유니버설 바이너리: 별도 Python 설치 없이 독립 실행 가능 1.3. 성능 벤치마크 (Django 프로젝트 기준) 작업 pip poetry uv 초기 설치 142s 98s 12s 재설치 89s 64s 0.8s 잠금파일 생성 32s 28s 3s 2. 설치 방법 uv는 다양한 방법으로 설치할 수 있습니다. 아래는 OS별 설치 방법과 pip를 사용하는 방법입니다.\n2.1. Windows Windows에서 uv를 설치하려면 PowerShell을 사용합니다:\n❯ powershell -ExecutionPolicy ByPass -c \u0026#34;irm https://astral.sh/uv/install.ps1 | iex\u0026#34; 2.2. macOS/Linux macOS 또는 Linux에서는 다음 명령어를 사용하여 설치할 수 있습니다:\n❯ curl -LsSf https://astral.sh/uv/install.sh | sh 2.3. pip를 사용한 설치 Python의 pip를 사용하여 설치할 수도 있습니다:\n❯ pip install uv 설치 후 uv 명령어가 제대로 작동하는지 확인하려면 다음 명령어를 실행하세요:\n❯ uv --version 개인적으로는 python을 설치 하고 pip로 uv를 설치하는 것을 추천 합니다. vscode에서 Jupter Notebook 같이 자동으로 pip를 통해서 설치하는 경우가 있는데. python의 pip를 통하면 편하게 설치가 됩니다.\n3. 셀 통합 설정 uv는 다양한 셸 환경에서 자동 완성 및 편리한 명령어 사용을 지원합니다. 아래는 OS별 셸 통합 설정 방법입니다.\n3.1. Windows (PowerShell) PowerShell에서 uv 자동 완성을 설정하려면 다음 명령어를 실행하세요:\n❯ mkdir -Force $PROFILE.CurrentUserAllHosts ❯ uv generate-completion powershell \u0026gt; $PROFILE.CurrentUserAllHosts\\uv.ps1 PowerShell을 다시 시작하면 자동 완성이 활성화됩니다.\n3.2. macOS/Linux (Zsh) Zsh에서 uv 자동 완성을 설정하려면 다음 명령어를 실행하세요:\n❯ mkdir -p ~/.zsh/completions ❯ uv generate-completion zsh \u0026gt; ~/.zsh/completions/_uv 그런 다음 ~/.zshrc 파일에 다음 줄을 추가합니다:\nfpath=(~/.zsh/completions $fpath) autoload -U compinit \u0026amp;\u0026amp; compinit Zsh를 다시 시작하거나 source ~/.zshrc를 실행하여 설정을 적용합니다.\n3.3. macOS/Linux (Bash) Bash에서 uv 자동 완성을 설정하려면 다음 명령어를 실행하세요:\n❯ mkdir -p ~/.bash_completion.d ❯ uv --generate-completion bash \u0026gt; ~/.bash_completion.d/uv 그런 다음 ~/.bashrc 파일에 다음 줄을 추가합니다:\nif [ -f ~/.bash_completion.d/uv ]; then . ~/.bash_completion.d/uv fi Bash를 다시 시작하거나 source ~/.bashrc를 실행하여 설정을 적용합니다.\n4. 패키지 관리 하기 4.1. 파이썬 버전 설치하기 특정 Python 버전을 설치하거나 변경하려면 다음을 실행하세요:\n❯ uv python install 3.12.10 설치된 Python 버전을 확인하려면:\n❯ uv python list 현재 폴더에 가상환경 폴더를 설치 하려면 아래와 같이 합니다.\n❯ uv venv --python 3.12.10 Using CPython 3.12.10 Creating virtual environment at: .venv Activate with: source .venv/Scripts/activate 이렇게 하면 현재 폴더에 .venv폴더가 생성 되고 python 가상 환경 설정이 들어 갑니다.\n4.2. 프로젝트 생성하기 가상 환경을 설정 하려면 아래와 같이 init 명령를 통해서 프로젝트 초기 설정을 할 수 있습니다.\n❯ uv init uv-project ❯ cd uv-project ❯ uv venv ❯ source .venv/Scripts/activate uv-project 폴더가 생성되고, 내부 구조는 대략 다음과 같습니다:\n❯ tree -a . ├── .python-version ├── .gitignore ├── .venv ├── pyproject.toml ├── hello.py └── README.md .python-version을 통해 파이썬 버전이 고정됩니다 pyproject.toml 은 의존성 및 프로젝트 메타데이터를 정의하는 핵심 파일입니다. .venv 폴더는 아직 보이지 않을 수 있는데, 의존성을 추가하면 자동으로 생성됩니다. 혹시 현재 폴더에 아래와 같이 설정 하시면 됩니다.\n❯ uv init ❯ uv venv ❯ source .venv/Scripts/activate 5. 패키지 관리 5.1. 기존 uv로 설치된 프로젝트 설정 하기 자동화 환경에서 uv sync만으로 프로젝트에 필요한 Python 버전과 .venv 가 자동으로 맞춰집니다.\n❯ uv sync 5.2. 패키지 설치 하기 uv add로 패키지를 설치 할 수 있습니다. 한번에 여러개의 패키지를 설치 하려면 뒤에 붙여서 패키지명을 적어 주면 됩니다.\n❯ uv add scipy six Resolved 4 packages in 152ms Prepared 3 packages in 1.50s ░░░░░░░░░░░░░░░░░░░░ [0/3] Installing Installed 3 packages in 527ms + numpy==2.2.4 + scipy==1.15.2 + six==1.17.0 설치가 완료 되면 pyproject.toml파일을 확인 해 보면 설치된 패키지가 기록 된 것을 확인 할 수 있습니다.\n❯ cat pyproject.toml [project] name = \u0026#34;uv\u0026#34; version = \u0026#34;0.1.0\u0026#34; description = \u0026#34;Add your description here\u0026#34; readme = \u0026#34;README.md\u0026#34; requires-python = \u0026#34;\u0026gt;=3.12\u0026#34; dependencies = [ \u0026#34;scipy\u0026gt;=1.15.2\u0026#34;, \u0026#34;six\u0026gt;=1.17.0\u0026#34;, ] 5.3. 기존 requirements.txt 파일에서 설치 하기 기존 python 프로젝트 라면 requirements.txt 파일이 있을 겁니다. 그 파일을 기준으로 패키지를 설치 하려면 아래와 같이 사용 하시면 됩니다.\n❯ uv add -r requirements.txt 혹시, 다른 uv 사용자가 아닌 분을 배려 해서 requirements.txt 파일을 만들고 싶다면 uv pip 명령어를 통해서 파일을 만들 수도 있습니다\n❯ uv pip freeze \u0026gt; requirements.txt 5.4. 패키지 삭제 하기 환경과 pyproject.toml 파일에서 의존성을 제거하려면 uv remove 명령어를 사용할 수 있습니다. 이 명령어는 해당 패키지와 그 하위 의존성들을 모두 제거합니다:\n❯ uv remove scikit-learn 6. 스크립트 실행하기 필요한 의존성을 설치한 후에는 평소처럼 Python 스크립트 작업을 시작할 수 있습니다. UV는 Python 코드를 실행하는 몇 가지 다른 방법을 제공합니다:\nPython 스크립트를 직접 실행하려면 일반적인 python script.py 구문 대신 uv run 명령 다음에 스크립트 이름을 사용하면 됩니다:\n❯ uv run hello.py run 명령은 스크립트가 프로젝트를 위해 UV가 생성한 가상 환경 내에서 실행되도록 보장합니다.\n7. UV에서 잠금 파일이란 무엇입니까? 잠금 파일(uv.lock)은 UV의 종속성 관리에서 필수적인 부분입니다. 종속성을 설치하기 위해 uv add 명령을 실행하면 UV가 uv.lock 파일을 생성하고 업데이트합니다. 이 잠금 파일은 다음과 같은 몇 가지 중요한 용도로 사용됩니다.\n설치된 모든 종속성과 하위 종속성의 정확한 버전을 기록합니다. 서로 다른 환경에서 종속성 버전을 \u0026ldquo;잠금\u0026quot;하여 재현 가능한 빌드를 보장합니다. 일관된 패키지 버전을 유지 관리하여 \u0026ldquo;종속성 지옥\u0026quot;을 방지하는 데 도움이 됩니다. UV가 종속성을 다시 해결하는 대신 잠긴 버전을 사용할 수 있으므로 설치 속도가 빨라집니다. UV는 잠금 파일을 자동으로 관리하므로 수동으로 편집할 필요가 없습니다. 잠금 파일은 모든 개발자가 동일한 종속성 버전을 사용할 수 있도록 버전 제어에 커밋되어야 합니다.\n잠금 파일과 requirements.txt의 차이점 잠금 파일과 requirements.txt은 모두 종속성을 추적하는 역할을 하지만 고유한 목적과 사용 사례가 있습니다. 잠금 파일에는 정확한 패키지 버전과 전체 종속성 트리에 대한 자세한 정보가 포함되어 있어 개발 전반에 걸쳐 일관된 환경을 보장합니다. Requirements.txt 파일은 더 간단하고, 일반적으로 직접 종속성만 나열하며, Python 도구에서 널리 지원됩니다.\n잠금 파일은 재현 가능한 빌드를 유지 관리하고 종속성 충돌을 방지하기 위해 개발에 필수적입니다. Requirements.txt 파일은 배포 시나리오 또는 UV를 사용하지 않을 수 있는 사용자와 코드를 공유할 때 더 적합합니다. 또한 UV의 잠금 파일 형식을 지원하지 않는 도구 및 서비스와의 호환성을 위해 필요합니다.\n배포를 위한 requirements.txt 생성하는 동안 개발용 UV의 잠금 파일을 사용하여 두 파일을 모두 유지 관리할 수 있습니다. UV 잠금 파일에서 requirements.txt 생성하려면 다음 명령을 사용합니다.\n❯ uv export -o requirements.txt 이렇게 하면 잠금 파일을 기반으로 고정된 버전이 있는 텍스트 파일이 생성되므로 프로젝트의 종속성을 표준 형식으로 쉽게 공유하면서 개발 중에 UV의 고급 종속성 관리의 이점을 계속 활용할 수 있습니다.\n","date":"2025-04-14","permalink":"/post/2025/2025-04-14-python-uv-package-manager/","section":"post","summary":"UV는 현대적이고 고성능 파이썬 패키지 관리자이며 Rust로 작성된 설치 프로그램입니다. PIP과 같은 전통적인 Python 패키지 관리 도구의 드롭 인 교체 역할을하며 속도, 신뢰성 및 종속성 해상도가 크게 향상됩니다.\n","title":"Python의 uv 패키지 매니저"},{"content":"윈도우 환경에서 개발을 하다보면 터미널의 기능이 제한적이라는 것을 느끼게 됩니다. 이럴 때 git-bash와 zsh를 함께 사용하면 더 강력한 터미널 환경을 구축할 수 있습니다. 이 글에서는 윈도우 git-bash에서 zsh를 설치하고 설정하는 방법을 알아보겠습니다.\n1. Git Bash 설치 먼저 Git Bash를 설치해야 합니다. Git for Windows에서 최신 버전을 다운로드하여 설치합니다.\n2. ZSH 설치 2.1 Nerd Font 설치 ZSH를 사용하기 전에 먼저 Nerd Font를 설치해야 합니다. Nerd Fonts에서 원하는 폰트를 다운로드하여 설치합니다. 이 글에서는 D2CodingLigature Nerd Font를 사용합니다.\nD2CodingLigature Nerd Font Download 2.2 ZSH 패키지 다운로드 MSYS2 패키지 저장소에서 최신 zsh 패키지를 다운로드합니다. 패키지는 .zst 형식으로 압축되어 있으므로, PeaZip과 같은 압축 해제 프로그램이 필요합니다.\n2.3 ZSH 설치 다운로드한 패키지의 내용을 Git Bash 설치 디렉토리(기본값: C:\\Program Files\\Git)에 압축 해제합니다.\n2.4 ZSH 테스트 및 초기 설정 Git Bash를 열고 다음 명령어를 실행합니다:\nzsh 이 단계에서 zsh는 몇 가지 초기 설정을 물어봅니다. 탭 완성, 히스토리 등의 설정을 원하는 대로 구성하면 됩니다.\n2.5 터미널 설정 ~/.minttyrc 파일을 생성하고 다음 내용을 추가합니다:\nBoldAsFont=no Font=D2CodingLigature Nerd Font FontHeight=14 Columns=180 Rows=46 ScrollbackLines=2000 BackgroundColour=13,13,13 MiddleClickAction=void RightClickAction=paste Language= BellType=0 BellFlash=no Printer=Microsoft Print to PDF Transparency=off CursorBlinks=yes ThemeFile=nord ForegroundColour=178,178,178 CursorColour=225,225,225 FontSmoothing=full Locale=en_US Charset=UTF-8 Term=xterm-256color BoldAsColour=no CursorType=block 이렇게 설정 하면 git-bash의 터미널 창이 이뻐 집니다.\n3. ZSH 설정 3.1 ZSH를 기본 셸로 설정 /etc/zsh/zshenv 파일을 편집하여 다음 줄을 파일 시작 부분에 추가합니다:\nPATH=/mingw64/bin/usr/bin:/usr/bin:/bin:$PATH 3.2 Git Bash에서 ZSH 자동 실행 설정 ~/.bashrc 파일을 생성하고 다음 내용을 추가합니다:\n# Launch Zsh if [ -t 1 ]; then exec zsh fi 이제 git-bash를 실행 합니다.\n4. ZSH 유틸 설치 oh-my-zsh를 설치 하면 편하긴 한데. oh-my-zsh가 기본적으로 너무 많은 기능을 가지고 있어서 많이 무겁다는 단점있습니다. 이 포스트에서는 필요한 유틸만 별도로 설치 합니다.\n4.1 설치 경로 만들기 mkdir -p ~/.zsh/plugins mkdir -p ~/.zsh/theme 4.2 zsh-autosuggestions 설치 zsh-autosuggestions는 명령어를 입력할 때 이전에 사용한 명령어를 기반으로 자동 완성을 제안해주는 플러그인입니다. 터미널에서 작업할 때 반복적인 명령어 입력을 크게 줄여주고, 긴 경로나 복잡한 명령어를 쉽게 재사용할 수 있게 해줍니다. 제안된 명령어는 회색으로 표시되며, 오른쪽 화살표 키를 눌러 빠르게 수락할 수 있습니다.\ngit clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/plugins/zsh-autosuggestions ~/.zshrc 파일에 아래의 내용을 추가 해 줍니다. 마지막에 추가 해 줍니다.\nif [[ -r \u0026#34;~/.zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\u0026#34; ]]; then source \u0026#34;~/.zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\u0026#34; fi 4.3 zsh-syntax-highlighting 설치 zsh-syntax-highlighting은 명령줄에서 입력하는 명령어와 인자에 구문 강조 색상을 적용해주는 ZSH 플러그인입니다. 이 플러그인은 명령어가 올바르게 입력되었는지 실시간으로 시각적 피드백을 제공하며, 명령어를 실행하기 전에 오타나 구문 오류를 식별하는 데 도움을 줍니다. 유효한 명령어는 녹색으로, 존재하지 않는 명령어는 빨간색으로 표시되어 명령어 입력의 정확성을 즉시 확인할 수 있습니다.\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.zsh/plugins/zsh-syntax-highlighting ~/.zshrc 파일에 아래의 내용을 추가해 줍니다. 이 플러그인은 항상 zshrc 파일의 마지막에 로드되어야 한다는 점을 기억하세요. ~/.zshrc 파일에 아래의 내용을 추가 해 줍니다. 마지막에 추가 해 줍니다.\nif [[ -r \u0026#34;~/.zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\u0026#34; ]]; then source \u0026#34;~/.zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\u0026#34; fi 4.4 zsh-completions 설치 zsh-completions은 ZSH의 기본 명령어 완성 기능을 대폭 확장해주는 플러그인입니다. 이 플러그인은 수백 개의 추가 명령어, 도구 및 유틸리티에 대한 완성 스크립트를 제공하여 명령어 입력의 효율성과 정확성을 높여줍니다. Git, Docker, npm, pip, kubectl 등과 같은 다양한 개발 도구에 대한 고급 탭 완성 기능을 제공하므로 복잡한 명령어나 옵션을 기억하지 않아도 쉽게 입력할 수 있습니다.\ngit clone https://github.com/zsh-users/zsh-completions.git ~/.zsh/plugins/zsh-completions ~/.zshrc 파일에 아래의 내용을 추가해 줍니다.\nif [[ -d ~/.zsh/plugins/zsh-completions/src ]]; then fpath=(~/.zsh/plugins/zsh-completions/src $fpath) autoload -U compinit \u0026amp;\u0026amp; compinit fi 이 설정은 zsh-completions의 완성 스크립트를 ZSH의 함수 경로(fpath)에 추가하고, 완성 시스템(compinit)을 초기화합니다.\n6. Powerlevel10k 테마 설치 6.1 Powerlevel10k 설치 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/.zsh/theme/powerlevel10k echo \u0026#39;source ~/.zsh/theme/powerlevel10k/powerlevel10k.zsh-theme\u0026#39; \u0026gt;\u0026gt; ~/.zshrc git-bash를 다시 시작 하면 Powerlevel10k의 설정이 시작 됩니다.\n7. VS Code에서 ZSH 사용하기 VS Code의 settings.json 파일에 다음 설정을 추가합니다:\n\u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;Git Bash\u0026#34;, \u0026#34;terminal.integrated.fontFamily\u0026#34;: \u0026#34;\u0026#39;D2CodingLigature Nerd Font\u0026#39;\u0026#34; 8. Windows Terminal에서 ZSH 사용하기 Windows 10/11에서는 Windows Terminal을 통해 더 강력하고 사용자 친화적인 터미널 환경을 구성할 수 있습니다. Windows Terminal에 Git Bash(ZSH)를 추가하여 사용하는 방법은 두 가지가 있습니다.\n8.1 Git 설치 시 Windows Terminal 연동 옵션 선택 가장 간단한 방법은 Git for Windows를 설치할 때 Windows Terminal 프로필에 Git Bash를 추가하는 옵션을 선택하는 것입니다.\nGit for Windows 설치 프로그램을 실행합니다. 설치 과정 중 \u0026ldquo;Windows Terminal에 Git Bash 프로필 추가\u0026rdquo; 옵션을 체크합니다. 설치가 완료되면 Windows Terminal에서 Git Bash를 바로 사용할 수 있습니다. 8.2 수동으로 Windows Terminal에 Git Bash 추가하기 이미 Git이 설치되어 있다면, Windows Terminal 설정 파일을 직접 수정하여 Git Bash를 추가할 수 있습니다.\nWindows Terminal을 실행한 후, 상단의 드롭다운 메뉴 → 설정을 클릭합니다. 좌측 하단의 \u0026ldquo;설정 파일 열기\u0026rdquo; 버튼을 클릭하여 JSON 설정 파일을 엽니다. profiles → list 배열에 다음 코드를 추가합니다: { \u0026#34;guid\u0026#34;: \u0026#34;{수정필요-GUID}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Git Bash (ZSH)\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe -li\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;C:\\\\Program Files\\\\Git\\\\mingw64\\\\share\\\\git\\\\git-for-windows.ico\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;%USERPROFILE%\u0026#34; } guid 값은 고유해야 합니다. 온라인 GUID 생성기를 사용하여 새 GUID를 생성하세요. Git 설치 경로가 기본값과 다르다면 commandline과 icon 경로를 적절히 수정하세요. 설정 파일을 저장하고 Windows Terminal을 재시작합니다. 기본 Profile을 bash로 하고 싶다면, 설정 파일에서\n위에 입력 했던, profile의 id를 defaultProfile에 넣어 주면 된다.\n\u0026#34;defaultProfile\u0026#34;: \u0026#34;{수정필요-GUID}\u0026#34;, 이제 Windows Terminal의 드롭다운 메뉴에서 \u0026ldquo;Git Bash (ZSH)\u0026ldquo;를 선택하면 Git Bash가 실행되고, 우리가 설정한 ZSH 환경이 자동으로 로드됩니다.\n이제 윈도우에서도 강력한 ZSH 환경을 사용할 수 있습니다. Git Bash와 ZSH의 결합은 개발 생산성을 크게 향상시킬 수 있습니다.\n","date":"2025-04-13","permalink":"/post/2025/2025-04-13-windows-git-bash-use-zsh/","section":"post","summary":"윈도우 환경에서 개발을 하다보면 터미널의 기능이 제한적이라는 것을 느끼게 됩니다. 이럴 때 git-bash와 zsh를 함께 사용하면 더 강력한 터미널 환경을 구축할 수 있습니다. 이 글에서는 윈도우 git-bash에서 zsh를 설치하고 설정하는 방법을 알아보겠습니다.\n","title":"윈도우 git-bash에서 zsh 사용하기"},{"content":"SVG 아이콘 폴더를 모니터링하고 자동으로 index.ts 파일을 생성하는 Vite 플러그인입니다.\n이 플러그인은 웹사이트의 기능을 확장하고 관리 효율성을 높이기 위해 필요합니다. 사용자가 원하는 특정 기능들을 쉽게 추가할 수 있도록 도와주며, 설치 후에는 사용자 친화적인 인터페이스를 통해 간편하게 설정 및 활용할 수 있습니다. 특히 svgr을 사용하면 ?react가 붙은 URL을 일일이 import할 필요 없이 손쉽게 SVG 아이콘을 import할 수 있어 매우 유용합니다. 이러한 편리함 덕분에 개발자는 더욱 빠르고 효과적으로 사이트를 개발을 할 수 있습니다.\n설치. npm install vite-plugin-svgr vite-plugin-svgr-indexer --save-dev # 또는 yarn add vite-plugin-svgr vite-plugin-svgr-indexer -D # 또는 pnpm add vite-plugin-svgr vite-plugin-svgr-indexer -D 사용 방법 // vite.config.js / vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39;; import svgr from \u0026#39;vite-plugin-svgr\u0026#39;; import svgrIndexer from \u0026#39;vite-plugin-svgr-indexer\u0026#39;; export default defineConfig({ plugins: [ svgr(), // 먼저 vite-plugin-svgr 구성 svgrIndexer({ // 모니터링할 SVG 아이콘 디렉토리 경로 (필수) iconDirs: [\u0026#39;src/assets/icons\u0026#39;], // 생성할 인덱스 파일 이름 (기본값: \u0026#39;index.ts\u0026#39;) indexFileName: \u0026#39;index.ts\u0026#39;, // 파일 감시 활성화 (기본값: true) watch: true, // 하위 폴더 감시 활성화 (기본값: true) recursive: true, // 컴포넌트 이름에 추가할 접두사 (기본값: \u0026#39;\u0026#39;) componentPrefix: \u0026#39;Icon\u0026#39; }), ], }); TypeScript 지원 TypeScript를 사용하는 경우 tsconfig.json에 다음을 추가하세요:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;types\u0026#34;: [\u0026#34;vite-plugin-svgr/client\u0026#34;] } } 또는 더 나은 타입 추론을 위한 선언 도우미도 있습니다. vite-env.d.ts에 다음을 추가하세요:\n/// \u0026lt;reference types=\u0026#34;vite-plugin-svgr/client\u0026#34; /\u0026gt; 이렇게 하면 SVG 임포트에 대한 적절한 타입 정의가 제공됩니다.\n기능 지정된 디렉토리의 SVG 파일을 모니터링합니다. SVG 파일이 추가, 삭제 또는 수정될 때 자동으로 index.ts 파일을 생성합니다. 생성된 index.ts 파일은 모든 SVG 파일을 React 컴포넌트로 가져와서 내보냅니다. 각 하위 디렉토리에 대한 별도의 index.ts 파일을 생성하여 해당 디렉토리의 SVG 파일만 가져옵니다. 컴포넌트 이름에 접두사 추가를 지원합니다 (예: Icon 접두사: arrow.svg → IconArrow). 예시 SVG 파일 구조:\nsrc/assets/icons/ ├── arrow.svg ├── close.svg ├── menu.svg └── navigation/ ├── back.svg └── forward.svg 메인 디렉토리에 생성된 index.ts:\nimport IconArrow from \u0026#39;./arrow.svg?react\u0026#39;; import IconClose from \u0026#39;./close.svg?react\u0026#39;; import IconMenu from \u0026#39;./menu.svg?react\u0026#39;; export { IconArrow, IconClose, IconMenu }; navigation 하위 디렉토리에 생성된 index.ts:\nimport IconBack from \u0026#39;./back.svg?react\u0026#39;; import IconForward from \u0026#39;./forward.svg?react\u0026#39;; export { IconBack, IconForward }; React 컴포넌트에서의 사용법\n// 메인 디렉토리에서 가져오기 import { IconClose, IconMenu } from \u0026#39;./assets/icons\u0026#39;; // 하위 디렉토리에서 가져오기 import { IconBack } from \u0026#39;./assets/icons/navigation\u0026#39;; function App() { return ( \u0026lt;div\u0026gt; \u0026lt;IconClose /\u0026gt; \u0026lt;IconMenu /\u0026gt; \u0026lt;IconBack /\u0026gt; \u0026lt;/div\u0026gt; ); } ","date":"2025-02-28","permalink":"/post/2025/2025-02-28_vite-plugin-svgr-indexer/","section":"post","summary":"SVG 아이콘 폴더를 모니터링하고 자동으로 index.ts 파일을 생성하는 Vite 플러그인입니다.\n","title":"SVG 아이콘의 인덱스 파일을 생성하는 Vite 플러그인"},{"content":"이번 글에서는 Docker Compose를 사용하여 PostgreSQL Replication 환경을 구축하고, PgCat을 통한 Connection Pooling을 구현하는 방법을 알아보겠습니다.\n1. 프로젝트 구조 프로젝트는 다음과 같은 파일들로 구성되어 있습니다:\ndocker-compose.yml: 컨테이너 구성 정의 .env: 환경 변수 설정 config/pgcat.simple.toml: PgCat 설정 파일 2. 환경 변수 설정 (.env) 환경 변수를 통해 데이터베이스 접속 정보와 포트 설정을 관리합니다:\n# PostgreSQL 기본 설정 POSTGRESQL_USERNAME=postgres POSTGRESQL_DATABASE=postgres POSTGRESQL_PASSWORD=mysecretpassword # 복제 설정 POSTGRESQL_REPLICATION_USER=repl_user POSTGRESQL_REPLICATION_PASSWORD=repl_password # 포트 설정 PGCAT_PORT=6432 PG1_PORT=5433 PG2_PORT=5434 PG3_PORT=5435 3. PostgreSQL Replication 구성 Master 노드 (pg1) Primary 데이터베이스 서버로 동작 읽기/쓰기 작업 모두 수행 복제 모드: master POSTGRESQL_REPLICATION_MODE: master POSTGRESQL_REPLICATION_USER: ${POSTGRESQL_REPLICATION_USER} POSTGRESQL_REPLICATION_PASSWORD: ${POSTGRESQL_REPLICATION_PASSWORD} Replica 노드 (pg2, pg3) Secondary 데이터베이스 서버로 동작 읽기 전용 작업 수행 복제 모드: slave Master 노드의 데이터를 실시간으로 복제 POSTGRESQL_REPLICATION_MODE: slave POSTGRESQL_MASTER_HOST: pg1 POSTGRESQL_MASTER_PORT_NUMBER: 5432 4. PgCat을 통한 Connection Pooling PgCat은 PostgreSQL용 고성능 커넥션 풀러로, 다음과 같은 기능을 제공합니다:\n주요 설정 Transaction 단위의 커넥션 풀링 읽기/쓰기 쿼리 분리 로드 밸런싱 상태 모니터링 (Prometheus) [pools.postgres] pool_mode = \u0026#34;transaction\u0026#34; query_parser_enabled = true query_parser_read_write_splitting = true 서버 구성 Primary (pg1): 쓰기 작업 처리 Replica (pg2, pg3): 읽기 작업 처리 servers = [ [ \u0026#34;pg1\u0026#34;, 5432, \u0026#34;primary\u0026#34; ], [ \u0026#34;pg2\u0026#34;, 5432, \u0026#34;replica\u0026#34; ], [ \u0026#34;pg3\u0026#34;, 5432, \u0026#34;replica\u0026#34; ] ] 5. 시스템 아키텍처 클라이언트는 PgCat(6432)로 연결 PgCat이 쿼리 유형에 따라 적절한 서버로 라우팅 쓰기 쿼리 → Primary (pg1) 읽기 쿼리 → Replica (pg2, pg3) 6. 장점 고가용성\nMaster 노드 장애 시에도 Replica를 통한 읽기 작업 가능 데이터 복제를 통한 데이터 안정성 확보 성능 최적화\n읽기/쓰기 작업 분리로 부하 분산 Connection Pooling을 통한 데이터베이스 연결 효율화 확장성\n필요에 따라 Replica 노드 추가 가능 트래픽 증가에 유연하게 대응 마치며 이러한 구성을 통해 안정적이고 확장 가능한 PostgreSQL 환경을 구축할 수 있습니다. 실제 운영 환경에서는 모니터링과 백업 전략도 함께 고려해야 합니다.\n참고 구현 소스 PostgreSQL Replication Documentation PgCat GitHub Repository Docker Compose Documentation Bitnami PostgreSQL Docker Image ","date":"2025-01-17","permalink":"/post/2025/2025-01-17_postgresql-replication/","section":"post","summary":"이번 글에서는 Docker Compose를 사용하여 PostgreSQL Replication 환경을 구축하고, PgCat을 통한 Connection Pooling을 구현하는 방법을 알아보겠습니다.\n","title":"PostgreSQL Replication과 Connection Pooling 구현하기"},{"content":"웹 성능은 사용자 경험(UX)을 결정짓는 핵심 요소 중 하나입니다. 사용자가 페이지에서 다른 페이지로 이동할 때 추가적인 로딩 지연 없이 빠르게 전환할 수 있다면, 더 높은 만족도가 보장됩니다.\n구글 크롬을 중심으로 제안된 Speculation Rules는 브라우저가 사용자 행동을 예상하여 사전에 리소스를 로드해 두는 새로운 방식으로, 향상된 UX를 제공합니다.\n이번 글에서는 보다 자세하게 Speculation Rules의 개념과 활용 방법, 주의 사항 등을 단계별로 살펴보겠습니다.\n1. Speculation Rules란? Speculation Rules는 브라우저가 미래에 사용자가 페이지나 리소스를 요청할 가능성이 높다고 판단되는 경우, 해당 리소스를 미리 가져오거나(prefetch) 심지어 완전히 렌더링(prerender)하여 준비해 두는 기술입니다.\n대표적인 예로, 사용자가 A 페이지에서 B 페이지로 이동할 것이 거의 확실한 상황에서는 브라우저가 B 페이지를 사전에 로드해둡니다. 사용자가 실제로 B 페이지를 클릭하는 시점에는 이미 모든 데이터가 준비되어 있어, 즉시 표시가 가능합니다.\n기존 기법과 차이점 Resource Hint (prefetch, preload)\nHTML 같은 리소스 힌트(Resource Hint)는 요청을 미리 가져오도록 브라우저에 알리는 역할을 합니다. 다만, 개별 리소스 단위로 적용하고, 더 세밀한 제어는 어렵습니다.\nSpeculation Rules\nJSON 형태의 규칙 집합을 통해 브라우저가 보다 총체적(페이 로드 단위)인 관점에서 ‘이러이러한 상황에서 해당 페이지(혹은 리소스)를 미리 로드하라’고 명시합니다.\n자바스크립트와 DOM에서 얻은 정보를 기반으로 클릭 가능성 등을 종합적으로 분석하므로, 더 정교한 사전 로드가 가능합니다.\n2. \u0026lt;script type=\u0026ldquo;speculationrules\u0026rdquo;\u0026gt; 개요 Speculation Rules는 다음과 같은 형태로 작성합니다:\n\u0026lt;script type=\u0026#34;speculationrules\u0026#34;\u0026gt; { \u0026#34;prefetch\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;urls\u0026#34;: [ \u0026#34;/users\u0026#34;, \u0026#34;/info\u0026#34; ] } ], \u0026#34;prerender\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;urls\u0026#34;: [ \u0026#34;/main\u0026#34; ] } ] } \u0026lt;/script\u0026gt; type=\u0026quot;speculationrules\u0026quot;: JSON 형식의 규칙을 가진 스크립트 파일임을 브라우저에게 알림 prefetch: 브라우저가 리소스를 미리 가져오기만 하고, 렌더링은 하지 않음 prerender: 브라우저가 페이지를 뒤에서 완전히 렌더링까지 완료해 둠 JSON 구조 설명 prefetch: 해당 리소스를 미리 다운로드하여 네트워크 지연을 최소화 (렌더링은 하지 않음) prerender: 페이지 전체를 미리 불러온 뒤 메모리에 로드된 상태로 대기시켜, 사용자가 이동할 때 즉각적으로 표시 source: \u0026quot;list\u0026quot; 외에 \u0026quot;document\u0026quot; 등 다양한 타입이 있을 수 있으며, 이 값에 따라 브라우저가 어떤 방식으로 URL을 해석할지 결정 urls: 실제로 미리 처리할 대상 URL 배열 eagerness: 브라우저가 Speculation Rules를 얼마나 공격적으로 적용할지를 설정 (예: \u0026quot;conservative\u0026quot;, \u0026quot;eager\u0026quot;) 3. Speculation Rules 동작 원리 브라우저 파싱\n브라우저가 HTML 문서를 파싱하며 speculationrules 스크립트를 만나면, 내부의 JSON을 분석합니다.\n규칙 적용\nJSON의 prefetch, prerender, eagerness 설정에 따라 해당 URL들을 우선순위 큐에 등록합니다.\n사전 로드(조건부)\n브라우저는 네트워크 상황, 메모리 상황, CPU 리소스 등을 고려하여 과도한 사전 로드를 막으려 할 수 있습니다. 사용자가 예상 경로를 벗어날 경우에는 해당 사전 로드가 무의미할 수 있음. UX 개선\n실제로 사용자가 사전에 로드된 리소스나 페이지를 요청하면, 이미 브라우저 캐싱 또는 메모리에 준비된 상태이므로 지연 시간이 거의 들지 않습니다.\nSpeculation Rules 설정 옵션\nprerender 옵션 { \u0026#34;prerender\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;urls\u0026#34;: [ \u0026#34;https://example.com/next-page\u0026#34; ] } ] } source: \u0026quot;list\u0026quot;: 단순히 사전에 선언한 URL만을 prerender 대상으로 지정 활용 상황: 다음 단계로 넘어갈 URL을 이미 파악하고 있거나, ‘다음 버튼’과 같이 사용자가 누를 확률이 매우 높은 경우 prefetch 옵션 { \u0026#34;prefetch\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;urls\u0026#34;: [ \u0026#34;https://example.com/assets/images/banner.jpg\u0026#34; ] } ] } prefetch: 큰 이미지, JS, CSS 파일 등 다음 페이지 로딩에 필요한 리소스를 미리 다운받아 둘 때 사용 주의점: 너무 많은 리소스를 무분별하게 prefetch하면, 자원 낭비와 네트워크 혼잡이 발생할 수 있음 eagerness 옵션 eagerness: 이 옵션은 사전 로드의 “공격성”을 조절하며, 주요 값은 다음과 같습니다: \u0026quot;immediate\u0026quot; : 프리패치와 프리랜더를 가능한 한 빠르게 가져옴 \u0026quot;conservative\u0026quot;: 리소스 소모를 최소화하며 신중하게 처리 (예: 마우스다운, 포인터다운) \u0026quot;eager\u0026quot;: 보다 공격적으로 사전 로드를 수행, 더 많은 자원을 사용 가능 (예: 마우스 커서 오버, 스크롤 시 화면 노출 후 중단) \u0026quot;moderate\u0026quot; : eager와 conservative 사이 값. (예: 스크롤 시 화면 노출 후 마우스 커서 이동) 활용 상황: 사용자 경험이 특히 중요한 경우 \u0026quot;eager\u0026quot;를 사용할 수 있지만, 장치 성능과 네트워크 상황을 고려해야 합니다. 5. Speculation Rules의 장점과 단점 장점 빠른 페이지 전환 사용자가 이동할 가능성이 높은 페이지를 미리 랜더링해 둔다면, 즉각적인 반응성을 제공할 수 있습니다. 정교한 제어 JSON 형태의 설정을 통해 어떤 리소스를 얼마만큼 사전에 불러올지 세부적으로 결정할 수 있습니다. 향상된 UX 페이지 전환 시 대기 시간이 현저히 감소해 사용자 만족도 상승 단점 호환성 이슈 모든 브라우저가 지원하지 않습니다. 크롬이 먼저 도입했으며, 다른 브라우저는 도입 계획이 다릅니다. 과도한 리소스 낭비 예측이 빗나갔을 때 불필요한 리소스를 미리 로드해 네트워크 트래픽과 메모리 사용량이 증가할 수 있습니다. 보안, 개인정보 문제 사전 로딩 시 쿠키나 인증 데이터가 의도치 않게 전송될 수 있습니다. 민감 정보가 없는 리소스 위주로 시도하는 것이 좋습니다. 6. 브라우저 호환성과 주의 사항 Speculation Rules는 아직 크롬 계열 브라우저 중심으로만 비교적 실험적으로 지원됩니다.\n따라서 프로덕션 환경에서 전면적으로 적용하기보다는, 아래와 같은 단계를 거치는 것이 좋습니다:\nFeature Detection 사용자 브라우저가 Speculation Rules를 지원하는지 판별하고, 미지원 시 기존 방식(예: rel=\u0026quot;prefetch\u0026quot;)으로 대체 점진적 적용 (Progressive Enhancement) 일부분의 페이지나 리소스에서 먼저 Speculation Rules를 적용해 효과를 측정 효과 측정 \u0026amp; 모니터링 실제 페이지 전환 속도, 사용자 이동 경로, 리소스 사용량 등을 분석해 Speculation Rules의 효용성을 확인 7. 사용 예시 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ko\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Speculation Rules Demo\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Speculation Rules 테스트\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; 아래 버튼을 누르면 다음 페이지로 이동합니다. 다만, 사전에 페이지를 미리 렌더링해 두어, 클릭 즉시 새 페이지가 뜰 것입니다. \u0026lt;/p\u0026gt; \u0026lt;button onclick=\u0026#34;location.href=\u0026#39;next.html\u0026#39;\u0026#34;\u0026gt;다음 페이지로 이동\u0026lt;/button\u0026gt; \u0026lt;!-- Speculation Rules Script --\u0026gt; \u0026lt;script type=\u0026#34;speculationrules\u0026#34;\u0026gt; { \u0026#34;prerender\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;urls\u0026#34;: [\u0026#34;https://example.com/next.html\u0026#34;] } ], \u0026#34;prefetch\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;urls\u0026#34;: [ \u0026#34;/users\u0026#34;, \u0026#34;/info\u0026#34; ] } ], \u0026#34;eagerness\u0026#34;: \u0026#34;eager\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 위 예시는 다음 페이지 next.html을 미리 렌더링(prerender) 해 두고, 필요한 JS/CSS 파일은 미리 다운로드(prefetch)하며, eagerness를 \u0026ldquo;eager\u0026quot;로 설정해 보다 적극적으로 자원을 활용하도록 설정합니다.\n8. 문서가 prerendering인지 확인하는 방법 문서의 통계를 위해서 자바스크립트가 실행을 제한 해야 할 경우가 있을 수도 있습니다. 이런 경우에는 아래와 같은 스크립트를 통해서 제어가 가능 합니다.\nif (document.prerendering) { document.addEventListener(\u0026#34;prerenderingchange\u0026#34;, main, { once: true }); } else { main(); } function main() { setTimeout(() =\u0026gt; { document.body.append(\u0026#34;Timeout Finished\u0026#34;); }, 1000); } 9. 참고 MDN: Resource Hint 사양 MDN: Speculation Rules 사양 YouTube: Speculation Rules 소개 How to Use Speculation Rules API to Load Web Pages Instantly ","date":"2025-01-08","permalink":"/post/2025/2025-01-08_script-type-speculationrules/","section":"post","summary":"웹 성능은 사용자 경험(UX)을 결정짓는 핵심 요소 중 하나입니다. 사용자가 페이지에서 다른 페이지로 이동할 때 추가적인 로딩 지연 없이 빠르게 전환할 수 있다면, 더 높은 만족도가 보장됩니다.\n","title":"Speculation Rules 사이트 로딩 속도 개선하기"},{"content":"\nDocker의 이미지에는 사용자가 생각하는 것보다 더 많은 내용이 포함되는 경우가 많습니다.\n이러한 불필요한 파일, 라이브러리, 의존성 등으로 인해 이미지 크기가 커지고 배포 및 실행 속도가 느려질 수 있습니다. 이 글에서는 Docker 이미지 최적화를 통해 크기와 실행성을 개선하는 다양한 방법을 소개합니다.\nDocker 이미지를 최적화해야 하는 이유 이미지 크기 감소: 최적화를 통해 이미지 크기를 줄임으로써 저장소 및 네트워크 사용량을 절약할 수 있습니다. 이는 개발 및 배포 시간을 단축하고 비용을 절감하는 데 크게 기여합니다. 배포 속도 향상: 이미지 크기가 작아지면 컨테이너의 배포와 로딩 속도가 빨라지며, 이는 CI/CD 워크플로우의 효율성을 높입니다. 보안성 향상: 불필요한 파일과 의존성을 제거하면 공격 표면이 감소하여 잠재적인 보안 취약점을 줄일 수 있습니다. 자원 절약: 작고 간결한 이미지는 시스템 리소스를 효율적으로 사용하며, 메모리 및 디스크 공간 낭비를 방지합니다. 유지보수 용이: 최적화된 이미지에는 필수 구성 요소만 포함하므로 쉽게 관리와 디버깅을 할 수 있습니다. 불필요한 복잡성을 줄여 유지보수가 훨씬 간단해집니다. Docker 이미지 최적화를 위한 효과적인 방법 1. 최소한의 베이스 이미지 선택하기 기본적으로 ubuntu:latest와 같은 큰 이미지를 사용하는 대신, 우리는 alpine으로 전환했습니다. 이 간단한 변화로 이미지 크기를 800MB에서 30MB 이하로 줄일 수 있었습니다. 예시:\nFROM alpine:latest 2. 다단계 빌드 사용하기 React 애플리케이션 같은 프로젝트에서는 빌드 의존성(Node.js, npm 등)이 빌드 과정에서만 필요하고 프로덕션 이미지에서는 필요하지 않습니다. 다단계 빌드를 사용하면 빌드 환경과 런타임 환경을 분리하여 훨씬 작은 이미지를 생성할 수 있습니다. 예시: React 애플리케이션에 다단계 빌드를 적용한 Dockerfile은 다음과 같습니다:\n# 빌드 단계 (Build Stage) FROM node:16 AS builder WORKDIR /app COPY package.json package-lock.json ./ RUN npm install COPY . . RUN npm run build # 런타임 단계 (Runtime Stage) FROM nginx:alpine COPY --from=builder /app/build /usr/share/nginx/html CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] 이 방법은 빌드 파일들만 최종 이미지에 포함되도록 보장해, 프로덕션에 적합하고 크기가 작아진 이미지를 제공합니다.\n3. 불필요한 파일 제거하기 디버깅 과정에서 임시 파일들이 빌드에 포함되는 경우가 많았습니다. .dockerignore 파일을 추가함으로써 이러한 파일들이 이미지에 포함되지 않도록 방지했습니다. 예시:\nnode_modules *.log .git 4. 레이어 결합 및 최소화하기 Dockerfile의 각 명령어(RUN, COPY, ADD 등)는 이미지에 새로운 레이어를 생성합니다. 레이어가 많아지면 이미지 크기가 커질 수 있습니다. 여러 명령어를 하나의 RUN 명령어로 결합하여 레이어 수를 줄이면 이미지를 최적화할 수 있습니다. 예시: 다음과 같이 작성하기보다는:\nRUN apt-get update RUN apt-get install -y curl nodejs RUN apt-get clean RUN rm -rf /var/lib/apt/lists/* 다음처럼 한 줄로 결합하면 좋습니다:\nRUN apt-get update \u0026amp;\u0026amp; apt-get install -y curl nodejs \\ \u0026amp;\u0026amp; apt-get clean \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* 이렇게 하면 레이어 수를 줄이고 같은 레이어 안에서 캐시와 같은 임시 파일을 제거할 수 있어 이미지가 더 작고 깔끔해집니다.\n5. 불필요한 의존성 설치 피하기 Docker 이미지 초기 상태에서는 \u0026ldquo;혹시 필요할지도 몰라서\u0026rdquo; 추가 라이브러리를 설치하는 경우가 많았습니다. 그러나 시간이 지나면서 이는 이미지의 불필요한 비대화와 불필요한 보안 위험을 초래한다는 것을 깨달았습니다. 런타임에 실제로 필요한 의존성만 지정함으로써 이미지를 더 작고 안전하게 유지할 수 있었습니다.\n6. 캐시 활용하기 도커 이미지 빌드 과정에서 캐시를 잘 활용하면 이미지 빌드 시간을 크게 단축할 수 있습니다. 예를 들어, 변경되지 않는 의존성 파일(COPY 명령어)은 Dockerfile 최상단에 배치하여 캐시를 재사용할 수 있게 설계할 수 있습니다.예시:\nCOPY package.json package-lock.json ./ RUN npm install 7. docker-slim 사용하기 이미지 최적화에 혁신을 가져온 도구 중 하나는 docker-slim이었습니다. 이 도구는 이미지를 자동으로 분석하고 사용되지 않는 파일, 바이너리, 라이브러리를 제거하여 크기를 줄여주며, 기능에는 영향을 주지 않습니다. docker-slim을 사용한 이후, 최대 80%까지 이미지 크기를 줄일 수 있었으며 이는 최적화 전략의 필수 도구가 되었습니다. 이미지를 최적화하는 명령어:\ndocker-slim build \u0026lt;image-name\u0026gt; 8. 이미지 정기적으로 점검 및 정리하기 Docker 이미지는 시간이 지남에 따라 쌓이는데, 사용되지 않는 이미지나 레이어는 공간을 낭비하게 됩니다. 정기적으로 사용하지 않는 이미지를 점검하고 정리하는 것은 깨끗한 환경을 유지하는 데 중요합니다. 사용하지 않는 이미지를 정리하는 명령어:\ndocker system prune -f 모든 사용하지 않는 이미지를 제거하는 명령어:\ndocker image prune -a -f 정기적인 정리 작업을 통해 Docker 환경을 효율적으로 유지할 수 있습니다.\n9. 압축 파일 활용하기 이미지 크기를 줄이는 또 다른 방법으로, 압축된 애플리케이션 소스를 Docker 이미지에 포함할 수 있습니다. 소스 파일을 압축하면 전송량이 줄어들고 크기가 최적화됩니다. 또한, 컨테이너 안에서 압축 해제를 통해 필요한 파일만 사용할 수 있습니다. 예시:\nCOPY app.tar.gz /app/ RUN tar -zxvf /app/app.tar.gz -C /app \u0026amp;\u0026amp; rm /app/app.tar.gz 이 방법은 특히 파일 구조가 복잡하거나 대량의 데이터를 포함하고 있을 때 유용하게 사용할 수 있습니다.\n10. 이미지에 메타데이터 추가하기 Dockerfile에 LABEL 명령어를 사용해 주요 메타데이터를 추가하면 이미지 관리와 검색이 더 쉬워집니다. 이는 이미지가 서로 다른 팀이나 빌드 파이프라인에서 사용될 때 유용합니다. 예시:\nLABEL maintainer=\u0026#34;your_email@example.com\u0026#34; LABEL version=\u0026#34;1.0\u0026#34; LABEL description=\u0026#34;This is an optimized Docker image.\u0026#34; 이렇게 메타데이터를 추가하면 관리가 용이하고, 다양한 태그로 이미지를 명확히 식별할 수 있습니다.\n결론 Docker 이미지를 최적화하는 작업은 단순히 이미지 크기를 줄이고 배포 속도를 높이는 것뿐만 아니라, 보안성과 자원 효율성까지 향상시킬 수 있는 중요한 과정입니다. 다양한 최적화 방법을 통해 Docker 이미지를 간소화하면 운영 환경에서의 안정성과 관리 효율성이 증가합니다. 특히 다단계 빌드나 캐시 활용, 그리고 도구를 적극 활용하는 전략들은 시간을 절약하고 비용을 줄이는 데 큰 도움이 됩니다. 결과적으로, 최적화된 Docker 이미지는 개발 및 운영의 전체적인 생산성을 높이는 핵심 요소로 자리매김합니다.\n참고 자료 Docker 공식 문서 Dockerfile 모범 사례 ","date":"2024-12-27","permalink":"/post/2024/2024-12-27_docker-image-optimization/","section":"post","summary":"\nDocker의 이미지에는 사용자가 생각하는 것보다 더 많은 내용이 포함되는 경우가 많습니다.\n","title":"Docker 이미지 최적화: 더 빠른 배포를 위한 크기 줄이기"},{"content":"TypeScript는 현대 웹 개발에서 필수로 자리 잡고 있는 정적 타이핑 언어입니다.\nJavaScript 위에서 작동하면서도 개발자가 안전성과 생산성을 향상시킬 수 있는 여러 고급 기능을 제공합니다. 이 글에서는 TypeScript의 고급 기능을 이해하기 쉽게 설명하고, 실무에서 활용 가능한 예제를 제공합니다.\nInterface 기본적인 Interface 선언 Interface는 주로 객체의 구조를 정의하는 데 사용됩니다. 각 속성의 이름과 타입을 정의하며, 클래스에서도 이를 구현할 수 있습니다.\ninterface User { id: number; name: string; email: string; } const newUser: User = { id: 1, name: \u0026#39;철수\u0026#39;, email: \u0026#39;chulsoo@example.com\u0026#39;, }; 선택적 속성(Optional Properties)과 읽기 전용(Readonly Properties) Interface는 선택적 속성과 읽기 전용 속성도 지원합니다.\ninterface Post { title: string; content?: string; // 선택적 속성 readonly author: string; // 읽기 전용 속성 } const blogPost: Post = { title: \u0026#39;TypeScript Interface 사용법\u0026#39;, author: \u0026#39;영희\u0026#39;, }; blogPost.title = \u0026#39;새로운 제목\u0026#39;; // 가능 // blogPost.author = \u0026#39;철수\u0026#39;; // 오류 발생 Type Type 별칭 (Type Aliases) Type은 다양한 타입을 결합하거나 새로운 이름으로 기존 타입을 정의할 때 사용됩니다. 유니언 타입, 인터섹션 타입 등을 정의하기에도 적합합니다.\ntype Status = \u0026#39;active\u0026#39; | \u0026#39;inactive\u0026#39; | \u0026#39;suspended\u0026#39;; const userStatus: Status = \u0026#39;active\u0026#39;; 객체 타입 정의 Type도 interface와 마찬가지로 객체의 구조를 정의할 수 있습니다.\ntype Product = { id: number; name: string; price: number; }; const newProduct: Product = { id: 101, name: \u0026#39;컴퓨터\u0026#39;, price: 1500000, }; Interface와 Type의 차이 특징 Interface Type 타입 확장 extends 키워드로 확장 가능 인터섹션(\u0026amp;)으로 확장 가능 병합 동일 이름의 Interface는 병합 가능 Type은 병합이 불가 사용 대상 주로 객체, 클래스 구조 정의에 사용 다양한 타입 표현에 적합 Interface 확장 interface Animal { name: string; } interface Dog extends Animal { breed: string; } const myDog: Dog = { name: \u0026#39;나비\u0026#39;, breed: \u0026#39;푸들\u0026#39;, }; Type 확장 type Animal = { name: string; }; type Bird = Animal \u0026amp; { canFly: boolean; }; const myBird: Bird = { name: \u0026#39;참새\u0026#39;, canFly: true, }; 일반적으로 Interface는 객체에 적합하며, Type은 유연성과 간결성이 요구되는 상황에 더 적합합니다. 프로젝트의 요구 사항에 따라 적절히 선택하여 활용하세요.\nInterface와 Type을 활용한 함수 작성 Interface와 Type을 사용하면 함수의 매개변수와 반환값을 명확히 정의할 수 있습니다.\nInterface로 함수 정의 Interface는 함수의 매개변수 객체의 구조를 정의하는 데 자주 사용됩니다.\ninterface Book { title: string; author: string; publishedYear: number; } function printBookInfo(book: Book): void { console.log(`제목: ${book.title}, 저자: ${book.author}, 출판년도: ${book.publishedYear}`); } // 올바른 사용 예시 printBookInfo({ title: \u0026#39;타입스크립트 마스터하기\u0026#39;, author: \u0026#39;홍길동\u0026#39;, publishedYear: 2023, }); // 잘못된 사용 예시 printBookInfo({ title: \u0026#39;타입스크립트 마스터하기\u0026#39;, author: \u0026#39;홍길동\u0026#39;, }); // 오류: publishedYear 속성이 없음 Type으로 함수 정의 type Status = \u0026#39;active\u0026#39; | \u0026#39;inactive\u0026#39; | \u0026#39;suspended\u0026#39;; type User = { id: number; name: string; status: Status; }; function updateUserStatus(user: User, newStatus: Status): User { return { ...user, status: newStatus }; } const user: User = { id: 1, name: \u0026#39;철수\u0026#39;, status: \u0026#39;active\u0026#39;, }; const updatedUser = updateUserStatus(user, \u0026#39;inactive\u0026#39;); console.log(updatedUser); Interface와 Type의 장점 비교 Interface의 주요 장점 클래스와의 통합: Interface는 클래스에서 implements 키워드를 사용하여 쉽게 구현할 수 있습니다. 자동 병합: 동일한 이름의 Interface는 자동으로 병합되므로 확장성이 높습니다. Type의 주요 장점 유연성: 유니언 타입, 인터섹션 타입 등 다양한 복합 타입을 작성할 때 유리합니다. 간결성: 간단하고 가독성이 높은 코드 작성에 적합합니다. 실무에서의 선택 실무에서는 Interface와 Type을 상황에 맞게 혼합하여 사용하는 방식이 일반적입니다. 객체의 모양을 설명해야 할 때는 Interface를, 복합적인 타입을 정의할 때는 Type을 사용하는 것이 좋습니다.\n유니언(Union) 타입과 인터섹션(Intersection) 타입 TypeScript는 여러 타입을 결합하여 새로운 타입을 만들어낼 수 있는 강력한 기능을 제공합니다. 이는 JavaScript에서의 논리 연산자 OR(||)와 AND(\u0026amp;\u0026amp;)와 비슷한 개념으로, 코드 베이스에서 정교한 타입 검사를 수행할 수 있게 합니다.\n유니언 타입 유니언 타입은 두 개 이상의 타입을 조합하여 생성하는 타입입니다. 이를 통해 변수나 매개변수가 여러 타입 중 하나를 가질 수 있도록 지정할 수 있습니다.\nfunction orderProduct(orderId: string | number) { console.log(\u0026#39;상품 주문 번호:\u0026#39;, orderId); } // 👍 올바른 사용 예시 orderProduct(1); orderProduct(\u0026#39;123-abc\u0026#39;); // 👎 잘못된 사용 예시 orderProduct({ name: \u0026#39;상품명\u0026#39; }); 위 코드는 string 또는 number 타입을 매개변수로만 허용합니다. 다른 타입이 들어올 경우 컴파일 단계에서 오류를 반환합니다.\n인터섹션 타입 반면, 인터섹션 타입은 여러 타입의 모든 속성을 포함하는 새로운 타입을 생성합니다. 이는 객체 또는 변수 등이 여러 타입을 동시에 만족해야 할 때 유용합니다.\ninterface Person { name: string; firstname: string; } interface FootballPlayer { club: string; } function transferPlayer(player: Person \u0026amp; FootballPlayer) { console.log(`${player.firstname} ${player.name} 선수가 ${player.club}으로 이적합니다.`); } // 👍 올바른 사용 예시 transferPlayer({ name: \u0026#39;라마스\u0026#39;, firstname: \u0026#39;세르히오\u0026#39;, club: \u0026#39;PSG\u0026#39;, }); // 👎 잘못된 사용 예시 transferPlayer({ name: \u0026#39;라마스\u0026#39;, firstname: \u0026#39;세르히오\u0026#39;, }); 여기서 transferPlayer 함수는 Person과 FootballPlayer의 모든 속성을 가지는 객체만 허용합니다. 속성이 누락되면 TypeScript는 컴파일 단계에서 오류를 반환합니다.\nKeyof 키워드 keyof 키워드는 인터페이스나 객체의 키를 추출하여 새로운 유니언 타입을 생성할 수 있게 해줍니다. 이는 타입 안정성을 유지하고, 리팩토링 시 실수를 줄이는 데 중요한 역할을 합니다.\ninterface MovieCharacter { firstname: string; name: string; movie: string; } type characterProps = keyof MovieCharacter; // characterProps는 \u0026#39;firstname\u0026#39; | \u0026#39;name\u0026#39; | \u0026#39;movie\u0026#39; 타입 keyof를 사용하지 않고 직접 타입을 명시할 수도 있습니다:\ntype characterProps = \u0026#39;firstname\u0026#39; | \u0026#39;name\u0026#39; | \u0026#39;movie\u0026#39;; 하지만 keyof를 사용하면 MovieCharacter 인터페이스를 변경하더라도 타입이 자동으로 반영되어 코드의 유지보수가 더 쉬워집니다.\n응용 예제 interface PizzaMenu { starter: string; pizza: string; beverage: string; dessert: string; } const simpleMenu: PizzaMenu = { starter: \u0026#39;샐러드\u0026#39;, pizza: \u0026#39;페퍼로니\u0026#39;, beverage: \u0026#39;콜라\u0026#39;, dessert: \u0026#39;바닐라 아이스크림\u0026#39;, }; function adjustMenu( menu: PizzaMenu, menuEntry: keyof PizzaMenu, change: string, ) { menu[menuEntry] = change; } // 👍 올바른 사용 예시 adjustMenu(simpleMenu, \u0026#39;pizza\u0026#39;, \u0026#39;하와이안 피자\u0026#39;); adjustMenu(simpleMenu, \u0026#39;beverage\u0026#39;, \u0026#39;맥주\u0026#39;); // 👎 잘못된 사용 예시 adjustMenu(simpleMenu, \u0026#39;coffee\u0026#39;, \u0026#39;아메리카노\u0026#39;); 위의 예제에서 adjustMenu 함수는 메뉴를 조정할 수 있도록 구현되었습니다. keyof를 사용함으로써 인터페이스 변경 시 함수가 자동으로 변화를 반영하며 타입 안정성이 유지됩니다.\nTypeof 키워드 typeof 키워드는 변수의 타입을 추출하여 사용할 수 있도록 해줍니다. 이는 특히 함수의 반환 타입을 기반으로 새로운 타입을 생성할 때 유용합니다.\n간단한 예제 let firstname = \u0026#39;프로도\u0026#39;; let name: typeof firstname; // name은 \u0026#39;string\u0026#39; 타입 단순한 예제에서는 효과가 크지 않지만, 더 복잡한 코드에서는 강력한 도구가 됩니다. 아래는 ReturnType과 결합하여 함수의 반환 타입을 추출하는 예제입니다.\n응용 예제 function getCharacter() { return { firstname: \u0026#39;프로도\u0026#39;, name: \u0026#39;배긴스\u0026#39;, }; } type Character = ReturnType\u0026lt;typeof getCharacter\u0026gt;; /* Character 타입은 아래와 같습니다: { firstname: string; name: string; } */ 위 코드에서는 getCharacter 함수의 반환 타입을 기반으로 Character 타입을 생성합니다. 함수의 반환 타입이 변경되면 Character 타입도 자동으로 갱신됩니다. 이는 리팩토링과 코드 유지보수의 부담을 크게 줄여줍니다.\n조건부 타입 (Conditional Types) 조건부 타입은 JavaScript의 삼항 연산자와 유사한 개념으로, 조건에 따라 다른 타입을 반환합니다. 이는 TypeScript에서 더욱 강력하고 유연한 타입 시스템을 지원합니다.\n기본 문법 T extends 조건 ? 참일 때 타입 : 거짓일 때 타입;\n활용 예제 interface StringId { id: string; } interface NumberId { id: number; } type Id\u0026lt;T\u0026gt; = T extends string ? StringId : NumberId; // 사용 예시 let idOne: Id\u0026lt;string\u0026gt;; // StringId 타입 let idTwo: Id\u0026lt;number\u0026gt;; // NumberId 타입 위 예제에서는 Id라는 조건부 타입을 정의했습니다. 만약 T가 string 타입으로 확장 가능하다면, 반환 타입은 StringId이고, 그렇지 않으면 NumberId 타입이 됩니다.\n조건부 타입은 타입에서 더욱 정교한 제어와 타입 기반 로직을 구현할 수 있도록 도와줍니다.\n명령어 유형 유틸리티 타입은 일반적인 타입 변환을 용이하게 하기 위한 도구입니다. TypeScript는 많은 유틸리티 타입을 제공합니다. 이 블로그 포스트에서 전부를 다루기에는 너무 많습니다. 아래에는 제가 가장 자주 사용하는 유틸리티 타입 몇 가지를 선택적으로 소개합니다. 공식 TypeScript 문서는 모든 유틸리티 타입 목록을 잘 제공하고 있습니다.\nPartial The Partial utility type를 사용하면 모든 속성이 선택 사항인 새로운 인터페이스로 인터페이스를 변환할 수 있습니다.\ninterface MovieCharacter { firstname: string; name: string; movie: string; } function registerCharacter(character: Partial\u0026lt;MovieCharacter\u0026gt;) {} // 👍 올바른 사용 예시 registerCharacter({ firstname: \u0026#39;Frodo\u0026#39;, }); // 👎 잘못된 사용 예시 registerCharacter({ firstname: \u0026#39;Frodo\u0026#39;, name: \u0026#39;Baggins\u0026#39;, }); MovieCharacter는 firstname, name, movie가 필요합니다. 그러나 registerPerson 함수의 시그니처는 Partial 유틸리티를 사용하여 firstname, name, movie를 선택적으로 가진 새 타입을 생성합니다.\nRequired Required는 Partial의 반대 역할을 합니다. 선택적 속성을 가진 기존 인터페이스를 받아 모든 속성이 필수인 타입으로 변환합니다.\ninterface MovieCharacter { firstname?: string; name?: string; movie?: string; } function hireActor(character: Required\u0026lt;MovieCharacter\u0026gt;) {} // 👍 올바른 사용 예시 hireActor({ firstname: \u0026#39;Frodo\u0026#39;, name: \u0026#39;Baggins\u0026#39;, movie: \u0026#39;The Lord of the Rings\u0026#39;, }); // 👎 잘못된 사용 예시 hireActor({ firstname: \u0026#39;Frodo\u0026#39;, name: \u0026#39;Baggins\u0026#39;, }); 이 예제에서는 MovieCharacter의 속성이 선택 사항이었습니다. Required를 사용하여 모든 속성이 필수인 타입으로 변환하였습니다. 따라서 firstname, name 및 movie 속성을 포함하는 객체만 허용됩니다.\nExtract Extract는 타입의 정보를 추출할 수 있도록 해줍니다. Extract는 두 개의 매개변수를 받으며, 첫 번째는 인터페이스이고 두 번째는 추출해야 할 타입입니다.\ntype MovieCharacters = | \u0026#39;Harry Potter\u0026#39; | \u0026#39;Tom Riddle\u0026#39; | { firstname: string; name: string }; type hpCharacters = Extract\u0026lt;MovieCharacters, string\u0026gt;; // hpCharacters = \u0026#39;Harry Potter\u0026#39; | \u0026#39;Tom Riddle\u0026#39;; type hpCharacters = Extract\u0026lt;MovieCharacters, { firstname: string }\u0026gt;; // hpCharacters = {firstname: string; name: string }; Extract\u0026lt;MovieCharacters, string\u0026gt;는 문자열로 구성된 유니언 타입 hpCharacters를 생성합니다. 반면 Extract\u0026lt;MovieCharacters, {firstname: string}\u0026gt;는 firstname: string 타입을 포함하는 모든 객체 타입을 추출합니다.\nExclude Exclude는 추출의 반대 역할을 합니다. 즉, 타입을 제외하여 새 타입을 생성할 수 있습니다.\ntype MovieCharacters = | \u0026#39;Harry Potter\u0026#39; | \u0026#39;Tom Riddle\u0026#39; | { firstname: string; name: string }; type hpCharacters = Exclude\u0026lt;MovieCharacters, string\u0026gt;; // equal to type hpCharacters = {firstname: string; name: string }; type hpCharacters = Exclude\u0026lt;MovieCharacters, { firstname: string }\u0026gt;; // equal to type hpCharacters = \u0026#39;Harry Potter\u0026#39; | \u0026#39;Tom Riddle\u0026#39;; 먼저, 모든 문자열을 제외하는 새로운 타입을 생성합니다. 그 다음, firstname: string을 포함하는 모든 객체 타입을 제외하는 타입을 생성합니다.\nInfer type infer는 새 유형(type)을 생성할 수 있게 해줍니다. 이는 Javascript에서 var, let 또는 const 키워드를 사용하여 변수를 생성하는 것과 유사합니다.\ntype flattenArrayType\u0026lt;T\u0026gt; = T extends Array\u0026lt;infer ArrayType\u0026gt; ? ArrayType : T; type foo = flattenArrayType\u0026lt;string[]\u0026gt;; // foo = string; type foo = flattenArrayType\u0026lt;number[]\u0026gt;; // foo = number; type foo = flattenArrayType\u0026lt;number\u0026gt;; // foo = number; T는 Array\u0026lt;infer ArrayType\u0026gt;을 확장합니다. 이는 T가 배열(Array)을 확장하는지 확인하는 것입니다. 더욱이, 우리는 infer 키워드를 사용하여 배열 타입을 얻습니다. 이는 마치 변수를 사용해 타입을 저장하는 것과 같습니다.그런 다음, 조건부 타입을 사용하여 T가 배열을 확장하면 ArrayType을 반환합니다. 그렇지 않으면 T를 반환합니다.\n","date":"2024-12-27","permalink":"/post/2024/2024-12-27_advanced-typescript/","section":"post","summary":"TypeScript는 현대 웹 개발에서 필수로 자리 잡고 있는 정적 타이핑 언어입니다.\n","title":"TypeScript Interface와 Type"},{"content":"Aspect-Oriented Programming(AOP)은 Spring에서 횡단 관심사를 처리하기 위한 강력한 도구입니다.\nAOP를 활용하면 애플리케이션의 주요 비즈니스 로직을 간결하게 유지하면서도, 반복적인 작업을 쉽게 처리할 수 있습니다. 아래는 Spring AOP를 활용해 구현할 수 있는 몇 가지 유용한 기능과 구현 예제입니다.\n1. 로깅 (Logging) 메서드의 입력값, 출력값, 실행 시간을 로깅하는 기능.\n구현 예제\n@Aspect @Component public class LoggingAspect { @Around(\u0026#34;execution(* com.example..*(..))\u0026#34;) // com.example 패키지의 모든 메서드 public Object logMethodDetails(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Method \u0026#34; + joinPoint.getSignature() + \u0026#34; called with args: \u0026#34; + Arrays.toString(joinPoint.getArgs())); Object result = joinPoint.proceed(); System.out.println(\u0026#34;Method \u0026#34; + joinPoint.getSignature() + \u0026#34; returned: \u0026#34; + result); return result; } } 2. 보안 검사 (Security Check) 메서드 실행 전 사용자의 인증 및 권한을 검사하는 기능.\n구현 예제\n@Aspect @Component public class SecurityAspect { @Before(\u0026#34;@annotation(com.example.annotations.SecureAction)\u0026#34;) // 특정 어노테이션이 붙은 메서드만 public void checkSecurity() { // 예: 현재 사용자의 권한을 확인 boolean hasPermission = SecurityContextHolder.getContext().getAuthentication().isAuthenticated(); if (!hasPermission) { throw new SecurityException(\u0026#34;User not authorized!\u0026#34;); } System.out.println(\u0026#34;User is authorized\u0026#34;); } } 3. 트랜잭션 관리 (Custom Transaction Management) Spring의 기본 트랜잭션 외에, 특정 작업에서 커스텀 트랜잭션 처리를 추가.\n구현 예제\n@Aspect @Component public class TransactionManagementAspect { @Around(\u0026#34;@annotation(org.springframework.transaction.annotation.Transactional)\u0026#34;) public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Transaction started\u0026#34;); try { Object result = joinPoint.proceed(); System.out.println(\u0026#34;Transaction committed\u0026#34;); return result; } catch (Exception ex) { System.out.println(\u0026#34;Transaction rolled back\u0026#34;); throw ex; } } } 4. 캐싱 (Caching) 결과를 캐싱하여 메서드 호출을 최적화.\n구현 예제\n@Aspect @Component public class CachingAspect { private final Map\u0026lt;String, Object\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); @Around(\u0026#34;@annotation(com.example.annotations.Cached)\u0026#34;) public Object cacheResult(ProceedingJoinPoint joinPoint) throws Throwable { String key = joinPoint.getSignature().toString() + Arrays.toString(joinPoint.getArgs()); if (cache.containsKey(key)) { System.out.println(\u0026#34;Cache hit for key: \u0026#34; + key); return cache.get(key); } System.out.println(\u0026#34;Cache miss for key: \u0026#34; + key); Object result = joinPoint.proceed(); cache.put(key, result); return result; } } 5. 예외 처리 (Global Exception Handling) 특정 패키지의 메서드에서 발생한 예외를 중앙에서 처리.\n구현 예제\n@Aspect @Component public class ExceptionHandlingAspect { @AfterThrowing(pointcut = \u0026#34;execution(* com.example..*(..))\u0026#34;, throwing = \u0026#34;ex\u0026#34;) public void handleException(JoinPoint joinPoint, Exception ex) { System.err.println(\u0026#34;Exception in method \u0026#34; + joinPoint.getSignature() + \u0026#34;: \u0026#34; + ex.getMessage()); // 로그 저장 또는 알림 전송 } } 6. 메트릭 수집 (Metrics Collection) 메서드 호출 횟수, 평균 실행 시간을 수집하여 성능 모니터링.\n구현 예제\n@Aspect @Component public class MetricsAspect { private final Map\u0026lt;String, Long\u0026gt; executionCount = new HashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Long\u0026gt; totalTime = new HashMap\u0026lt;\u0026gt;(); @Around(\u0026#34;execution(* com.example..*(..))\u0026#34;) public Object collectMetrics(ProceedingJoinPoint joinPoint) throws Throwable { String methodName = joinPoint.getSignature().toString(); long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long duration = System.currentTimeMillis() - start; executionCount.put(methodName, executionCount.getOrDefault(methodName, 0L) + 1); totalTime.put(methodName, totalTime.getOrDefault(methodName, 0L) + duration); System.out.println(\u0026#34;Method \u0026#34; + methodName + \u0026#34; called \u0026#34; + executionCount.get(methodName) + \u0026#34; times\u0026#34;); System.out.println(\u0026#34;Average execution time: \u0026#34; + (totalTime.get(methodName) / executionCount.get(methodName)) + \u0026#34; ms\u0026#34;); return result; } } 7. 입력값 검증 (Validation) 메서드 호출 전에 입력값이 유효한지 검증.\n구현 예제\n@Aspect @Component public class ValidationAspect { @Before(\u0026#34;@annotation(com.example.annotations.ValidateInput)\u0026#34;) public void validateInputs(JoinPoint joinPoint) { Object[] args = joinPoint.getArgs(); for (Object arg : args) { if (arg == null) { throw new IllegalArgumentException(\u0026#34;Null value not allowed for arguments!\u0026#34;); } } System.out.println(\u0026#34;All inputs are valid\u0026#34;); } } 여기에는 Spring AOP를 활용하여 더 다양한 유용한 기능을 구현한 예제를 소개합니다. 각 기능은 프로젝트에 따라 확장 가능하며, 비즈니스 요구사항에 따라 활용될 수 있습니다.\n8. 요청 데이터 암호화 및 복호화 API 요청 데이터나 응답 데이터를 암호화/복호화하여 보안성을 강화.\n구현 예제\n@Aspect @Component public class EncryptionAspect { private static final String SECRET_KEY = \u0026#34;my-secret-key\u0026#34;; @Around(\u0026#34;@annotation(com.example.annotations.EncryptData)\u0026#34;) public Object encryptAndDecrypt(ProceedingJoinPoint joinPoint) throws Throwable { Object[] args = joinPoint.getArgs(); // 암호화된 데이터로 변경 for (int i = 0; i \u0026lt; args.length; i++) { if (args[i] instanceof String) { args[i] = encrypt((String) args[i]); } } System.out.println(\u0026#34;Arguments encrypted: \u0026#34; + Arrays.toString(args)); // 메서드 실행 Object result = joinPoint.proceed(args); // 복호화된 결과 반환 if (result instanceof String) { result = decrypt((String) result); System.out.println(\u0026#34;Result decrypted: \u0026#34; + result); } return result; } private String encrypt(String data) { // 간단한 암호화 로직 (예시) return Base64.getEncoder().encodeToString((data + SECRET_KEY).getBytes()); } private String decrypt(String data) { // 간단한 복호화 로직 (예시) String decoded = new String(Base64.getDecoder().decode(data)); return decoded.replace(SECRET_KEY, \u0026#34;\u0026#34;); } } 9. API 호출 제한 (Rate Limiting) 특정 사용자가 API를 과도하게 호출하지 않도록 제한.\n구현 예제\n@Aspect @Component public class RateLimitingAspect { private final Map\u0026lt;String, Integer\u0026gt; userRequestCounts = new HashMap\u0026lt;\u0026gt;(); private static final int LIMIT = 5; // 요청 제한 @Before(\u0026#34;@annotation(com.example.annotations.RateLimited)\u0026#34;) public void enforceRateLimit(JoinPoint joinPoint) { String userId = getCurrentUserId(); // 사용자 ID 가져오기 (가정) userRequestCounts.put(userId, userRequestCounts.getOrDefault(userId, 0) + 1); if (userRequestCounts.get(userId) \u0026gt; LIMIT) { throw new RuntimeException(\u0026#34;Rate limit exceeded for user: \u0026#34; + userId); } System.out.println(\u0026#34;Request allowed for user: \u0026#34; + userId); } private String getCurrentUserId() { // 현재 사용자 ID를 가져오는 로직 (예: 보안 컨텍스트) return \u0026#34;user123\u0026#34;; } } 10. 메서드 리트라이 (Retry) 실패한 메서드 호출을 일정 횟수까지 재시도.\n구현 예제\n@Aspect @Component public class RetryAspect { @Around(\u0026#34;@annotation(com.example.annotations.Retryable)\u0026#34;) public Object retry(ProceedingJoinPoint joinPoint) throws Throwable { int maxRetries = 3; // 최대 재시도 횟수 int attempts = 0; while (true) { try { return joinPoint.proceed(); // 메서드 실행 } catch (Exception ex) { attempts++; System.out.println(\u0026#34;Attempt \u0026#34; + attempts + \u0026#34; failed\u0026#34;); if (attempts \u0026gt;= maxRetries) { System.out.println(\u0026#34;Max retries reached\u0026#34;); throw ex; } } } } } 11. 감사 로깅 (Audit Logging) 중요한 작업(예: 데이터베이스 변경)을 기록하여 감사를 가능하게 함.\n구현 예제\n@Aspect @Component public class AuditLoggingAspect { @After(\u0026#34;@annotation(com.example.annotations.AuditLog)\u0026#34;) public void logAuditDetails(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); String userName = getCurrentUserName(); // 현재 사용자 가져오기 (가정) System.out.println(\u0026#34;User \u0026#34; + userName + \u0026#34; executed \u0026#34; + methodName); // 로그 저장 또는 DB에 기록 } private String getCurrentUserName() { // 현재 사용자 이름을 반환 (예: 보안 컨텍스트) return \u0026#34;admin\u0026#34;; } } 12. 메서드 호출 알림 (Notification) 특정 메서드가 호출되었을 때 알림을 전송.\n구현 예제\n@Aspect @Component public class NotificationAspect { @After(\u0026#34;@annotation(com.example.annotations.NotifyOnCall)\u0026#34;) public void sendNotification(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); System.out.println(\u0026#34;Notification: Method \u0026#34; + methodName + \u0026#34; was called\u0026#34;); // 알림 전송 (예: 이메일, SMS, 슬랙) } } 13. 요청 추적 (Request Tracing) 모든 요청을 추적하여 디버깅 및 모니터링.\n구현 예제\n@Aspect @Component public class RequestTracingAspect { @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) // 컨트롤러의 모든 메서드 public void traceRequest(JoinPoint joinPoint) { System.out.println(\u0026#34;Request received for method: \u0026#34; + joinPoint.getSignature()); System.out.println(\u0026#34;Arguments: \u0026#34; + Arrays.toString(joinPoint.getArgs())); } } 14. 데이터 변경 이벤트 처리 데이터 변경 시 추가 작업(예: 캐시 무효화) 수행.\n구현 예제\n@Aspect @Component public class DataChangeAspect { @AfterReturning(\u0026#34;@annotation(com.example.annotations.OnDataChange)\u0026#34;) public void handleDataChange(JoinPoint joinPoint) { System.out.println(\u0026#34;Data change detected in method: \u0026#34; + joinPoint.getSignature()); // 캐시 무효화, 이벤트 전송 등의 작업 수행 } } 15. 성능 문제 감지 (Performance Monitoring) 특정 메서드에서 일정 시간을 초과하는 경우 경고를 출력.\n구현 예제\n@Aspect @Component public class PerformanceMonitoringAspect { private static final long WARNING_THRESHOLD = 1000; // 1초 @Around(\u0026#34;@annotation(com.example.annotations.MonitorPerformance)\u0026#34;) public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long duration = System.currentTimeMillis() - start; if (duration \u0026gt; WARNING_THRESHOLD) { System.err.println(\u0026#34;Performance warning: \u0026#34; + joinPoint.getSignature() + \u0026#34; took \u0026#34; + duration + \u0026#34; ms\u0026#34;); } else { System.out.println(joinPoint.getSignature() + \u0026#34; executed in \u0026#34; + duration + \u0026#34; ms\u0026#34;); } return result; } } 16. 데이터베이스 슬로우 쿼리 탐지 SQL 실행 시간이 긴 경우 경고 로그를 남기거나 알림을 보냅니다.\n구현 예제\n@Aspect @Component public class SlowQueryDetectorAspect { private static final long SLOW_QUERY_THRESHOLD = 2000; // 2초 @Around(\u0026#34;execution(* com.example.repository..*(..))\u0026#34;) // Repository 계층 감시 public Object detectSlowQueries(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long duration = System.currentTimeMillis() - start; if (duration \u0026gt; SLOW_QUERY_THRESHOLD) { System.err.println(\u0026#34;Slow query detected: \u0026#34; + joinPoint.getSignature() + \u0026#34; took \u0026#34; + duration + \u0026#34; ms\u0026#34;); } return result; } } 17. 사용자 접근 로그 기록 (Access Logging) API 호출 시 사용자의 IP 주소, 요청 시간 등을 기록합니다.\n구현 예제\n@Aspect @Component public class AccessLoggingAspect { @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) // 모든 컨트롤러 메서드 public void logAccess(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); String ipAddress = getClientIp(); // 클라이언트 IP 가져오기 System.out.println(\u0026#34;Access log: \u0026#34; + methodName + \u0026#34; called from IP: \u0026#34; + ipAddress); } private String getClientIp() { // HttpServletRequest를 통해 IP 주소 가져오기 return \u0026#34;127.0.0.1\u0026#34;; // 예제용 } } 18. 조건부 실행 (Conditional Execution) 특정 조건에서만 메서드를 실행하거나 무시합니다.\n구현 예제\n@Aspect @Component public class ConditionalExecutionAspect { @Around(\u0026#34;@annotation(com.example.annotations.ConditionalRun)\u0026#34;) public Object executeConditionally(ProceedingJoinPoint joinPoint) throws Throwable { boolean shouldRun = checkCondition(); // 실행 조건 확인 if (shouldRun) { return joinPoint.proceed(); // 조건이 충족되면 실행 } else { System.out.println(\u0026#34;Method \u0026#34; + joinPoint.getSignature() + \u0026#34; skipped due to condition\u0026#34;); return null; // 실행하지 않음 } } private boolean checkCondition() { // 조건 로직 (예: 특정 설정값 확인) return false; } } 19. 메서드 호출 수 제한 특정 메서드가 지정된 횟수 이상 호출되지 않도록 제한합니다.\n구현 예제\n@Aspect @Component public class MethodCallLimiterAspect { private final Map\u0026lt;String, Integer\u0026gt; methodCallCounts = new HashMap\u0026lt;\u0026gt;(); private static final int MAX_CALLS = 10; // 최대 호출 횟수 @Before(\u0026#34;@annotation(com.example.annotations.LimitedCall)\u0026#34;) public void limitMethodCalls(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); int currentCount = methodCallCounts.getOrDefault(methodName, 0); if (currentCount \u0026gt;= MAX_CALLS) { throw new RuntimeException(\u0026#34;Method \u0026#34; + methodName + \u0026#34; has been called too many times\u0026#34;); } methodCallCounts.put(methodName, currentCount + 1); System.out.println(\u0026#34;Method \u0026#34; + methodName + \u0026#34; called \u0026#34; + (currentCount + 1) + \u0026#34; times\u0026#34;); } } 20. 사용자 ID 태깅 (User ID Tagging) 로그나 메트릭에 현재 사용자 ID를 태깅하여 사용자별 모니터링을 제공합니다.\n구현 예제\n@Aspect @Component public class UserIdTaggingAspect { @Before(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) // 서비스 계층 메서드 감시 public void tagUserId(JoinPoint joinPoint) { String userId = getCurrentUserId(); // 현재 사용자 ID 가져오기 System.out.println(\u0026#34;Tagging user ID: \u0026#34; + userId + \u0026#34; for method: \u0026#34; + joinPoint.getSignature()); } private String getCurrentUserId() { // 보안 컨텍스트에서 사용자 ID 가져오기 return \u0026#34;user123\u0026#34;; // 예제용 } } 21. 필드 마스킹 (Field Masking) 로그 출력 시 민감한 데이터를 마스킹합니다.\n구현 예제\n@Aspect @Component public class FieldMaskingAspect { @Around(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) // 서비스 계층 메서드 감시 public Object maskSensitiveFields(ProceedingJoinPoint joinPoint) throws Throwable { Object result = joinPoint.proceed(); if (result instanceof String) { // 민감한 데이터 마스킹 (예: 이메일, 카드 번호) result = ((String) result).replaceAll(\u0026#34;(?\u0026lt;=.{2}).(?=.*@)\u0026#34;, \u0026#34;*\u0026#34;); } return result; } } 22. 실행 환경 확인 (Environment Check) 테스트 환경이나 프로덕션 환경에 따라 다른 동작을 수행.\n구현 예제\n@Aspect @Component public class EnvironmentCheckAspect { @Around(\u0026#34;@annotation(com.example.annotations.EnvironmentSensitive)\u0026#34;) public Object checkEnvironment(ProceedingJoinPoint joinPoint) throws Throwable { String currentEnv = getCurrentEnvironment(); // 현재 환경 가져오기 if (\u0026#34;prod\u0026#34;.equals(currentEnv)) { System.out.println(\u0026#34;Executing in production\u0026#34;); } else { System.out.println(\u0026#34;Executing in non-production environment\u0026#34;); } return joinPoint.proceed(); } private String getCurrentEnvironment() { // Spring Environment에서 현재 프로파일 가져오기 return \u0026#34;dev\u0026#34;; // 예제용 } } 23. 특정 패키지 메서드 호출 차단 특정 패키지의 메서드가 호출되지 않도록 차단합니다.\n구현 예제\n@Aspect @Component public class MethodBlockingAspect { @Before(\u0026#34;execution(* com.example.unallowed..*(..))\u0026#34;) // 금지된 패키지 public void blockMethodCall(JoinPoint joinPoint) { throw new RuntimeException(\u0026#34;Method \u0026#34; + joinPoint.getSignature() + \u0026#34; is not allowed to be called\u0026#34;); } } 24. 메서드 입력값 변환 (Input Transformation) 메서드 호출 전에 입력값을 변환.\n구현 예제\n@Aspect @Component public class InputTransformationAspect { @Around(\u0026#34;@annotation(com.example.annotations.TransformInput)\u0026#34;) public Object transformInput(ProceedingJoinPoint joinPoint) throws Throwable { Object[] args = joinPoint.getArgs(); for (int i = 0; i \u0026lt; args.length; i++) { if (args[i] instanceof String) { args[i] = ((String) args[i]).toUpperCase(); // 입력값 대문자 변환 } } System.out.println(\u0026#34;Transformed arguments: \u0026#34; + Arrays.toString(args)); return joinPoint.proceed(args); } } 25. 메모리 사용 모니터링 (Memory Usage Monitoring) 메서드 실행 전후로 메모리 사용량을 기록.\n구현 예제\n@Aspect @Component public class MemoryMonitoringAspect { @Around(\u0026#34;@annotation(com.example.annotations.MonitorMemory)\u0026#34;) public Object monitorMemoryUsage(ProceedingJoinPoint joinPoint) throws Throwable { Runtime runtime = Runtime.getRuntime(); long beforeMemory = runtime.totalMemory() - runtime.freeMemory(); Object result = joinPoint.proceed(); long afterMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;Memory usage for method \u0026#34; + joinPoint.getSignature() + \u0026#34;: \u0026#34; + (afterMemory - beforeMemory) + \u0026#34; bytes\u0026#34;); return result; } } 26. API 요청 제한 속도 조정 (Dynamic Throttling) 시스템 상태나 사용자 그룹에 따라 요청 속도를 동적으로 제한합니다.\n구현 예제\n@Aspect @Component public class DynamicThrottlingAspect { private final Map\u0026lt;String, Long\u0026gt; userLastRequestTime = new HashMap\u0026lt;\u0026gt;(); private static final long MIN_INTERVAL = 1000; // 최소 요청 간격 (1초) @Before(\u0026#34;@annotation(com.example.annotations.Throttled)\u0026#34;) public void enforceThrottling(JoinPoint joinPoint) { String userId = getCurrentUserId(); // 사용자 ID 가져오기 long currentTime = System.currentTimeMillis(); if (userLastRequestTime.containsKey(userId)) { long lastRequestTime = userLastRequestTime.get(userId); if (currentTime - lastRequestTime \u0026lt; MIN_INTERVAL) { throw new RuntimeException(\u0026#34;Too many requests for user: \u0026#34; + userId); } } userLastRequestTime.put(userId, currentTime); } private String getCurrentUserId() { // 예: 보안 컨텍스트에서 사용자 ID 가져오기 return \u0026#34;user123\u0026#34;; // 예제용 } } 27. 컨트롤러 응답 변환 (Response Transformation) 컨트롤러의 반환값을 동적으로 수정하여 사용자 맞춤 데이터를 반환합니다.\n구현 예제\n@Aspect @Component public class ResponseTransformationAspect { @AfterReturning(pointcut = \u0026#34;execution(* com.example.controller..*(..))\u0026#34;, returning = \u0026#34;response\u0026#34;) public Object transformResponse(JoinPoint joinPoint, Object response) { if (response instanceof String) { return ((String) response).toUpperCase(); // 응답을 대문자로 변환 } return response; } } 28. 실시간 메트릭 수집 (Real-time Metrics Collection) 메서드 실행 데이터를 외부 모니터링 시스템으로 전송합니다.\n구현 예제\n@Aspect @Component public class RealTimeMetricsAspect { @AfterReturning(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public void sendMetricsToSystem(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); System.out.println(\u0026#34;Sending execution metrics for: \u0026#34; + methodName); // 외부 시스템에 메트릭 전송 (예: Prometheus, DataDog) } } 29. 사용자별 데이터 필터링 사용자 권한에 따라 반환되는 데이터를 필터링합니다.\n구현 예제\n@Aspect @Component public class DataFilteringAspect { @Around(\u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(com.example.annotations.FilteredData)\u0026#34;) public Object filterDataForUser(ProceedingJoinPoint joinPoint) throws Throwable { Object result = joinPoint.proceed(); // 사용자 권한에 따른 데이터 필터링 if (result instanceof List) { List\u0026lt;?\u0026gt; list = (List\u0026lt;?\u0026gt;) result; return list.stream() .filter(item -\u0026gt; userHasAccess(item)) // 사용자 접근 권한 필터 .toList(); } return result; } private boolean userHasAccess(Object item) { // 접근 권한 로직 return true; // 예제용 } } 30. 메서드 파라미터 로그 제외 (Sensitive Logging) 특정 파라미터를 로그에서 제외하여 민감 정보를 보호합니다.\n구현 예제\n@Aspect @Component public class SensitiveLoggingAspect { @Around(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public Object excludeSensitiveParams(ProceedingJoinPoint joinPoint) throws Throwable { Object[] args = joinPoint.getArgs(); String methodName = joinPoint.getSignature().toShortString(); // 민감 데이터 마스킹 Object[] sanitizedArgs = Arrays.stream(args) .map(arg -\u0026gt; arg instanceof String \u0026amp;\u0026amp; isSensitive(arg) ? \u0026#34;****\u0026#34; : arg) .toArray(); System.out.println(\u0026#34;Method \u0026#34; + methodName + \u0026#34; called with args: \u0026#34; + Arrays.toString(sanitizedArgs)); return joinPoint.proceed(); } private boolean isSensitive(Object arg) { // 민감 정보 판별 (예: 비밀번호, 카드 번호) return arg.toString().matches(\u0026#34;.*\\\\d{4}-\\\\d{4}-\\\\d{4}-\\\\d{4}.*\u0026#34;); // 카드 번호 예시 } } 31. 백그라운드 태스크 실행 (Background Task Execution) 메서드 실행을 비동기로 처리하여 응답 속도를 높입니다.\n구현 예제\n@Aspect @Component public class BackgroundTaskAspect { private final ExecutorService executorService = Executors.newCachedThreadPool(); @Around(\u0026#34;@annotation(com.example.annotations.BackgroundTask)\u0026#34;) public void executeInBackground(ProceedingJoinPoint joinPoint) { executorService.submit(() -\u0026gt; { try { joinPoint.proceed(); System.out.println(\u0026#34;Executed in background: \u0026#34; + joinPoint.getSignature()); } catch (Throwable e) { e.printStackTrace(); } }); } } 32. 디버그 모드 활성화 (Debug Mode Toggle) 애플리케이션의 디버그 모드에서만 특정 로직을 실행합니다.\n구현 예제\n@Aspect @Component public class DebugModeAspect { private static final boolean DEBUG_MODE = true; // 설정에 따라 변경 가능 @Around(\u0026#34;@annotation(com.example.annotations.DebugOnly)\u0026#34;) public Object executeInDebugMode(ProceedingJoinPoint joinPoint) throws Throwable { if (DEBUG_MODE) { System.out.println(\u0026#34;Debug mode enabled for method: \u0026#34; + joinPoint.getSignature()); return joinPoint.proceed(); } else { System.out.println(\u0026#34;Debug mode skipped for method: \u0026#34; + joinPoint.getSignature()); return null; // 디버그 모드가 아니면 실행 생략 } } } 33. 캐시 삭제 후처리 (Post Cache Eviction Handling) 캐시 삭제 후 추가 작업을 처리합니다.\n구현 예제\n@Aspect @Component public class PostCacheEvictionAspect { @After(\u0026#34;@annotation(org.springframework.cache.annotation.CacheEvict)\u0026#34;) public void handleCacheEviction(JoinPoint joinPoint) { System.out.println(\u0026#34;Cache evicted for method: \u0026#34; + joinPoint.getSignature()); // 캐시 삭제 후 작업 (예: 로깅, 알림) } } 34. 데이터 통합 검증 (Unified Data Validation) 모든 데이터 입력에 대해 통합적으로 검증을 수행합니다.\n구현 예제\n@Aspect @Component public class UnifiedValidationAspect { @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void validateData(JoinPoint joinPoint) { for (Object arg : joinPoint.getArgs()) { if (!isValid(arg)) { throw new IllegalArgumentException(\u0026#34;Invalid argument: \u0026#34; + arg); } } System.out.println(\u0026#34;All arguments are valid for method: \u0026#34; + joinPoint.getSignature()); } private boolean isValid(Object arg) { // 데이터 유효성 검사 로직 return arg != null; // 예제용 } } 35. 조건부 트랜잭션 관리 (Conditional Transaction Management) 특정 조건에서만 트랜잭션을 활성화합니다.\n구현 예제\n@Aspect @Component public class ConditionalTransactionAspect { @Around(\u0026#34;@annotation(org.springframework.transaction.annotation.Transactional)\u0026#34;) public Object manageTransactionConditionally(ProceedingJoinPoint joinPoint) throws Throwable { if (shouldActivateTransaction()) { System.out.println(\u0026#34;Transaction started for: \u0026#34; + joinPoint.getSignature()); Object result = joinPoint.proceed(); System.out.println(\u0026#34;Transaction committed for: \u0026#34; + joinPoint.getSignature()); return result; } else { System.out.println(\u0026#34;Transaction skipped for: \u0026#34; + joinPoint.getSignature()); return joinPoint.proceed(); } } private boolean shouldActivateTransaction() { // 트랜잭션 활성화 조건 return true; // 예제용 } } 36. 데이터 변경 알림 (Change Notification) 특정 데이터가 변경되었을 때 관리자에게 알림을 전송합니다.\n구현 예제\n@Aspect @Component public class ChangeNotificationAspect { @AfterReturning(\u0026#34;@annotation(com.example.annotations.NotifyChange)\u0026#34;) public void notifyOnChange(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); System.out.println(\u0026#34;Data change detected in method: \u0026#34; + methodName); sendNotification(\u0026#34;Data has been changed in \u0026#34; + methodName); } private void sendNotification(String message) { // 이메일 또는 SMS 전송 로직 System.out.println(\u0026#34;Notification sent: \u0026#34; + message); } } 37. 캐시 프리로드 (Cache Preloading) 애플리케이션 시작 시 특정 데이터를 캐시에 미리 로드합니다.\n구현 예제\n@Aspect @Component public class CachePreloadingAspect { @PostConstruct // 애플리케이션 시작 시 호출 public void preloadCache() { System.out.println(\u0026#34;Preloading cache...\u0026#34;); // 캐시 초기화 로직 loadCache(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); loadCache(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;); } private void loadCache(String key, String value) { // 캐시에 데이터 로드 System.out.println(\u0026#34;Cached: \u0026#34; + key + \u0026#34; -\u0026gt; \u0026#34; + value); } } 38. 특정 메서드 비활성화 (Method Deactivation) 관리자가 지정한 메서드를 비활성화하여 호출되지 않도록 합니다.\n구현 예제\n@Aspect @Component public class MethodDeactivationAspect { private static final Set\u0026lt;String\u0026gt; deactivatedMethods = Set.of(\u0026#34;com.example.service.MyService.deactivatedMethod\u0026#34;); @Before(\u0026#34;execution(* com.example..*(..))\u0026#34;) public void blockDeactivatedMethods(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toString(); if (deactivatedMethods.contains(methodName)) { throw new RuntimeException(\u0026#34;Method \u0026#34; + methodName + \u0026#34; is currently deactivated\u0026#34;); } } } 39. API 요청 경로 추적 (Request Path Tracing) 모든 HTTP 요청의 경로를 추적하여 디버깅 정보를 출력합니다.\n구현 예제\n@Aspect @Component public class RequestPathTracingAspect { @Before(\u0026#34;execution(* org.springframework.web.bind.annotation.RestController..*(..))\u0026#34;) public void traceRequestPath(JoinPoint joinPoint) { String path = joinPoint.getSignature().toShortString(); System.out.println(\u0026#34;Request received for path: \u0026#34; + path); } } 40. 메서드 병렬 실행 (Parallel Execution) 특정 메서드를 병렬로 실행하여 성능을 높입니다.\n구현 예제\n@Aspect @Component public class ParallelExecutionAspect { private final ExecutorService executor = Executors.newFixedThreadPool(10); @Around(\u0026#34;@annotation(com.example.annotations.ParallelExecution)\u0026#34;) public Object executeInParallel(ProceedingJoinPoint joinPoint) { executor.submit(() -\u0026gt; { try { joinPoint.proceed(); System.out.println(\u0026#34;Executed in parallel: \u0026#34; + joinPoint.getSignature()); } catch (Throwable e) { e.printStackTrace(); } }); return null; // 병렬 실행이므로 결과를 즉시 반환 } } 41. 결과 데이터 포맷팅 (Result Formatting) 메서드 반환값을 JSON이나 XML 등 특정 형식으로 변환합니다.\n구현 예제\n@Aspect @Component public class ResultFormattingAspect { @AfterReturning(pointcut = \u0026#34;@annotation(com.example.annotations.FormatResult)\u0026#34;, returning = \u0026#34;result\u0026#34;) public Object formatResult(JoinPoint joinPoint, Object result) { if (result != null) { // JSON 형식으로 변환 String jsonResult = toJson(result); System.out.println(\u0026#34;Formatted result: \u0026#34; + jsonResult); return jsonResult; } return result; } private String toJson(Object result) { // 간단한 JSON 변환 로직 return \u0026#34;{\\\u0026#34;data\\\u0026#34;: \\\u0026#34;\u0026#34; + result.toString() + \u0026#34;\\\u0026#34;}\u0026#34;; } } 42. 실행 결과 캐싱 (Result Caching) 메서드 실행 결과를 캐싱하여 동일한 요청에 대해 재사용합니다.\n구현 예제\n@Aspect @Component public class ResultCachingAspect { private final Map\u0026lt;String, Object\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); @Around(\u0026#34;@annotation(com.example.annotations.Cacheable)\u0026#34;) public Object cacheResult(ProceedingJoinPoint joinPoint) throws Throwable { String key = generateCacheKey(joinPoint); if (cache.containsKey(key)) { System.out.println(\u0026#34;Cache hit for key: \u0026#34; + key); return cache.get(key); } Object result = joinPoint.proceed(); cache.put(key, result); System.out.println(\u0026#34;Cache saved for key: \u0026#34; + key); return result; } private String generateCacheKey(ProceedingJoinPoint joinPoint) { return joinPoint.getSignature().toString() + Arrays.toString(joinPoint.getArgs()); } } 43. 요청의 IP 블랙리스트 처리 (IP Blacklisting) 특정 IP 주소에서의 요청을 차단합니다.\n구현 예제\n@Aspect @Component public class IPBlacklistAspect { private static final Set\u0026lt;String\u0026gt; blacklistedIPs = Set.of(\u0026#34;192.168.0.1\u0026#34;, \u0026#34;10.0.0.1\u0026#34;); @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void blockBlacklistedIPs() { String clientIp = getClientIP(); if (blacklistedIPs.contains(clientIp)) { throw new RuntimeException(\u0026#34;Access denied for IP: \u0026#34; + clientIp); } System.out.println(\u0026#34;Access allowed for IP: \u0026#34; + clientIp); } private String getClientIP() { // 실제로 HttpServletRequest에서 IP를 가져오는 로직을 사용 return \u0026#34;192.168.0.1\u0026#34;; // 예제용 } } 44. 요청별 세션 데이터 초기화 (Session Initialization) HTTP 요청마다 세션 데이터를 초기화하거나 설정합니다.\n구현 예제\n@Aspect @Component public class SessionInitializationAspect { @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void initializeSessionData() { System.out.println(\u0026#34;Initializing session data...\u0026#34;); // 세션 데이터 초기화 로직 } } 45. 서비스 계층 장애 감지 (Service Failure Detection) 특정 서비스 계층에서의 장애 발생률을 모니터링하고 알림을 전송합니다.\n구현 예제\n@Aspect @Component public class FailureDetectionAspect { private final Map\u0026lt;String, Integer\u0026gt; failureCount = new HashMap\u0026lt;\u0026gt;(); private static final int FAILURE_THRESHOLD = 3; @AfterThrowing(pointcut = \u0026#34;execution(* com.example.service..*(..))\u0026#34;, throwing = \u0026#34;ex\u0026#34;) public void detectFailures(JoinPoint joinPoint, Throwable ex) { String methodName = joinPoint.getSignature().toString(); failureCount.put(methodName, failureCount.getOrDefault(methodName, 0) + 1); if (failureCount.get(methodName) \u0026gt;= FAILURE_THRESHOLD) { System.err.println(\u0026#34;Failure threshold exceeded for method: \u0026#34; + methodName); sendAlert(methodName); } } private void sendAlert(String methodName) { // 알림 전송 로직 (예: 이메일, Slack) System.out.println(\u0026#34;Alert sent for method: \u0026#34; + methodName); } } 여기에는 Spring AOP를 활용해 추가로 구현할 수 있는 더 많은 유용한 기능들을 소개합니다. 다양한 사례와 아이디어로 활용할 수 있습니다.\n46. 데이터베이스 페일오버 처리 (Database Failover Handling) 주 데이터베이스 장애 발생 시 대체 데이터베이스로 자동 전환.\n구현 예제\n@Aspect @Component public class DatabaseFailoverAspect { private boolean primaryDatabaseDown = false; @Around(\u0026#34;execution(* com.example.repository..*(..))\u0026#34;) public Object handleFailover(ProceedingJoinPoint joinPoint) throws Throwable { try { if (!primaryDatabaseDown) { System.out.println(\u0026#34;Using primary database...\u0026#34;); return joinPoint.proceed(); } } catch (Exception ex) { System.err.println(\u0026#34;Primary database failed. Switching to backup database...\u0026#34;); primaryDatabaseDown = true; return useBackupDatabase(joinPoint); } return useBackupDatabase(joinPoint); } private Object useBackupDatabase(ProceedingJoinPoint joinPoint) throws Throwable { // 여기서 backup 데이터베이스를 사용하는 로직 추가 System.out.println(\u0026#34;Executing with backup database\u0026#34;); return joinPoint.proceed(); // 예제에서는 그냥 진행 } } 47. 사용자 활동 기록 (User Activity Logging) 사용자가 수행한 모든 주요 작업을 기록합니다.\n구현 예제\n@Aspect @Component public class UserActivityLoggingAspect { @AfterReturning(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void logUserActivity(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); String userId = getCurrentUserId(); System.out.println(\u0026#34;User \u0026#34; + userId + \u0026#34; performed action: \u0026#34; + methodName); saveActivityToDatabase(userId, methodName); } private String getCurrentUserId() { // 보안 컨텍스트에서 현재 사용자 ID 가져오기 return \u0026#34;user123\u0026#34;; // 예제용 } private void saveActivityToDatabase(String userId, String action) { // 데이터베이스에 사용자 활동 저장 로직 System.out.println(\u0026#34;Activity saved: User=\u0026#34; + userId + \u0026#34;, Action=\u0026#34; + action); } } 48. API 응답 압축 (Response Compression) 컨트롤러의 모든 응답을 GZIP으로 압축하여 클라이언트로 전송합니다.\n구현 예제\n@Aspect @Component public class ResponseCompressionAspect { @Around(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public Object compressResponse(ProceedingJoinPoint joinPoint) throws Throwable { Object response = joinPoint.proceed(); if (response instanceof String) { String compressed = compress((String) response); System.out.println(\u0026#34;Response compressed\u0026#34;); return compressed; } return response; } private String compress(String data) { // 간단한 GZIP 압축 로직 return Base64.getEncoder().encodeToString(data.getBytes()); } } 49. 요청 프로파일링 (Request Profiling) 요청의 시작 시간, 끝 시간, 실행 시간 등을 기록하여 성능 분석.\n구현 예제\n@Aspect @Component public class RequestProfilingAspect { @Around(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public Object profileRequest(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object response = joinPoint.proceed(); long end = System.currentTimeMillis(); System.out.println(\u0026#34;Method \u0026#34; + joinPoint.getSignature() + \u0026#34; executed in \u0026#34; + (end - start) + \u0026#34; ms\u0026#34;); return response; } } 50. 서비스 호출 패턴 감지 (Service Call Pattern Detection) 특정 서비스가 지나치게 빈번히 호출되는 경우 경고.\n구현 예제\n@Aspect @Component public class ServiceCallPatternAspect { private final Map\u0026lt;String, Long\u0026gt; callTimestamps = new HashMap\u0026lt;\u0026gt;(); private static final long THRESHOLD = 1000; // 1초 이내 반복 호출 경고 @Before(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public void detectRapidCalls(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); long currentTime = System.currentTimeMillis(); if (callTimestamps.containsKey(methodName)) { long lastCall = callTimestamps.get(methodName); if (currentTime - lastCall \u0026lt; THRESHOLD) { System.err.println(\u0026#34;Warning: Method \u0026#34; + methodName + \u0026#34; is being called too frequently!\u0026#34;); } } callTimestamps.put(methodName, currentTime); } } 51. 테스트 환경 모드 처리 (Test Mode Handling) 테스트 환경에서는 특정 동작을 스킵하거나 대체 동작을 실행합니다.\n구현 예제\n@Aspect @Component public class TestModeAspect { private static final boolean TEST_MODE = true; @Around(\u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(com.example.annotations.TestModeOnly)\u0026#34;) public Object handleTestMode(ProceedingJoinPoint joinPoint) throws Throwable { if (TEST_MODE) { System.out.println(\u0026#34;Test mode active, skipping: \u0026#34; + joinPoint.getSignature()); return null; // 테스트 환경에서는 동작 생략 } return joinPoint.proceed(); } } 52. 서비스 사용량 제한 (Quota Management) 사용자가 지정된 서비스 사용량을 초과하지 않도록 제한합니다.\n구현 예제\n@Aspect @Component public class QuotaManagementAspect { private final Map\u0026lt;String, Integer\u0026gt; userQuotas = new HashMap\u0026lt;\u0026gt;(); private static final int MAX_QUOTA = 100; @Before(\u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(com.example.annotations.QuotaLimited)\u0026#34;) public void enforceQuota(JoinPoint joinPoint) { String userId = getCurrentUserId(); int currentQuota = userQuotas.getOrDefault(userId, 0); if (currentQuota \u0026gt;= MAX_QUOTA) { throw new RuntimeException(\u0026#34;Quota exceeded for user: \u0026#34; + userId); } userQuotas.put(userId, currentQuota + 1); System.out.println(\u0026#34;Quota used by \u0026#34; + userId + \u0026#34;: \u0026#34; + (currentQuota + 1)); } private String getCurrentUserId() { // 현재 사용자 ID 가져오기 로직 return \u0026#34;user123\u0026#34;; // 예제용 } } 53. 요청 실행 순서 추적 (Execution Order Tracking) 다단계 요청 실행 흐름을 추적하여 디버깅 정보를 제공합니다.\n구현 예제\n@Aspect @Component public class ExecutionOrderTrackingAspect { private int sequence = 0; @Before(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public void trackExecutionOrder(JoinPoint joinPoint) { sequence++; System.out.println(\u0026#34;Execution order \u0026#34; + sequence + \u0026#34;: \u0026#34; + joinPoint.getSignature()); } } 54. 비동기 오류 처리 (Async Error Handling) 비동기로 실행되는 메서드에서 발생하는 예외를 중앙에서 처리합니다.\n구현 예제\n@Aspect @Component public class AsyncErrorHandlingAspect { @AfterThrowing(pointcut = \u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(org.springframework.scheduling.annotation.Async)\u0026#34;, throwing = \u0026#34;ex\u0026#34;) public void handleAsyncError(JoinPoint joinPoint, Throwable ex) { System.err.println(\u0026#34;Async error in method: \u0026#34; + joinPoint.getSignature() + \u0026#34;, error: \u0026#34; + ex.getMessage()); sendErrorNotification(joinPoint.getSignature().toString(), ex); } private void sendErrorNotification(String method, Throwable ex) { // 오류 알림 로직 (예: 이메일, Slack) System.out.println(\u0026#34;Error notification sent for method: \u0026#34; + method); } } 55. 비밀 유지 계약(NDA) 로깅 특정 메서드가 호출될 때, 실행된 동작이 NDA(Non-Disclosure Agreement)에 따라 로그에 포함되지 않도록 처리.\n구현 예제\n@Aspect @Component public class NDALoggingAspect { @Around(\u0026#34;@annotation(com.example.annotations.NDAProtected)\u0026#34;) public Object handleNDALogging(ProceedingJoinPoint joinPoint) throws Throwable { try { System.out.println(\u0026#34;NDA-protected method called: \u0026#34; + joinPoint.getSignature()); return joinPoint.proceed(); } finally { System.out.println(\u0026#34;Execution of NDA-protected method completed. No details logged.\u0026#34;); } } } 56. 컨트롤러 입력값 스니핑 방지 (Input Sniffing Prevention) 사용자의 입력값에 악성 코드가 포함되어 있는지 탐지하고 차단합니다.\n구현 예제\n@Aspect @Component public class InputValidationAspect { @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void validateInput(JoinPoint joinPoint) { Object[] args = joinPoint.getArgs(); for (Object arg : args) { if (arg instanceof String \u0026amp;\u0026amp; containsMaliciousCode((String) arg)) { throw new IllegalArgumentException(\u0026#34;Malicious input detected: \u0026#34; + arg); } } } private boolean containsMaliciousCode(String input) { // 간단한 악성 코드 탐지 로직 return input.contains(\u0026#34;\u0026lt;script\u0026gt;\u0026#34;) || input.contains(\u0026#34;DROP TABLE\u0026#34;); } } 57. 애플리케이션 상태 체크 (Application Health Monitoring) 특정 메서드가 호출될 때 애플리케이션의 상태를 체크하고 필요시 알림을 전송.\n구현 예제\n@Aspect @Component public class ApplicationHealthAspect { @Before(\u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(com.example.annotations.HealthCheck)\u0026#34;) public void checkApplicationHealth() { if (!isApplicationHealthy()) { System.err.println(\u0026#34;Application health check failed!\u0026#34;); sendHealthAlert(); } else { System.out.println(\u0026#34;Application is healthy.\u0026#34;); } } private boolean isApplicationHealthy() { // 간단한 상태 체크 로직 (예: 메모리 사용량, 디스크 상태 등) return true; // 예제용 } private void sendHealthAlert() { // 건강 상태 알림 전송 로직 System.out.println(\u0026#34;Health alert sent to monitoring system.\u0026#34;); } } 58. 데이터 변경 감사 로그 작성 (Audit Logging with Details) 데이터베이스에서 데이터가 변경되었을 때 변경 전후의 값을 감사 로그로 작성.\n구현 예제\n@Aspect @Component public class AuditDetailAspect { @Around(\u0026#34;@annotation(com.example.annotations.AuditChanges)\u0026#34;) public Object logChanges(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Capturing audit log for method: \u0026#34; + joinPoint.getSignature()); Object[] args = joinPoint.getArgs(); // 변경 전 데이터 가져오기 Object beforeChange = fetchCurrentData(args); Object result = joinPoint.proceed(); // 변경 후 데이터 가져오기 Object afterChange = fetchCurrentData(args); // 감사 로그 작성 logAuditDetails(beforeChange, afterChange); return result; } private Object fetchCurrentData(Object[] args) { // 현재 데이터를 가져오는 로직 (예: ID로 조회) return \u0026#34;Sample Data\u0026#34;; // 예제용 } private void logAuditDetails(Object before, Object after) { System.out.println(\u0026#34;Audit Log -\u0026gt; Before: \u0026#34; + before + \u0026#34;, After: \u0026#34; + after); } } 59. 외부 API 호출 자동 재시도 (External API Retry Mechanism) 외부 API 호출이 실패할 경우 일정 횟수까지 재시도합니다.\n구현 예제\n@Aspect @Component public class ExternalAPIRetryAspect { @Around(\u0026#34;@annotation(com.example.annotations.RetryOnFailure)\u0026#34;) public Object retryAPIRequest(ProceedingJoinPoint joinPoint) throws Throwable { int maxRetries = 3; int attempts = 0; while (true) { try { return joinPoint.proceed(); } catch (Exception ex) { attempts++; System.err.println(\u0026#34;API call failed. Attempt \u0026#34; + attempts); if (attempts \u0026gt;= maxRetries) { throw ex; } } } } } 60. 비밀번호 유효성 검사 (Password Strength Validation) 사용자가 입력한 비밀번호가 규칙에 맞는지 검증.\n구현 예제\n@Aspect @Component public class PasswordValidationAspect { @Before(\u0026#34;@annotation(com.example.annotations.ValidatePassword)\u0026#34;) public void validatePassword(JoinPoint joinPoint) { Object[] args = joinPoint.getArgs(); for (Object arg : args) { if (arg instanceof String \u0026amp;\u0026amp; !isValidPassword((String) arg)) { throw new IllegalArgumentException(\u0026#34;Invalid password: \u0026#34; + arg); } } } private boolean isValidPassword(String password) { // 비밀번호 강도 검사 (예: 최소 길이, 특수 문자 포함 여부 등) return password.length() \u0026gt;= 8 \u0026amp;\u0026amp; password.matches(\u0026#34;.*[!@#$%^\u0026amp;*()].*\u0026#34;); } } 61. 지연 초기화 (Lazy Initialization) 특정 메서드의 결과를 최초 호출 시 초기화하고 캐싱하여 재사용.\n구현 예제\n@Aspect @Component public class LazyInitializationAspect { private final Map\u0026lt;String, Object\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); @Around(\u0026#34;@annotation(com.example.annotations.LazyInit)\u0026#34;) public Object handleLazyInit(ProceedingJoinPoint joinPoint) throws Throwable { String key = joinPoint.getSignature().toString(); if (cache.containsKey(key)) { System.out.println(\u0026#34;Returning cached result for: \u0026#34; + key); return cache.get(key); } Object result = joinPoint.proceed(); cache.put(key, result); System.out.println(\u0026#34;Result cached for: \u0026#34; + key); return result; } } 62. 사용자 시간대 기반 데이터 처리 (Time Zone Based Processing) 사용자의 시간대에 맞춰 데이터를 처리.\n구현 예제\n@Aspect @Component public class TimeZoneProcessingAspect { @Around(\u0026#34;@annotation(com.example.annotations.TimeZoneAware)\u0026#34;) public Object adjustForTimeZone(ProceedingJoinPoint joinPoint) throws Throwable { String userTimeZone = getUserTimeZone(); System.out.println(\u0026#34;Adjusting data for user time zone: \u0026#34; + userTimeZone); // 시간대 조정 로직 Object result = joinPoint.proceed(); return adjustResultForTimeZone(result, userTimeZone); } private String getUserTimeZone() { // 사용자의 시간대 가져오는 로직 (예: 요청 헤더에서 추출) return \u0026#34;Asia/Seoul\u0026#34;; // 예제용 } private Object adjustResultForTimeZone(Object result, String timeZone) { // 시간대에 맞게 데이터를 조정하는 로직 return result; // 예제용 } } 63. API 요청별 실행 우선순위 처리 (Priority-Based Execution) API 요청에 우선순위를 부여하여 중요한 요청을 먼저 처리.\n구현 예제\n@Aspect @Component public class PriorityExecutionAspect { @Around(\u0026#34;@annotation(com.example.annotations.Priority)\u0026#34;) public Object prioritizeRequest(ProceedingJoinPoint joinPoint) throws Throwable { String priority = getPriorityFromRequest(); System.out.println(\u0026#34;Handling request with priority: \u0026#34; + priority); // 우선순위에 따라 처리 로직 추가 return joinPoint.proceed(); } private String getPriorityFromRequest() { // 요청에서 우선순위를 추출 (예: 요청 헤더 또는 파라미터) return \u0026#34;HIGH\u0026#34;; // 예제용 } } 64. 요청 응답 시간 로깅 (Request-Response Time Logging) 요청 처리의 전체 시간을 측정하고 로깅.\n구현 예제\n@Aspect @Component public class RequestResponseTimeAspect { @Around(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public Object logRequestResponseTime(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); System.out.println(\u0026#34;Request to \u0026#34; + joinPoint.getSignature() + \u0026#34; completed in \u0026#34; + (end - start) + \u0026#34; ms\u0026#34;); return result; } } 65. API 요청 크기 제한 (Request Size Limiting) API 요청의 데이터 크기를 제한하여 과도한 데이터 전송 방지.\n구현 예제\n@Aspect @Component public class RequestSizeLimitingAspect { private static final int MAX_SIZE = 1024 * 1024; // 1MB @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void limitRequestSize(JoinPoint joinPoint) { for (Object arg : joinPoint.getArgs()) { if (arg instanceof String \u0026amp;\u0026amp; ((String) arg).length() \u0026gt; MAX_SIZE) { throw new IllegalArgumentException(\u0026#34;Request size exceeds the allowed limit.\u0026#34;); } } } } 66. 요청 리플레이 방지 (Request Replay Protection) 특정 요청이 중복해서 처리되지 않도록 방지.\n구현 예제\n@Aspect @Component public class ReplayProtectionAspect { private final Set\u0026lt;String\u0026gt; processedRequests = Collections.synchronizedSet(new HashSet\u0026lt;\u0026gt;()); @Before(\u0026#34;@annotation(com.example.annotations.ReplayProtected)\u0026#34;) public void preventReplay(JoinPoint joinPoint) { String requestId = extractRequestId(); if (processedRequests.contains(requestId)) { throw new IllegalStateException(\u0026#34;Duplicate request detected: \u0026#34; + requestId); } processedRequests.add(requestId); } private String extractRequestId() { // 요청 ID 추출 로직 (예: 헤더에서 가져오기) return UUID.randomUUID().toString(); // 예제용 } } 67. 사용자별 데이터 처리 속도 제한 (Rate Limit per User) 사용자별 데이터 처리 속도를 제한.\n구현 예제\n@Aspect @Component public class UserRateLimitAspect { private final Map\u0026lt;String, Long\u0026gt; userLastRequestTime = new ConcurrentHashMap\u0026lt;\u0026gt;(); private static final long MIN_INTERVAL = 2000; // 2초 간격 @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void enforceUserRateLimit() { String userId = getCurrentUserId(); long now = System.currentTimeMillis(); if (userLastRequestTime.containsKey(userId)) { long lastRequestTime = userLastRequestTime.get(userId); if (now - lastRequestTime \u0026lt; MIN_INTERVAL) { throw new RuntimeException(\u0026#34;User \u0026#34; + userId + \u0026#34; is sending requests too quickly.\u0026#34;); } } userLastRequestTime.put(userId, now); } private String getCurrentUserId() { // 사용자 ID 가져오기 로직 return \u0026#34;user123\u0026#34;; // 예제용 } } 68. 메서드 호출 통계 (Method Invocation Statistics) 특정 메서드가 얼마나 자주 호출되는지 기록하고 분석.\n구현 예제\n@Aspect @Component public class MethodInvocationStatisticsAspect { private final Map\u0026lt;String, Integer\u0026gt; methodCallCounts = new ConcurrentHashMap\u0026lt;\u0026gt;(); @After(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public void trackMethodCalls(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); methodCallCounts.put(methodName, methodCallCounts.getOrDefault(methodName, 0) + 1); System.out.println(\u0026#34;Method \u0026#34; + methodName + \u0026#34; has been called \u0026#34; + methodCallCounts.get(methodName) + \u0026#34; times.\u0026#34;); } } 69. 특정 필드 제거 후 로깅 (Exclude Sensitive Fields) 로그 출력 시 민감한 데이터를 제거합니다.\n구현 예제\n@Aspect @Component public class SensitiveFieldRemovalAspect { @Around(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public Object removeSensitiveFieldsFromLog(ProceedingJoinPoint joinPoint) throws Throwable { Object result = joinPoint.proceed(); if (result instanceof Map) { Map\u0026lt;String, Object\u0026gt; data = (Map\u0026lt;String, Object\u0026gt;) result; data.remove(\u0026#34;password\u0026#34;); data.remove(\u0026#34;creditCardNumber\u0026#34;); } return result; } } 70. API 사용량 모니터링 (API Usage Monitoring) API 호출 사용량을 추적하여 과도한 요청에 대한 경고를 제공합니다.\n구현 예제\n@Aspect @Component public class ApiUsageMonitoringAspect { private final Map\u0026lt;String, Integer\u0026gt; apiUsageCounts = new ConcurrentHashMap\u0026lt;\u0026gt;(); private static final int MAX_USAGE_LIMIT = 100; @After(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void monitorApiUsage(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().toShortString(); apiUsageCounts.put(methodName, apiUsageCounts.getOrDefault(methodName, 0) + 1); if (apiUsageCounts.get(methodName) \u0026gt; MAX_USAGE_LIMIT) { System.err.println(\u0026#34;Warning: API usage limit exceeded for \u0026#34; + methodName); } } } 71. 요청 응답 디버깅 (Request-Response Debugging) 요청 및 응답 데이터를 캡처하고 디버깅 로그를 출력.\n구현 예제\n@Aspect @Component public class RequestResponseDebuggingAspect { @Around(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public Object logRequestAndResponse(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Request to: \u0026#34; + joinPoint.getSignature()); System.out.println(\u0026#34;Arguments: \u0026#34; + Arrays.toString(joinPoint.getArgs())); Object response = joinPoint.proceed(); System.out.println(\u0026#34;Response from: \u0026#34; + joinPoint.getSignature()); System.out.println(\u0026#34;Response Data: \u0026#34; + response); return response; } } 72. 오래 실행되는 요청 탐지 (Long-Running Request Detection) 특정 시간 이상 실행되는 요청을 탐지하여 경고.\n구현 예제\n@Aspect @Component public class LongRunningRequestAspect { private static final long WARNING_THRESHOLD = 3000; // 3초 @Around(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public Object detectLongRunningRequests(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long duration = System.currentTimeMillis() - start; if (duration \u0026gt; WARNING_THRESHOLD) { System.err.println(\u0026#34;Warning: Long-running request detected in \u0026#34; + joinPoint.getSignature() + \u0026#34; (Duration: \u0026#34; + duration + \u0026#34; ms)\u0026#34;); } return result; } } 73. 메서드 실행 제한 시간 초과 경고 (Timeout Warning) 특정 메서드가 지정된 시간 내에 완료되지 않으면 경고를 출력.\n구현 예제\n@Aspect @Component public class MethodTimeoutWarningAspect { private static final long TIMEOUT_THRESHOLD = 2000; // 2초 @Around(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public Object monitorMethodTimeout(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long duration = System.currentTimeMillis() - start; if (duration \u0026gt; TIMEOUT_THRESHOLD) { System.err.println(\u0026#34;Warning: Method \u0026#34; + joinPoint.getSignature() + \u0026#34; took too long (\u0026#34; + duration + \u0026#34; ms)\u0026#34;); } return result; } } 74. 데이터 사본 생성 및 복원 (Backup and Restore Data) 데이터 변경 작업 전에 사본을 생성하고, 실패 시 복원.\n구현 예제\n@Aspect @Component public class DataBackupAspect { private final Map\u0026lt;String, Object\u0026gt; backupData = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Around(\u0026#34;@annotation(com.example.annotations.BackupRestore)\u0026#34;) public Object handleBackupAndRestore(ProceedingJoinPoint joinPoint) throws Throwable { String key = joinPoint.getSignature().toString(); try { backupData.put(key, createBackup()); return joinPoint.proceed(); } catch (Exception ex) { restoreBackup(key); throw ex; } } private Object createBackup() { // 데이터 백업 로직 System.out.println(\u0026#34;Backup created\u0026#34;); return \u0026#34;BackupData\u0026#34;; // 예제용 } private void restoreBackup(String key) { // 데이터 복원 로직 System.out.println(\u0026#34;Restoring backup for key: \u0026#34; + key); } } 75. HTTP 요청의 헤더 검증 (Request Header Validation) HTTP 요청 헤더에 필수 정보가 포함되어 있는지 검증.\n구현 예제\n@Aspect @Component public class RequestHeaderValidationAspect { @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void validateHeaders() { String requiredHeader = getHeader(\u0026#34;X-Required-Header\u0026#34;); if (requiredHeader == null || requiredHeader.isEmpty()) { throw new IllegalArgumentException(\u0026#34;Missing required header: X-Required-Header\u0026#34;); } } private String getHeader(String headerName) { // 요청 헤더 가져오기 (HttpServletRequest에서) return \u0026#34;ValidHeader\u0026#34;; // 예제용 } } 76. 데이터 일관성 확인 (Data Consistency Check) 메서드 호출 후 데이터베이스의 상태를 확인하여 데이터 일관성을 유지.\n구현 예제\n@Aspect @Component public class DataConsistencyAspect { @After(\u0026#34;execution(* com.example.repository..*(..))\u0026#34;) public void checkDataConsistency() { if (!isDataConsistent()) { System.err.println(\u0026#34;Data inconsistency detected!\u0026#34;); handleInconsistency(); } } private boolean isDataConsistent() { // 데이터 일관성 확인 로직 return true; // 예제용 } private void handleInconsistency() { // 데이터 불일치 처리 로직 System.out.println(\u0026#34;Handling data inconsistency...\u0026#34;); } } 77. 동적 기능 활성화 (Dynamic Feature Toggle) 외부 설정값에 따라 메서드 실행 여부를 동적으로 제어.\n구현 예제\n@Aspect @Component public class FeatureToggleAspect { @Around(\u0026#34;@annotation(com.example.annotations.FeatureToggle)\u0026#34;) public Object handleFeatureToggle(ProceedingJoinPoint joinPoint) throws Throwable { String featureName = getFeatureName(joinPoint); if (isFeatureEnabled(featureName)) { System.out.println(\u0026#34;Feature \u0026#34; + featureName + \u0026#34; is enabled\u0026#34;); return joinPoint.proceed(); } else { System.out.println(\u0026#34;Feature \u0026#34; + featureName + \u0026#34; is disabled\u0026#34;); return null; } } private String getFeatureName(ProceedingJoinPoint joinPoint) { // 어노테이션에서 기능 이름 추출 return \u0026#34;NewFeature\u0026#34;; // 예제용 } private boolean isFeatureEnabled(String featureName) { // 외부 설정값으로 기능 활성화 여부 결정 return true; // 예제용 } } 78. API 응답 캐시 무효화 (Invalidate Cache on Response) 특정 조건에서 API 응답 캐시를 무효화.\n구현 예제\n@Aspect @Component public class CacheInvalidationAspect { @After(\u0026#34;@annotation(com.example.annotations.InvalidateCache)\u0026#34;) public void invalidateCache() { System.out.println(\u0026#34;Invalidating cache for the current operation...\u0026#34;); // 캐시 무효화 로직 } } 79. 메서드 호출 흐름 추적 (Call Flow Tracing) 메서드 호출 흐름을 추적하여 디버깅.\n구현 예제\n@Aspect @Component public class CallFlowTracingAspect { private final ThreadLocal\u0026lt;Stack\u0026lt;String\u0026gt;\u0026gt; callStack = ThreadLocal.withInitial(Stack::new); @Before(\u0026#34;execution(* com.example..*(..))\u0026#34;) public void beforeMethod(JoinPoint joinPoint) { callStack.get().push(joinPoint.getSignature().toShortString()); System.out.println(\u0026#34;Entering: \u0026#34; + joinPoint.getSignature()); } @After(\u0026#34;execution(* com.example..*(..))\u0026#34;) public void afterMethod(JoinPoint joinPoint) { System.out.println(\u0026#34;Exiting: \u0026#34; + callStack.get().pop()); } } 80. 트랜잭션 롤백 후 처리 (Post Rollback Handling) 트랜잭션이 롤백된 후 추가 작업을 수행.\n구현 예제\n@Aspect @Component public class RollbackHandlingAspect { @AfterThrowing(pointcut = \u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(org.springframework.transaction.annotation.Transactional)\u0026#34;, throwing = \u0026#34;ex\u0026#34;) public void handleRollback(Throwable ex) { System.err.println(\u0026#34;Transaction rolled back due to: \u0026#34; + ex.getMessage()); // 롤백 후 작업 (예: 알림 전송, 복구 작업) } } 81. 사용자 활동의 세부 로그 생성 (Detailed User Activity Logging) 사용자가 수행한 작업의 세부 로그를 생성하여 분석.\n구현 예제\n@Aspect @Component public class DetailedUserActivityAspect { @After(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void logDetailedUserActivity(JoinPoint joinPoint) { String userId = getCurrentUserId(); String methodName = joinPoint.getSignature().toShortString(); System.out.println(\u0026#34;User \u0026#34; + userId + \u0026#34; accessed \u0026#34; + methodName); saveDetailedActivityLog(userId, methodName); } private void saveDetailedActivityLog(String userId, String action) { // 사용자 활동 로그 저장 로직 System.out.println(\u0026#34;Activity saved: User=\u0026#34; + userId + \u0026#34;, Action=\u0026#34; + action); } private String getCurrentUserId() { return \u0026#34;user123\u0026#34;; // 예제용 } } 82. 글로벌 메서드 실행 모니터링 (Global Method Execution Monitoring) 애플리케이션 내에서 모든 메서드 실행을 모니터링하여 통계 생성.\n구현 예제\n@Aspect @Component public class GlobalMethodMonitoringAspect { private final Map\u0026lt;String, Long\u0026gt; executionCounts = new ConcurrentHashMap\u0026lt;\u0026gt;(); private final Map\u0026lt;String, Long\u0026gt; executionDurations = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Around(\u0026#34;execution(* com.example..*(..))\u0026#34;) public Object monitorMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable { String methodName = joinPoint.getSignature().toShortString(); long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long duration = System.currentTimeMillis() - start; executionCounts.put(methodName, executionCounts.getOrDefault(methodName, 0L) + 1); executionDurations.put(methodName, executionDurations.getOrDefault(methodName, 0L) + duration); System.out.println(\u0026#34;Executed \u0026#34; + methodName + \u0026#34; in \u0026#34; + duration + \u0026#34; ms\u0026#34;); return result; } public void printStatistics() { executionCounts.forEach((method, count) -\u0026gt; { long totalDuration = executionDurations.get(method); System.out.println(\u0026#34;Method: \u0026#34; + method + \u0026#34;, Count: \u0026#34; + count + \u0026#34;, Avg Time: \u0026#34; + (totalDuration / count) + \u0026#34; ms\u0026#34;); }); } } 83. 비동기 메서드 병렬 실행 제한 (Async Method Parallel Execution Limit) 비동기로 실행되는 메서드의 병렬 실행 개수를 제한.\n구현 예제\n@Aspect @Component public class AsyncParallelExecutionLimitAspect { private final Semaphore semaphore = new Semaphore(5); // 최대 병렬 실행 개수 제한 @Around(\u0026#34;@annotation(org.springframework.scheduling.annotation.Async)\u0026#34;) public Object limitAsyncExecution(ProceedingJoinPoint joinPoint) throws Throwable { if (!semaphore.tryAcquire()) { throw new RuntimeException(\u0026#34;Too many parallel executions. Try again later.\u0026#34;); } try { return joinPoint.proceed(); } finally { semaphore.release(); } } } 84. 동적 서비스 변경 (Dynamic Service Switching) 특정 조건에 따라 서비스 인스턴스를 동적으로 변경.\n구현 예제\n@Aspect @Component public class DynamicServiceSwitchingAspect { @Around(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public Object switchService(ProceedingJoinPoint joinPoint) throws Throwable { if (shouldUseAlternativeService()) { System.out.println(\u0026#34;Using alternative service for: \u0026#34; + joinPoint.getSignature()); return useAlternativeService(joinPoint); } return joinPoint.proceed(); } private boolean shouldUseAlternativeService() { // 서비스 변경 조건 return Math.random() \u0026gt; 0.5; // 예제용 } private Object useAlternativeService(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Alternative service logic executed.\u0026#34;); // 실제로 대체 서비스 호출 로직 작성 return null; // 예제용 } } 85. 데이터 조회 실패 대체 데이터 제공 (Fallback Data Provider) 데이터 조회 실패 시 기본값 또는 캐시 데이터를 제공.\n구현 예제\n@Aspect @Component public class FallbackDataAspect { @Around(\u0026#34;execution(* com.example.repository..*(..))\u0026#34;) public Object provideFallbackData(ProceedingJoinPoint joinPoint) throws Throwable { try { return joinPoint.proceed(); } catch (Exception ex) { System.err.println(\u0026#34;Failed to fetch data. Providing fallback.\u0026#34;); return getFallbackData(joinPoint); } } private Object getFallbackData(ProceedingJoinPoint joinPoint) { // 대체 데이터 제공 로직 return \u0026#34;FallbackData\u0026#34;; // 예제용 } } 86. 사용자 지정 요청 추적 ID 생성 (Custom Request Trace ID) 각 요청에 고유한 추적 ID를 생성하여 로깅과 디버깅에 활용.\n구현 예제\n@Aspect @Component public class RequestTraceIdAspect { private final ThreadLocal\u0026lt;String\u0026gt; traceId = new ThreadLocal\u0026lt;\u0026gt;(); @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void generateTraceId() { traceId.set(UUID.randomUUID().toString()); System.out.println(\u0026#34;Generated Trace ID: \u0026#34; + traceId.get()); } @After(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void clearTraceId() { System.out.println(\u0026#34;Clearing Trace ID: \u0026#34; + traceId.get()); traceId.remove(); } public String getTraceId() { return traceId.get(); } } 87. 사용자 세션 기반 접근 제어 (Session-Based Access Control) 사용자 세션 상태에 따라 특정 API 접근을 제한.\n구현 예제\n@Aspect @Component public class SessionAccessControlAspect { @Before(\u0026#34;@annotation(com.example.annotations.SessionRestricted)\u0026#34;) public void restrictAccessBasedOnSession() { if (!isSessionActive()) { throw new IllegalStateException(\u0026#34;User session is not active.\u0026#34;); } } private boolean isSessionActive() { // 세션 상태 확인 로직 return true; // 예제용 } } 88. 캐시 업데이트 시 알림 전송 (Notify on Cache Update) 캐시가 업데이트될 때 관리자나 모니터링 시스템에 알림을 전송.\n구현 예제\n@Aspect @Component public class CacheUpdateNotificationAspect { @After(\u0026#34;@annotation(org.springframework.cache.annotation.CachePut)\u0026#34;) public void notifyCacheUpdate() { System.out.println(\u0026#34;Cache updated. Sending notification...\u0026#34;); sendCacheUpdateNotification(); } private void sendCacheUpdateNotification() { // 알림 전송 로직 (예: 이메일, 슬랙) System.out.println(\u0026#34;Notification sent.\u0026#34;); } } 89. 사용자별 트랜잭션 추적 (User-Specific Transaction Tracking) 각 사용자별로 트랜잭션 실행 내역을 추적.\n구현 예제\n@Aspect @Component public class UserTransactionTrackingAspect { @AfterReturning(\u0026#34;@annotation(org.springframework.transaction.annotation.Transactional)\u0026#34;) public void trackTransaction(JoinPoint joinPoint) { String userId = getCurrentUserId(); String methodName = joinPoint.getSignature().toShortString(); System.out.println(\u0026#34;Transaction completed by user: \u0026#34; + userId + \u0026#34; on method: \u0026#34; + methodName); saveTransactionLog(userId, methodName); } private String getCurrentUserId() { // 사용자 ID 가져오기 로직 return \u0026#34;user123\u0026#34;; // 예제용 } private void saveTransactionLog(String userId, String methodName) { // 트랜잭션 로그 저장 System.out.println(\u0026#34;Transaction log saved for user: \u0026#34; + userId + \u0026#34;, method: \u0026#34; + methodName); } } 90. 커스텀 메서드 리턴값 변환 (Custom Return Value Transformation) 특정 메서드의 반환값을 동적으로 변환.\n구현 예제\n@Aspect @Component public class ReturnValueTransformationAspect { @AfterReturning(pointcut = \u0026#34;execution(* com.example.service..*(..))\u0026#34;, returning = \u0026#34;result\u0026#34;) public Object transformReturnValue(JoinPoint joinPoint, Object result) { if (result instanceof String) { return ((String) result).toUpperCase(); } return result; } } 91. 조건부 로깅 (Conditional Logging) 특정 조건을 만족할 때만 메서드 실행을 로깅합니다.\n구현 예제\n@Aspect @Component public class ConditionalLoggingAspect { @Around(\u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(com.example.annotations.ConditionalLog)\u0026#34;) public Object logConditionally(ProceedingJoinPoint joinPoint) throws Throwable { if (shouldLog(joinPoint)) { System.out.println(\u0026#34;Executing method: \u0026#34; + joinPoint.getSignature()); } return joinPoint.proceed(); } private boolean shouldLog(ProceedingJoinPoint joinPoint) { // 조건 정의 (예: 특정 파라미터 값, 현재 환경 등) return true; // 예제에서는 항상 로깅 } } 92. 데이터 입력 이력 관리 (Data Input History Tracking) 모든 데이터 입력 내역을 저장하여 추적 가능하도록 만듭니다.\n구현 예제\n@Aspect @Component public class DataInputHistoryAspect { @After(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public void trackInputHistory(JoinPoint joinPoint) { Object[] args = joinPoint.getArgs(); for (Object arg : args) { saveInputHistory(arg); } } private void saveInputHistory(Object input) { // 데이터 입력 이력 저장 로직 System.out.println(\u0026#34;Input history saved: \u0026#34; + input); } } 93. 메서드 호출 순서 보장 (Ensure Method Invocation Order) 특정 메서드 호출 순서를 보장하여 의도한 흐름을 유지합니다.\n구현 예제\n@Aspect @Component public class MethodInvocationOrderAspect { private final Queue\u0026lt;String\u0026gt; expectedOrder = new LinkedList\u0026lt;\u0026gt;(List.of( \u0026#34;firstMethod\u0026#34;, \u0026#34;secondMethod\u0026#34;, \u0026#34;thirdMethod\u0026#34; )); @Before(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public void ensureOrder(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); if (!expectedOrder.isEmpty() \u0026amp;\u0026amp; !expectedOrder.peek().equals(methodName)) { throw new IllegalStateException(\u0026#34;Method \u0026#34; + methodName + \u0026#34; called out of order.\u0026#34;); } expectedOrder.poll(); } } 94. 특정 파라미터 기반 접근 제어 (Parameter-Based Access Control) 메서드 파라미터 값에 따라 실행 여부를 제어.\n구현 예제\n@Aspect @Component public class ParameterBasedAccessControlAspect { @Before(\u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; args(param,..)\u0026#34;) public void restrictAccess(Object param) { if (!hasAccess(param)) { throw new SecurityException(\u0026#34;Access denied for parameter: \u0026#34; + param); } } private boolean hasAccess(Object param) { // 접근 권한 확인 로직 (예: 특정 값 허용 여부) return !\u0026#34;restricted\u0026#34;.equals(param); } } 95. 요청 데이터 변환 (Request Data Transformation) 요청 데이터를 변환하여 메서드가 처리하기 쉽게 조정.\n구현 예제\n@Aspect @Component public class RequestDataTransformationAspect { @Around(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public Object transformRequestData(ProceedingJoinPoint joinPoint) throws Throwable { Object[] args = joinPoint.getArgs(); for (int i = 0; i \u0026lt; args.length; i++) { if (args[i] instanceof String) { args[i] = preprocessData((String) args[i]); } } return joinPoint.proceed(args); } private String preprocessData(String data) { // 데이터 전처리 로직 (예: 대문자 변환) return data.trim().toUpperCase(); } } 96. 트랜잭션 내 특정 작업 감시 (Monitor Specific Actions in Transactions) 트랜잭션 내부에서 특정 작업이 발생하는지 모니터링.\n구현 예제\n@Aspect @Component public class TransactionMonitoringAspect { @Around(\u0026#34;@annotation(org.springframework.transaction.annotation.Transactional)\u0026#34;) public Object monitorTransaction(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Transaction started: \u0026#34; + joinPoint.getSignature()); try { return joinPoint.proceed(); } finally { System.out.println(\u0026#34;Transaction completed: \u0026#34; + joinPoint.getSignature()); } } } 97. 동적 메서드 실행 제한 (Dynamic Execution Blocking) 환경이나 조건에 따라 메서드 실행을 차단.\n구현 예제\n@Aspect @Component public class DynamicExecutionBlockingAspect { @Before(\u0026#34;execution(* com.example.service..*(..)) \u0026amp;\u0026amp; @annotation(com.example.annotations.DynamicBlock)\u0026#34;) public void blockExecution(JoinPoint joinPoint) { if (shouldBlockExecution()) { throw new IllegalStateException(\u0026#34;Method execution blocked: \u0026#34; + joinPoint.getSignature()); } } private boolean shouldBlockExecution() { // 차단 조건 (예: 특정 환경, 설정값 등) return false; // 예제에서는 차단하지 않음 } } 98. HTTP 응답 데이터 필터링 (Response Data Filtering) API 응답에서 민감한 정보를 필터링.\n구현 예제\n@Aspect @Component public class ResponseDataFilteringAspect { @Around(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public Object filterResponseData(ProceedingJoinPoint joinPoint) throws Throwable { Object response = joinPoint.proceed(); if (response instanceof Map) { Map\u0026lt;String, Object\u0026gt; data = (Map\u0026lt;String, Object\u0026gt;) response; data.remove(\u0026#34;password\u0026#34;); data.remove(\u0026#34;ssn\u0026#34;); // 민감 데이터 제거 } return response; } } 99. 대규모 데이터 처리 모니터링 (Large Data Processing Monitoring) 대규모 데이터 처리 시 성능을 추적하고 경고.\n구현 예제\n@Aspect @Component public class LargeDataProcessingMonitoringAspect { private static final int LARGE_DATA_THRESHOLD = 1000; @Around(\u0026#34;execution(* com.example.service..*(..))\u0026#34;) public Object monitorLargeDataProcessing(ProceedingJoinPoint joinPoint) throws Throwable { Object[] args = joinPoint.getArgs(); for (Object arg : args) { if (arg instanceof List \u0026amp;\u0026amp; ((List\u0026lt;?\u0026gt;) arg).size() \u0026gt; LARGE_DATA_THRESHOLD) { System.err.println(\u0026#34;Warning: Large data processing detected in method: \u0026#34; + joinPoint.getSignature()); } } return joinPoint.proceed(); } } 100. 요청 ID 전파 (Request ID Propagation) 요청 ID를 메서드 호출 체인 전반에 전파하여 추적 가능.\n구현 예제\n@Aspect @Component public class RequestIdPropagationAspect { private static final ThreadLocal\u0026lt;String\u0026gt; requestId = ThreadLocal.withInitial(() -\u0026gt; UUID.randomUUID().toString()); @Before(\u0026#34;execution(* com.example.controller..*(..))\u0026#34;) public void propagateRequestId() { System.out.println(\u0026#34;Propagating Request ID: \u0026#34; + requestId.get()); } public static String getRequestId() { return requestId.get(); } } ","date":"2024-12-20","permalink":"/post/2024/2024-12-20_usefull_aop/","section":"post","summary":"Aspect-Oriented Programming(AOP)은 Spring에서 횡단 관심사를 처리하기 위한 강력한 도구입니다.\n","title":"유용한 Aspect-Oriented Programming(AOP) 모음"},{"content":"이 문서는 Spring Boot 애플리케이션에서 자주 사용되는 애노테이션의 목록입니다.\n자세하고 포괄적인 정보는 공식 Javadocs 및 문서를 참조하십시오.\n핵심 스프링 @Bean - 애노테이션이 붙은 메서드는 Spring IoC 컨테이너에 의해 관리되는 빈을 생성합니다. @Primary - 후보가 여러 개인 경우 Bean에 우선권을 부여해야 함을 나타냅니다. 단일 값 종속성을 autowire할 수 있습니다. 스테레오타입 애노테이션 @Component - 애노테이션이 붙은 클래스를 컴포넌트 스캐닝에 의해 발견되고 애플리케이션 컨텍스트에 로드되는 빈으로 표시합니다. @Controller - 애노테이션이 붙은 클래스를 Spring MVC의 요청 핸들러를 포함하는 빈으로 표시합니다. @RestController - 애노테이션이 붙은 클래스를 @Controller 빈으로 표시하고 반환된 결과를 메시지로 직렬화하기 위해 @ResponseBody를 추가합니다. @Configuration - 애노테이션이 붙은 클래스를 자바 설정으로 표시하여 빈을 정의합니다. @Service - 애노테이션이 붙은 클래스를 빈으로 표시합니다(관례상 비즈니스 로직을 포함하는 경우가 많습니다). @Repository - 애노테이션이 붙은 클래스를 빈으로 표시하고(관례상 데이터 접근을 제공하는 경우가 많습니다) SQLException을 DataAccessExceptions로 자동 변환합니다. 빈 상태 @PostConstruct - 의존성 주입이 완료된 후 초기화를 수행하기 위해 애노테이션이 붙은 메서드를 실행합니다. @PreDestroy - 빈이 파괴되기 전에 애노테이션이 붙은 메서드를 실행합니다(예: 종료 시). 설정 @Import - 하나 이상의 자바 설정 클래스 @Configuration를 가져옵니다. @PropertySource - application.properties 파일의 위치를 지정하여 키-값 쌍을 Spring Environment에 추가합니다. @Value - 애노테이션이 붙은 필드와 매개변수 값이 주입됩니다. @ComponentScan - 컴포넌트 스캐닝을 구성합니다(@Component, @Service 등). 빈 속성 @Lazy - 애노테이션이 붙은 빈은 첫 사용 시 지연 초기화됩니다. @Profile - 정의된 프로필이 활성화된 경우에만 빈이 초기화됩니다. @Scope - 빈 생성 범위를 정의합니다(예: 프로토타입, 싱글톤 등). @DependsOn - 생성 순서 측면에서 다른 빈에 대한 종속성을 명시적으로 정의합니다. @Order - 빈 목록을 주입할 때 정렬 순서를 정의하지만 단일 빈이 예상되는 경우 우선순위를 해결하지는 않습니다. @Primary - 여러 빈을 자동 주입할 수 있는 경우 애노테이션이 붙은 빈이 선택됩니다. @Conditional - 조건이 만족되는 경우에만 애노테이션이 붙은 빈이 생성됩니다. Spring Boot에서 추가로 사용 가능: @ConditionalOnBean @ConditionalOnMissingBean @ConditionalOnClass @ConditionalOnMissingClass @ConditionalOnProperty @ConditionalOnMissingProperty 빈 주입 @Autowired - 빈이 애노테이션이 붙은 세터, 필드 또는 생성자 매개변수에 주입됩니다. @Qualifier - 자동 주입 후보를 식별하기 위한 추가 조건으로 빈의 이름을 지정합니다. 유효성 검사 @Valid - 속성, 메서드 매개변수 또는 반환 유형을 유효성 검사 대상으로 표시합니다. @Validated - 여러 그룹의 유효성 검사를 허용하는 @Valid의 변형입니다(예: 애노테이션이 붙은 클래스의 모든 필드). @NotNull - null이 아니어야 합니다. @NotEmpty - null이 아니고 비어 있지 않아야 합니다. @NotBlank - null이 아니고 최소한 하나의 공백이 아닌 문자가 있어야 합니다. @Digits - 허용 범위 내의 숫자여야 합니다. @Past - 과거의 순간, 날짜 또는 시간이어야 합니다. @Future - 미래의 순간, 날짜 또는 시간이어야 합니다. \u0026hellip; 스프링 부트 @SpringBootConfiguration - Spring Boot 애플리케이션 @Configuration을 나타냅니다. @EnableAutoConfiguration - 클래스 경로를 기반으로 필요한 빈을 제공하기 위해 애플리케이션 컨텍스트 자동 구성을 활성화합니다. @ConfigurationProperties - 키 값 속성의 외부 바인딩을 제공합니다. @ConstructorBinding - 세터 대신 생성자를 사용하여 속성을 바인딩합니다. @ConfigurationPropertiesScan - @ConfigurationProperties 클래스를 자동으로 감지합니다. @SpringBootApplication - @SpringBootConfiguration, @EnableAutoConfiguration, @ConfigurationPropertiesScan 및 @ComponentScan의 조합입니다. @EntityScan - 엔티티 클래스를 스캔할 기본 패키지를 구성합니다. @EnableJpaRepositories - JPA 리포지토리의 자동 구성을 활성화합니다. @AutoConfiguration - 새로운 자동 구성 클래스를 정의합니다. @AutoConfigureBefore - 지정된 자동 구성 클래스보다 먼저 자동 구성을 적용합니다. @AutoConfigureAfter - 지정된 자동 구성 클래스 이후에 자동 구성을 적용합니다. 스프링 부트 테스트 @SpringBootTest - 애노테이션이 붙은 테스트 클래스는 통합 테스트를 위해 전체 애플리케이션 컨텍스트를 로드합니다. @WebMvcTest - 애노테이션이 붙은 테스트 클래스는 웹 레이어만 로드합니다(서비스 및 데이터 레이어는 무시됨). @DataJpaTest - 애노테이션이 붙은 클래스는 JPA 구성 요소만 로드합니다. @JsonTest - 애노테이션이 붙은 클래스는 직렬화 및 역직렬화 테스트를 위해 JSON 매퍼만 로드합니다. @MockBean - 애노테이션이 붙은 필드를 모의 객체로 표시하고 애플리케이션 컨텍스트에 빈으로 로드합니다. @SpyBean - 빈의 부분 모킹을 허용합니다. @Mock - 애노테이션이 붙은 필드를 모의 객체로 정의합니다. 스프링 테스트 @ContextConfiguration - 통합 테스트를 위해 애플리케이션 컨텍스트를 로드할 @Configuration을 정의합니다. @ExtendWith - 테스트를 실행할 확장을 정의합니다(예: MockitoExtension). @SpringJUnitConfig - @ContextConfiguration 및 @ExtendWith(SpringExtension.class)를 결합합니다. @TestPropertySource - 통합 테스트에 사용되는 속성 파일의 위치를 정의합니다. @DirtiesContext - 애노테이션이 붙은 테스트가 애플리케이션 컨텍스트를 더럽히고 각 테스트 후에 정리됨을 나타냅니다. @ActiveProfiles - 테스트 애플리케이션 컨텍스트를 초기화할 때 로드할 활성 빈 정의를 정의합니다. @Sql - 테스트 전후에 실행할 SQL 스크립트와 문을 정의할 수 있습니다. 트랜잭션 @EnableTransactionManagement - 애노테이션 기반 트랜잭션 선언 @Transactional을 활성화합니다. @Transactional - 애노테이션이 붙은 메서드는 트랜잭션 방식으로 실행됩니다. 스프링 JPA 및 하이버네이트 @Id - 애노테이션이 붙은 필드를 엔티티의 기본 키로 표시합니다. @GeneratedValue - 기본 키의 생성 전략을 제공합니다. @Column - 필드에 대한 추가 구성을 제공합니다(예: 열 이름). @Table - 엔티티에 대한 추가 구성을 제공합니다(예: 테이블 이름). @PersistenceContext - EntityManager가 애노테이션이 붙은 세터와 필드에 주입됩니다. @Embedded - 애노테이션이 붙은 필드는 Embeddable 클래스의 값으로 인스턴스화됩니다. @Embeddable - 애노테이션이 붙은 클래스의 인스턴스는 엔티티의 일부로 저장됩니다. @EmbeddedId - 애노테이션이 붙은 속성을 임베디드 클래스에 의해 매핑된 복합 키로 표시합니다. @AttributeOverride - 필드의 기본 매핑을 재정의합니다. @Transient - 애노테이션이 붙은 필드는 영속적이지 않습니다. @CreationTimestamp - 애노테이션이 붙은 필드는 엔티티가 처음 저장된 타임스탬프를 포함합니다. @UpdateTimestamp - 애노테이션이 붙은 필드는 엔티티가 마지막으로 업데이트된 타임스탬프를 포함합니다. @ManyToOne - N:1 관계를 나타내며, 애노테이션이 붙은 필드를 포함하는 엔티티는 다른 클래스의 엔티티와 단일 관계를 가지지만 다른 클래스는 여러 관계를 가집니다. @JoinColumn - 소유 측의 @ManyToOne 또는 @OneToOne 관계에서 엔티티를 조인하는 열을 나타내거나 단방향 @OneToMany를 나타냅니다. @OneToOne - 1:1 관계를 나타냅니다. @MapsId - @ManyToOne 또는 @OneToOne 관계의 소유 측 조인 열을 참조하여 참조 및 참조된 엔티티의 기본 키로 만듭니다. @ManyToMany - N:M 관계를 나타냅니다. @JoinTable - 조인 테이블을 사용한 연관을 지정합니다. @BatchSize - 애노테이션이 붙은 엔티티 컬렉션을 지연 로드할 크기를 정의합니다. @FetchMode - 연관에 대한 페치 전략을 정의합니다(예: 단일 서브쿼리로 모든 엔티티 로드). 스프링 시큐리티 @EnableWebSecurity - 웹 보안을 활성화합니다. @EnableGlobalMethodSecurity - 메서드 보안을 활성화합니다. @PreAuthorize - SpEL을 사용하여 접근 제어 표현식을 정의하며, 보호된 메서드를 호출하기 전에 평가됩니다. @PostAuthorize - SpEL을 사용하여 접근 제어 표현식을 정의하며, 보호된 메서드를 호출한 후 평가됩니다. @RolesAllowed - 보호된 메서드를 호출할 수 있는 보안 역할 목록을 지정합니다. 스프링 AOP @EnableAspectJAutoProxy - @Aspect로 표시된 구성 요소를 처리하는 지원을 활성화합니다. @Aspect - 애노테이션이 붙은 구성 요소를 포인트컷과 어드바이스를 포함하는 측면으로 선언합니다. @Before - 호출이 조인 포인트로 전파되기 전에 실행되는 포인트컷을 선언합니다. @AfterReturning - 조인 포인트가 성공적으로 결과를 반환하면 실행되는 포인트컷을 선언합니다. @AfterThrowing - 조인 포인트가 예외를 던지면 실행되는 포인트컷을 선언합니다. @After - 조인 포인트가 성공적으로 결과를 반환하거나 예외를 던지면 실행되는 포인트컷을 선언합니다. @Around - 호출 전에 실행되는 포인트컷을 선언하여 조인 포인트의 실행을 어드바이스에 제어를 넘깁니다. 유용한 링크 Spring 공식 문서 Spring Boot 참조 가이드 Spring Security 문서 Spring Data JPA 문서 Baeldung Spring 튜토리얼 Spring 깃허브 저장소 ","date":"2024-12-18","permalink":"/post/2024/2024-12-18_list_of_useful_annotation_in_spring_boot/","section":"post","summary":"이 문서는 Spring Boot 애플리케이션에서 자주 사용되는 애노테이션의 목록입니다.\n","title":"Spring Boot에서 자주 사용되는 애노테이션"},{"content":"개발 환경을 설정하고 관리하다 보면 다양한 버전의 Node.js와 패키지 매니저를 사용해야 할 때가 많습니다. 이때 도구 관리자 Volta를 사용하면 효율적이고 간편하게 Node.js 및 JavaScript 도구를 관리할 수 있습니다.\n이번 포스트에서는 Volta의 설치부터 프로젝트에서 pnpm과 Node.js 버전을 고정하여 사용하는 방법까지 자세히 소개하겠습니다.\n1. Volta란? Volta는 Node.js와 JavaScript 도구를 빠르고 효율적으로 관리하기 위한 도구 관리자입니다. 캐싱을 통해 도구 실행 속도를 향상시키고, 프로젝트별로 도구 버전을 고정하여 환경 일관성을 유지할 수 있습니다.\n2. Volta 설치하기 macOS/Linux: 터미널에 다음 명령어를 입력하여 설치합니다:\ncurl https://get.volta.sh | bash 설치가 완료되면 터미널을 다시 시작하거나 쉘 환경을 재로드해야 합니다.\nWindows: Windows에서 Volta를 설치하려면 다음 단계를 따르세요:\nVolta 공식 사이트 방문:\nVolta 공식 사이트에 접속합니다.\n설치 프로그램 다운로드:\n메인 페이지에서 \u0026ldquo;Download Installer\u0026rdquo; 버튼을 클릭하여 설치 프로그램(.msi 파일)을 다운로드합니다.\n설치 프로그램 실행:\n다운로드한 .msi 파일을 더블 클릭하여 설치를 시작합니다.\n설치 과정 진행:\n설치 마법사의 지시에 따라 설치를 완료합니다.\n명령 프롬프트 재시작:\n설치가 완료되면 명령 프롬프트(cmd) 또는 PowerShell을 다시 시작하여 환경 변수를 적용합니다.\n3. Node.js 버전 관리 특정 버전 설치: volta install node@16 위 명령어는 Node.js 16 버전을 설치합니다.\n기본 버전 설정: volta default node@16 전역적으로 Node.js 16 버전이 기본으로 사용됩니다.\n프로젝트별 버전 설정: 프로젝트 디렉토리에서 다음을 실행하여 해당 프로젝트에 Node.js 버전을 고정합니다:\nvolta pin node@14 해당 프로젝트에서는 Node.js 14 버전을 사용하게 됩니다.\n4. 프로젝트에서 pnpm과 Node.js 버전 고정하기 프로젝트별로 특정 버전의 도구를 고정하면 팀원 간 일관성을 유지하고 호환성 문제를 방지할 수 있습니다.\n1) 프로젝트 디렉토리로 이동: cd your-project-directory 2) Node.js 버전 고정: 프로젝트에서 사용할 Node.js 버전을 설정합니다.\nvolta pin node@16 현재 프로젝트에서 Node.js 버전을 16으로 고정합니다.\n3) pnpm 설치 및 버전 고정: 프로젝트에서 사용할 pnpm 버전을 설치하고 고정합니다.\nvolta pin pnpm@7 pnpm 버전 7을 프로젝트에 고정합니다.\n4) 고정된 버전 확인: 고정된 도구와 버전을 확인하려면:\nvolta list Project 섹션에 고정된 Node.js와 pnpm 버전이 표시됩니다.\n5. 패키지 설치 및 관리 전역 패키지 설치: volta install yarn Volta는 패키지를 전역적으로 설치하되, 프로젝트 격리를 지원합니다.\n패키지 매니저 사용: 버전을 고정한 후에는 일반적으로 사용하듯이 패키지 매니저 명령어를 실행하면 됩니다.\npnpm install pnpm run build 6. 설치된 도구 확인 현재 설치된 도구와 버전을 확인하려면:\nvolta list 7. Volta 업데이트 최신 버전으로 Volta를 업데이트하려면:\nvolta upgrade 8. Volta의 장점 속도 향상: 캐싱을 통해 도구 실행 속도를 높여줍니다. 간편한 버전 관리: Node.js 및 패키지의 버전을 손쉽게 전환할 수 있습니다. 프로젝트 격리: 프로젝트마다 독립된 도구 버전을 사용할 수 있어 호환성 문제를 방지합니다. 쉬운 설치: 간단한 명령어로 설치 및 설정이 가능합니다. 9. 추가 팁 .volta 디렉토리 공유: 프로젝트 루트에 생성된 .volta 디렉토리를 버전 관리 시스템(예: Git)에 포함시키면 팀원들도 동일한 도구 버전을 자동으로 사용하게 되어 환경 일관성을 유지할 수 있습니다.\n다른 패키지 매니저 버전 고정: pnpm 외에도 npm이나 yarn 등의 패키지 매니저도 동일한 방식으로 버전을 고정할 수 있습니다.\nvolta pin npm@7 volta pin yarn@1.22 10. 마무리 Volta를 사용하면 Node.js와 JavaScript 도구를 효율적으로 관리할 수 있으며, 프로젝트별로 도구 버전을 고정하여 팀원 간 일관된 개발 환경을 유지할 수 있습니다. 이는 버전 차이로 인한 예기치 않은 오류를 방지하고 안정적인 개발 환경을 조성하는 데 큰 도움이 됩니다.\n더 자세한 내용이나 고급 기능은 Volta 공식 문서를 참고하시기 바랍니다.\n","date":"2024-12-02","permalink":"/post/2024/2024-12-02_volta/","section":"post","summary":"개발 환경을 설정하고 관리하다 보면 다양한 버전의 Node.js와 패키지 매니저를 사용해야 할 때가 많습니다. 이때 도구 관리자 Volta를 사용하면 효율적이고 간편하게 Node.js 및 JavaScript 도구를 관리할 수 있습니다.\n","title":"Volta로 Node.js 및 JavaScript 도구 효율적으로 관리하기"},{"content":"데이터 시각화는 데이터 분석에서 중요한 단계입니다. Python의 Seaborn 라이브러리는 통계적 데이터 시각화를 쉽게 할 수 있도록 도와주는 강력한 도구입니다.\n이 글에서는 Seaborn의 기본 사용법과 함께 추천할 만한 다양한 그래프 유형을 소개하겠습니다.\n1. Seaborn 설치 Seaborn이 설치되어 있지 않다면, 다음 명령어로 설치할 수 있습니다:\npip install seaborn 2. 기본 사용법 Seaborn을 사용하기 위해서는 먼저 라이브러리를 임포트하고, 데이터셋을 준비해야 합니다. 예를 들어, tips라는 내장 데이터셋을 사용할 수 있습니다.\nimport seaborn as sns import matplotlib.pyplot as plt # 내장 데이터셋 로드 tips = sns.load_dataset(\u0026#34;tips\u0026#34;) # 데이터셋 확인 print(tips.head()) 결과값\ntotal_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 1 10.34 1.66 Male No Sun Dinner 3 2 21.01 3.50 Male No Sun Dinner 3 3 23.68 3.31 Male No Sun Dinner 2 4 24.59 3.61 Female No Sun Dinner 4 3. 기본 플롯 3.1 산점도 (Scatter Plot) 산점도는 두 변수 간의 관계를 시각화하는 데 유용합니다.\n# 산점도 그리기 sns.scatterplot(data=tips, x=\u0026#34;total_bill\u0026#34;, y=\u0026#34;tip\u0026#34;, hue=\u0026#34;day\u0026#34;) plt.title(\u0026#34;Total Bill vs Tip\u0026#34;) plt.show() 3.2 상자 그림 (Box Plot) 상자 그림은 데이터의 분포와 이상치를 시각화합니다.\n# 상자 그림 그리기 sns.boxplot(data=tips, x=\u0026#34;day\u0026#34;, y=\u0026#34;total_bill\u0026#34;, hue=\u0026#34;sex\u0026#34;) plt.title(\u0026#34;Total Bill by Day and Sex\u0026#34;) plt.show() 3.3 히스토그램 (Histogram) 히스토그램은 데이터의 분포를 시각화합니다.\n# 히스토그램 그리기 sns.histplot(data=tips, x=\u0026#34;total_bill\u0026#34;, bins=30, kde=True) plt.title(\u0026#34;Distribution of Total Bill\u0026#34;) plt.show() 3.4 Pairplot pairplot은 데이터셋의 모든 변수 쌍에 대해 산점도를 그려주고, 대각선에는 각 변수의 분포를 보여줍니다.\n# Pairplot 그리기 sns.pairplot(tips, hue=\u0026#34;sex\u0026#34;) plt.title(\u0026#34;Pairplot of Tips Dataset\u0026#34;) plt.show() 4. 추가 추천 그래프 Seaborn은 다양한 유형의 그래프를 지원하여 데이터 시각화를 풍부하게 할 수 있습니다. 아래는 추가로 추천할 만한 그래프 유형입니다.\n4.1 히트맵 (Heatmap) 히트맵은 데이터의 상관관계를 시각화하는 데 유용합니다.\n# 상관 행렬 계산 correlation_matrix = tips.corr() # 히트맵 그리기 sns.heatmap(correlation_matrix, annot=True, cmap=\u0026#34;coolwarm\u0026#34;) plt.title(\u0026#34;Correlation Heatmap\u0026#34;) plt.show() 4.2 바 플롯 (Bar Plot) 바 플롯은 범주형 데이터의 평균 또는 합계를 시각화하는 데 유용합니다.\n# 바 플롯 그리기 sns.barplot(data=tips, x=\u0026#34;day\u0026#34;, y=\u0026#34;total_bill\u0026#34;, hue=\u0026#34;sex\u0026#34;) plt.title(\u0026#34;Average Total Bill by Day and Sex\u0026#34;) plt.show() 4.3 선 그래프 (Line Plot) 선 그래프는 시간에 따른 변화를 시각화하는 데 적합합니다.\n# 예시 데이터 생성 import pandas as pd # 날짜 생성 dates = pd.date_range(\u0026#34;2023-01-01\u0026#34;, periods=10) values = [1, 3, 2, 5, 4, 6, 7, 8, 9, 10] data = pd.DataFrame({\u0026#34;Date\u0026#34;: dates, \u0026#34;Values\u0026#34;: values}) # 선 그래프 그리기 sns.lineplot(data=data, x=\u0026#34;Date\u0026#34;, y=\u0026#34;Values\u0026#34;) plt.title(\u0026#34;Line Plot Example\u0026#34;) plt.xticks(rotation=45) plt.show() 4.4 카운트 플롯 (Count Plot) 카운트 플롯은 각 범주형 변수의 개수를 시각화합니다.\n# 카운트 플롯 그리기 sns.countplot(data=tips, x=\u0026#34;day\u0026#34;, hue=\u0026#34;sex\u0026#34;) plt.title(\u0026#34;Count of Tips by Day and Sex\u0026#34;) plt.show() 4.5 조인트 플롯 (Joint Plot) 조인트 플롯은 두 변수 간의 관계를 시각화하고, 각 변수의 분포를 함께 보여줍니다.\n# 조인트 플롯 그리기 sns.jointplot(data=tips, x=\u0026#34;total_bill\u0026#34;, y=\u0026#34;tip\u0026#34;, kind=\u0026#34;scatter\u0026#34;, hue=\u0026#34;sex\u0026#34;) plt.title(\u0026#34;Joint Plot of Total Bill and Tip\u0026#34;) plt.show() 4.6 바이올린 플롯 (Violin Plot) 바이올린 플롯은 데이터의 분포를 시각화하며, 상자 그림과 밀도 곡선을 결합한 형태입니다.\n# 바이올린 플롯 그리기 sns.violinplot(data=tips, x=\u0026#34;day\u0026#34;, y=\u0026#34;total_bill\u0026#34;, hue=\u0026#34;sex\u0026#34;, split=True) plt.title(\u0026#34;Violin Plot of Total Bill by Day and Sex\u0026#34;) plt.show() 결론 Seaborn은 데이터 시각화를 간편하게 만들어주는 강력한 도구입니다. 다양한 플롯과 스타일을 통해 데이터를 효과적으로 시각화할 수 있습니다.\n","date":"2024-11-26","permalink":"/post/2024/2024-11-26_seaborn/","section":"post","summary":"데이터 시각화는 데이터 분석에서 중요한 단계입니다. Python의 Seaborn 라이브러리는 통계적 데이터 시각화를 쉽게 할 수 있도록 도와주는 강력한 도구입니다.\n","title":"Seaborn을 활용한 데이터 시각화의 편리함"},{"content":"Pandas는 데이터 분석 및 조작을 위한 강력한 라이브러리로, 특히 DataFrame 객체는 표 형식의 데이터를 다루는 데 매우 유용합니다.\n본 포스트에서는 Pandas의 DataFrame에서 자주 사용되는 메서드들을 소개하고자 합니다. 이 메서드들은 데이터의 효율적인 탐색, 선택, 조작, 결측치 처리 및 집계를 가능하게 하여 데이터 분석 작업을 한층 더 수월하게 만들어 줍니다.\nPandas에서 DataFrame은 2차원 데이터 구조로, 행과 열로 구성된 표 형식의 데이터를 저장하고 조작하는 데 사용됩니다.\nDataFrame은 다음과 같은 특징을 가지고 있습니다:\n행과 열: DataFrame은 행(row)과 열(column)로 구성되어 있으며, 각 열은 서로 다른 데이터 타입(예: 정수, 실수, 문자열 등)을 가질 수 있습니다.\n인덱스: 각 행은 고유한 인덱스를 가지며, 이를 통해 데이터에 쉽게 접근하고 조작할 수 있습니다. 기본적으로 인덱스는 0부터 시작하는 정수로 설정되지만, 사용자가 지정할 수도 있습니다.\n라벨: 각 열은 이름(라벨)을 가지며, 이를 통해 특정 열에 접근하거나 조작할 수 있습니다.\n다양한 데이터 소스: DataFrame은 CSV 파일, Excel 파일, SQL 데이터베이스 등 다양한 데이터 소스에서 쉽게 생성할 수 있습니다.\n강력한 데이터 조작 기능: Pandas는 데이터 필터링, 정렬, 집계, 결합, 결측치 처리 등 다양한 데이터 조작 기능을 제공합니다.\n1. 데이터 생성 다음과 같이 DataFrame을 생성할 수 있습니다:\nimport pandas as pd data = { \u0026#39;이름\u0026#39;: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;], \u0026#39;나이\u0026#39;: [25, 30, 35], \u0026#39;도시\u0026#39;: [\u0026#39;서울\u0026#39;, \u0026#39;부산\u0026#39;, \u0026#39;대구\u0026#39;] } df = pd.DataFrame(data) print(df) 이 코드는 다음과 같은 DataFrame을 생성합니다:\n이름 나이 도시 0 Alice 25 서울 1 Bob 30 부산 2 Charlie 35 대구 2. 데이터 조회 및 탐색 head(n): DataFrame의 처음 n개의 행을 반환합니다. 기본값은 5입니다.\ndf.head(3) tail(n): DataFrame의 마지막 n개의 행을 반환합니다. 기본값은 5입니다.\ndf.tail(3) info(): DataFrame의 요약 정보를 제공합니다. 데이터 타입, 결측치 수 등 다양한 정보를 쉽게 확인할 수 있습니다.\ndf.info() describe(): 수치형 데이터의 통계 요약을 제공합니다. 평균, 표준편차, 최소값, 최대값 등의 값들을 포함하고 있습니다.\ndf.describe() 3. 데이터 선택 및 필터링 loc[]: 라벨 기반 인덱싱을 사용하여 특정 행과 열을 선택합니다.\ndf.loc[0] # 첫 번째 행 선택 df.loc[:, \u0026#39;이름\u0026#39;] # \u0026#39;이름\u0026#39; 열 선택 iloc[]: 정수 기반 인덱싱을 사용하여 특정 행과 열을 선택합니다.\ndf.iloc[0, 1] # 첫 번째 행, 두 번째 열의 값 선택 조건 필터링: 특정 조건을 만족하는 행을 선택합니다.\ndf[df[\u0026#39;나이\u0026#39;] \u0026gt; 30] # 나이가 30보다 큰 행 선택 AND 조건 (\u0026amp;): Pandas에서 DataFrame에 대해 다중 조건을 사용하여 필터링할 때는 각 조건을 괄호로 묶고, 조건 사이에 비트 연산자 \u0026amp; (AND) 또는 | (OR)를 사용합니다. 조건을 결합할 때는 반드시 괄호를 사용해야 합니다. 예를 들어, 나이가 30보다 크고 도시가 \u0026lsquo;서울\u0026rsquo;인 행을 선택하고 싶다면 다음과 같이 작성할 수 있습니다:\ndf[(df[\u0026#39;나이\u0026#39;] \u0026gt; 30) \u0026amp; (df[\u0026#39;도시\u0026#39;] == \u0026#39;서울\u0026#39;)] OR 조건 (|) : 나이가 30보다 크거나 도시가 \u0026lsquo;부산\u0026rsquo;인 행을 선택하고 싶다면 다음과 같이 작성할 수 있습니다:\ndf[(df[\u0026#39;나이\u0026#39;] \u0026gt; 30) | (df[\u0026#39;도시\u0026#39;] == \u0026#39;부산\u0026#39;)] 복합 조건: 여러 조건을 조합하여 사용할 수도 있습니다. 예를 들어, 나이가 30보다 크고 도시가 \u0026lsquo;서울\u0026rsquo;이거나 \u0026lsquo;부산\u0026rsquo;인 행을 선택하려면 다음과 같이 작성할 수 있습니다:\ndf[((df[\u0026#39;나이\u0026#39;] \u0026gt; 30) \u0026amp; (df[\u0026#39;도시\u0026#39;] == \u0026#39;서울\u0026#39;)) | (df[\u0026#39;도시\u0026#39;] == \u0026#39;부산\u0026#39;)] 4. 데이터 조작 sort_values(by): 특정 열을 기준으로 DataFrame을 정렬합니다.\ndf.sort_values(by=\u0026#39;나이\u0026#39;, ascending=False) drop(labels): 특정 행이나 열을 삭제합니다.\ndf.drop(columns=\u0026#39;도시\u0026#39;) # \u0026#39;도시\u0026#39; 열 삭제 rename(columns): 열의 이름을 변경합니다.\ndf.rename(columns={\u0026#39;이름\u0026#39;: \u0026#39;이름_변경\u0026#39;}, inplace=True) 5. 데이터 추가 및 수정 assign(): 새로운 열을 추가하거나 기존 열을 수정합니다.\ndf = df.assign(성별=[\u0026#39;여\u0026#39;, \u0026#39;남\u0026#39;, \u0026#39;남\u0026#39;]) append(): 다른 DataFrame을 현재 DataFrame에 추가합니다.\ndf2 = pd.DataFrame({\u0026#39;이름\u0026#39;: [\u0026#39;David\u0026#39;], \u0026#39;나이\u0026#39;: [40], \u0026#39;도시\u0026#39;: [\u0026#39;광주\u0026#39;]}) df = df.append(df2, ignore_index=True) 6. 결측치 처리 isnull(): 결측치가 있는지 확인합니다.\ndf.isnull() fillna(value): 결측치를 특정 값으로 채웁니다.\ndf.fillna(0) dropna(): 결측치가 있는 행이나 열을 삭제합니다.\ndf.dropna() 7. 그룹화 및 집계 groupby(by): 특정 열을 기준으로 데이터를 그룹화합니다.\ndf.groupby(\u0026#39;도시\u0026#39;).mean() # 도시별 평균 나이 계산 agg(): 그룹화된 데이터에 대해 여러 집계 함수를 적용합니다.\ndf.groupby(\u0026#39;도시\u0026#39;).agg({\u0026#39;나이\u0026#39;: [\u0026#39;mean\u0026#39;, \u0026#39;max\u0026#39;]}) Pandas의 DataFrame은 다양한 데이터 분석 작업에 매우 유용한 메서드들을 제공합니다. 위에서 소개한 메서드를 적절히 활용하면 데이터를 보다 효율적으로 탐색하고 조작할 수 있습니다.\n","date":"2024-11-26","permalink":"/post/2024/2024-11-26_pandas-dataframe/","section":"post","summary":"Pandas는 데이터 분석 및 조작을 위한 강력한 라이브러리로, 특히 DataFrame 객체는 표 형식의 데이터를 다루는 데 매우 유용합니다.\n","title":"Pandas의 DataFrame에서 자주 사용되는 유용한 메서드들 소개"},{"content":"Jenkins는 소프트웨어 개발에서 지속적 통합 및 배포(CI/CD)를 위한 강력한 도구입니다. Docker Compose를 사용하여 Jenkins를 설정하면 환경 구성이 간편해지고 일관성 있는 배포가 가능해집니다.\n이 가이드에서는 Docker Compose를 사용하여 Jenkins를 설정하는 방법을 단계별로 설명하겠습니다.\n1. docker-compose.yml 파일 생성 먼저, 프로젝트 디렉토리에 docker-compose.yml 파일을 생성합니다. 이 파일은 Docker Compose가 컨테이너를 어떻게 구성하고 실행할지 정의합니다.\n2. docker-compose.yml 내용 작성 다음은 Jenkins를 Docker Compose로 실행하기 위한 기본적인 docker-compose.yml 파일의 내용입니다:\nversion: \u0026#39;3\u0026#39; services: jenkins: image: jenkins/jenkins:lts privileged: true user: root ports: - 8080:8080 - 50000:50000 container_name: jenkins volumes: - ./jenkins_home:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock restart: always 이 설정은 Jenkins의 기본적인 실행 환경을 제공합니다. 각 설정의 의미와 중요성에 대해 자세히 살펴보겠습니다.\n3. 설정 설명 image: jenkins/jenkins:lts 이 설정은 공식 Jenkins LTS (Long Term Support) 이미지를 사용하도록 지정합니다. LTS 버전은 안정성이 검증된 버전으로, 프로덕션 환경에 적합합니다.\nprivileged: true 및 user: root 이 설정들은 Jenkins 컨테이너에 필요한 권한을 부여합니다. 특히 Docker 명령어를 실행하거나 특정 시스템 리소스에 접근해야 할 때 필요합니다. 단, 보안상의 이유로 프로덕션 환경에서는 최소한의 권한만 부여하는 것이 좋습니다.\nports 8080:8080: Jenkins 웹 인터페이스에 접근하기 위한 포트입니다. 호스트의 8080 포트를 컨테이너의 8080 포트에 매핑합니다. 50000:50000: Jenkins 슬레이브 에이전트와의 통신을 위한 포트입니다. 분산 빌드 환경을 구성할 때 사용됩니다. volumes ./jenkins_home:/var/jenkins_home: Jenkins의 데이터와 설정을 호스트 시스템의 ./jenkins_home 디렉토리에 저장합니다. 이를 통해 컨테이너가 삭제되더라도 데이터를 유지할 수 있습니다. /var/run/docker.sock:/var/run/docker.sock: 호스트의 Docker 소켓을 Jenkins 컨테이너와 공유합니다. 이를 통해 Jenkins 내에서 Docker 명령어를 실행할 수 있게 됩니다. restart: always 시스템이 재시작되거나 Docker 데몬이 재시작될 때 Jenkins 컨테이너를 자동으로 시작하도록 설정합니다.\n4. Jenkins 실행 설정이 완료되면, docker-compose.yml 파일이 있는 디렉토리에서 다음 명령어를 실행하여 Jenkins를 시작합니다:\ndocker-compose up -d -d 옵션은 백그라운드에서 컨테이너를 실행하도록 합니다.\n5. Jenkins 초기 설정 Jenkins를 처음 실행하면 초기 설정 과정이 필요합니다. 다음 단계를 따라 설정을 완료하세요:\n웹 브라우저에서 http://localhost:8080으로 접속합니다. 초기 관리자 비밀번호를 입력해야 합니다. 이 비밀번호는 다음 명령어로 확인할 수 있습니다: docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword 화면의 지시에 따라 추천 플러그인을 설치하고 관리자 계정을 생성합니다. 주의사항 및 추가 고려사항 보안: 위의 설정은 기본적인 것이며, 프로덕션 환경에서는 추가적인 보안 설정이 필요합니다. 예를 들어, Jenkins에 대한 접근을 제한하거나, HTTPS를 설정하는 것이 좋습니다.\n버전 관리: Jenkins 버전을 업데이트할 때는 docker-compose.yml의 이미지 태그를 변경해야 할 수 있습니다. 정기적으로 버전을 확인하고 업데이트하는 것이 좋습니다.\n리소스 관리: Jenkins는 많은 시스템 리소스를 사용할 수 있습니다. 필요에 따라 컨테이너의 리소스 제한을 설정하는 것이 좋습니다.\n백업: jenkins_home 디렉토리를 정기적으로 백업하여 데이터 손실에 대비하세요.\n플러그인 관리: 필요한 플러그인만 설치하고 관리하세요. 불필요한 플러그인은 시스템 성능에 영향을 줄 수 있습니다.\n네트워크 설정: 다른 서비스와 연동해야 하는 경우, Docker 네트워크를 적절히 구성하세요.\nJenkins를 Docker Compose로 설정하면 환경 관리가 훨씬 쉬워지고, 개발 팀 전체가 일관된 환경에서 작업할 수 있습니다. 이 가이드를 따라 설정하고, 필요에 따라 추가적인 커스터마이징을 진행하시기 바랍니다. Jenkins를 통한 효율적인 CI/CD 파이프라인 구축으로 개발 프로세스를 한층 개선할 수 있을 것입니다.\n","date":"2024-10-21","permalink":"/post/2024/2024-10-21_jenkins-docker-compose/","section":"post","summary":"Jenkins는 소프트웨어 개발에서 지속적 통합 및 배포(CI/CD)를 위한 강력한 도구입니다. Docker Compose를 사용하여 Jenkins를 설정하면 환경 구성이 간편해지고 일관성 있는 배포가 가능해집니다.\n","title":"Jenkins Docker Compose 설정 가이드"},{"content":"Python 개발자라면 코드 품질 관리의 중요성을 잘 알고 계실 겁니다. 오늘은 VSCode에서 Ruff를 사용하여 Python 코드의 품질을 효과적으로 관리하는 방법을 소개해 드리겠습니다.\nRuff란? Ruff는 Python 코드를 위한 빠르고 강력한 linter입니다. 기존의 여러 도구(Flake8, Black, isort 등)의 기능을 통합하여 제공하며, 주요 특징과 기능은 다음과 같습니다.\n성능: Ruff는 Rust로 작성되었으며, Flake8이나 Black과 같은 전통적인 린터나 포맷터보다 10-100배 더 빠른 것으로 알려져 있습니다. 이러한 속도는 개발 중 실시간 피드백을 가능하게 하여 코딩 경험을 크게 향상시킵니다.\n설치: pip를 통해 쉽게 설치할 수 있습니다:\npip install ruff 설정: Ruff는 pyproject.toml, ruff.toml, 또는 .ruff.toml과 같은 파일을 통해 설정을 지원하여 사용자가 줄 길이나 무시할 규칙 등을 커스터마이즈할 수 있습니다.\n특징 린팅과 포맷팅: Ruff는 ruff check 명령으로 린팅을, ruff format 명령으로 포맷팅을 수행할 수 있어 코드 품질 유지를 위한 다목적 도구입니다.\n광범위한 규칙 세트: Flake8, isort 등 인기 있는 도구들에서 영감을 받은 800개 이상의 내장 규칙을 포함합니다. 이 광범위한 규칙 세트는 스타일 위반부터 잠재적 버그까지 다양한 코딩 문제를 식별하는 데 도움을 줍니다.\n자동 수정: Ruff는 사용되지 않는 import 제거와 같은 특정 오류를 자동으로 수정할 수 있는 기능을 제공하여 개발자의 생산성을 향상시킵니다.\n통합: 다양한 편집기(예: VS Code)와 잘 통합되며 CI/CD 파이프라인에서 사용할 수 있어 로컬 개발과 팀 환경 모두에 적합합니다.\n사용 사례 Ruff는 특히 다음과 같은 경우에 유용합니다:\n코드 리뷰 프로세스: 일관된 품질을 보장하여 코드 리뷰를 간소화합니다. 지속적 통합: CI/CD 워크플로우에서 품질 검사를 자동화합니다. 대규모 코드베이스: 전통적인 도구들이 현저히 느려질 수 있는 대규모 프로젝트에 이상적입니다. VSCode에서 Ruff 설정하기 1. Ruff 확장 설치 먼저 VSCode 마켓플레이스에서 \u0026ldquo;Ruff\u0026rdquo; 확장을 검색하여 설치합니다.\n2. ruff.toml 설정 프로젝트 루트 디렉토리에 ruff.toml 파일을 생성하고 다음과 같이 설정합니다:\n# Black과 동일합니다. line-length = 88 indent-width = 4 # 밑줄로 시작하는 미사용 변수를 허용합니다. dummy-variable-rgx = \u0026#34;^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$\u0026#34; # Python 3.12을 가정합니다. target-version = \u0026#34;py312\u0026#34; # 일반적으로 무시되는 다양한 디렉토리를 제외합니다. exclude = [ \u0026#34;.bzr\u0026#34;, \u0026#34;.direnv\u0026#34;, \u0026#34;.eggs\u0026#34;, \u0026#34;.git\u0026#34;, \u0026#34;.git-rewrite\u0026#34;, \u0026#34;.hg\u0026#34;, \u0026#34;.mypy_cache\u0026#34;, \u0026#34;.nox\u0026#34;, \u0026#34;.pants.d\u0026#34;, \u0026#34;.pytype\u0026#34;, \u0026#34;.ruff_cache\u0026#34;, \u0026#34;.svn\u0026#34;, \u0026#34;.tox\u0026#34;, \u0026#34;.venv\u0026#34;, \u0026#34;__pypackages__\u0026#34;, \u0026#34;_build\u0026#34;, \u0026#34;buck-out\u0026#34;, \u0026#34;build\u0026#34;, \u0026#34;dist\u0026#34;, \u0026#34;node_modules\u0026#34;, ] [lint] # https://docs.astral.sh/ruff/rules/ 참고 # E: pycodestyle 오류 (PEP 8 스타일 가이드) # F: Pyflakes (논리적 오류 및 잠재적 버그) # I: isort (import 정렬) # N: pep8-naming (이름 지정 규칙) # S: flake8-bandit (보안 이슈) # B: flake8-bugbear (추가적인 버그 및 디자인 문제 검출) # A: flake8-builtins (내장 함수 이름 오용 검사) select = [\u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;B\u0026#34;] ignore = [] fixable = [\u0026#34;ALL\u0026#34;] unfixable = [] [mccabe] max-complexity = 10 [flake8-quotes] docstring-quotes = \u0026#34;double\u0026#34; [flake8-tidy-imports] ban-relative-imports = \u0026#34;all\u0026#34; [pycodestyle] max-doc-length = 88 [pydocstyle] convention = \u0026#34;google\u0026#34; [pylint] max-args = 8 max-branches = 12 max-returns = 6 max-statements = 50 [pyupgrade] keep-runtime-typing = true [format] quote-style = \u0026#34;double\u0026#34; indent-style = \u0026#34;space\u0026#34; skip-magic-trailing-comma = false line-ending = \u0026#34;auto\u0026#34; docstring-code-format = false docstring-code-line-length = \u0026#34;dynamic\u0026#34; 이 설정은 Black 스타일을 따르면서도 Ruff의 다양한 기능을 활용합니다.\n3. VSCode settings.json 설정 VSCode의 설정 또는 프로젝트의 .vscode/settings.json 파일에 다음 설정을 추가합니다:\n{ \u0026#34;ruff.enable\u0026#34;: true, \u0026#34;python.languageServer\u0026#34;: \u0026#34;Pylance\u0026#34;, \u0026#34;python.analysis.typeCheckingMode\u0026#34;: \u0026#34;basic\u0026#34;, \u0026#34;python.analysis.autoImportCompletions\u0026#34;: true, \u0026#34;python.analysis.diagnosticMode\u0026#34;: \u0026#34;workspace\u0026#34;, \u0026#34;[python]\u0026#34;: { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;charliermarsh.ruff\u0026#34;, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: \u0026#34;explicit\u0026#34; } } } 설정 설명 Ruff 활성화: \u0026quot;ruff.enable\u0026quot;: true로 Ruff를 활성화합니다.\n언어 서버: Pylance를 사용하여 더 나은 Python 지원을 받습니다.\n타입 체크: \u0026quot;basic\u0026quot; 모드로 설정하여 기본적인 타입 체크를 수행합니다.\n자동 import: 자동 import 제안 기능을 활성화합니다.\n진단 모드: 전체 작업 공간에 대해 진단을 수행합니다.\nPython 파일 설정:\n저장 시 자동 포맷팅을 활성화합니다. Ruff를 기본 포맷터로 설정합니다. 저장 시 자동으로 import를 정리합니다. 결론 이렇게 설정하면 VSCode에서 Python 개발 시 Ruff를 통해 자동으로 코드 품질을 관리할 수 있습니다. 저장할 때마다 코드가 자동으로 포맷팅되고, import가 정리되며, 다양한 lint 규칙이 적용됩니다. 이를 통해 일관된 코드 스타일을 유지하고, 잠재적인 버그를 사전에 방지할 수 있습니다.\nRuff의 빠른 성능 덕분에 대규모 프로젝트에서도 원활하게 사용할 수 있으며, 하나의 도구로 여러 가지 코드 품질 관리 작업을 수행할 수 있어 매우 효율적입니다.\n이제 여러분도 VSCode와 Ruff를 활용하여 더 나은 Python 코드를 작성해보세요!\n","date":"2024-10-01","permalink":"/post/2024/2024-10-01-python-ruff-settings-in-vscode/","section":"post","summary":"Python 개발자라면 코드 품질 관리의 중요성을 잘 알고 계실 겁니다. 오늘은 VSCode에서 Ruff를 사용하여 Python 코드의 품질을 효과적으로 관리하는 방법을 소개해 드리겠습니다.\n","title":"VSCode에서 Ruff로 Python 코드 품질 관리하기"},{"content":"환경별로 여러 개의 .env 파일을 사용하여 설정을 관리하는 방법.\n예를 들어 .env.product, .env.dev, .env.dev.local 등 상황에 따라 다른 .env 파일을 로드하도록 설정할 수 있습니다.\n이를 구현하기 위해 다음과 같은 방법을 사용할 수 있습니다:\n1. 환경 변수를 통해 현재 환경 설정하기 먼저, 애플리케이션 실행 시 현재 환경을 지정하는 환경 변수를 설정합니다. 흔히 ENV 또는 APP_ENV라는 이름을 사용합니다.\n# 개발 환경에서 실행 export ENV=dev uvicorn main:app # 프로덕션 환경에서 실행 export ENV=product uvicorn main:app 또는 ENV 변수를 명령과 함께 지정할 수도 있습니다:\nENV=dev uvicorn main:app 2. 환경에 따라 적절한 .env 파일 로드하기 python-dotenv의 load_dotenv() 함수에 로드할 .env 파일의 경로를 지정하여, 환경별로 다른 설정을 로드할 수 있습니다.\nimport os from dotenv import load_dotenv from fastapi import FastAPI # ENV 환경 변수에서 현재 환경을 가져옵니다. 기본값은 \u0026#39;dev\u0026#39;로 설정합니다. ENV = os.getenv(\u0026#39;ENV\u0026#39;, \u0026#39;dev\u0026#39;) # 로드할 .env 파일의 경로를 설정합니다. dotenv_path = f\u0026#39;.env.{ENV}\u0026#39; # 해당 .env 파일을 로드합니다. load_dotenv(dotenv_path) app = FastAPI() @app.get(\u0026#34;/\u0026#34;) async def read_root(): secret_key = os.getenv(\u0026#34;SECRET_KEY\u0026#34;) return {\u0026#34;SECRET_KEY\u0026#34;: secret_key} 이렇게 하면 ENV 변수에 따라 .env.dev, .env.product 등의 파일을 로드하게 됩니다.\n3. 로컬 설정 파일 지원하기 만약 환경별 설정에 추가로 로컬에서만 사용하고 싶은 설정이 있다면, 로컬 .env 파일을 추가로 로드할 수 있습니다. 예를 들어, 개발 환경에서만 사용하는 .env.dev.local 파일을 로드하려면:\nimport os from dotenv import load_dotenv from fastapi import FastAPI ENV = os.getenv(\u0026#39;ENV\u0026#39;, \u0026#39;dev\u0026#39;) dotenv_path = f\u0026#39;.env.{ENV}\u0026#39; # 기본 환경 설정 로드 load_dotenv(dotenv_path) # 로컬 환경 설정 로드 (파일이 존재하는 경우에만) dotenv_local_path = f\u0026#39;.env.{ENV}.local\u0026#39; if os.path.exists(dotenv_local_path): load_dotenv(dotenv_local_path, override=True) app = FastAPI() 여기서 override=True 옵션을 사용하여 이전에 로드된 변수들을 덮어쓰도록 합니다.\n4. .env 파일 구성하기 각 환경별로 필요한 설정을 .env 파일에 작성합니다.\n.env.dev\nSECRET_KEY=dev_secret_key DATABASE_URL=sqlite:///./dev.db DEBUG=True .env.product\nSECRET_KEY=prod_secret_key DATABASE_URL=postgresql://user:password@host:port/dbname DEBUG=False .env.dev.local\nDATABASE_URL=sqlite:///./dev_local.db DATABASE_URL과 같은 설정은 로컬 개발 환경에 따라 다를 수 있으므로 .env.dev.local에서 오버라이드할 수 있습니다.\n5. .gitignore에 로컬 .env 파일 추가하기 로컬 설정 파일은 버전 관리에서 제외하여 개인별 설정이 공유되지 않도록 합니다.\n# .gitignore .env.*.local 6. 실행 방법 정리 개발 환경에서 기본 설정으로 실행\nENV=dev uvicorn main:app 개발 환경에서 로컬 설정을 포함하여 실행 (로컬 .env 파일이 존재해야 함)\nENV=dev uvicorn main:app 프로덕션 환경에서 실행\nENV=product uvicorn main:app 이러한 방식으로 환경별로 분리된 여러 개의 .env 파일을 관리하고, 상황에 따라 적절한 설정을 로드하여 FastAPI 애플리케이션에서 사용할 수 있습니다.\n","date":"2024-09-30","permalink":"/post/2024/2024-09-30-using-.env-in-fastapi/","section":"post","summary":"환경별로 여러 개의 .env 파일을 사용하여 설정을 관리하는 방법.\n","title":"FastAPI에서 .env 파일 사용하기"},{"content":"Nginx 서버에서 여러 도메인에 대해 CORS(Cross-Origin Resource Sharing)를 설정하는 방법에 대해 알아보겠습니다.\nexample.co.kr 도메인과 그 서브도메인들에 대한 CORS 설정을 예로 들어 설명하겠습니다.\nCORS란? CORS는 웹 브라우저에서 실행되는 스크립트가 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 메커니즘입니다. 보안상의 이유로 브라우저는 기본적으로 이를 제한하지만, 서버에서 적절한 CORS 헤더를 설정하면 이 제한을 완화할 수 있습니다.\nNginx 설정 살펴보기 다음은 Nginx에서 CORS를 설정하는 예시 설정입니다:\n# CORS 허용 도메인 설정 map $http_origin $cors_origin { default \u0026#34;\u0026#34;; \u0026#34;~^https?://([a-z0-9.-]+\\\\.)?example\\\\.co\\\\.kr(:[0-9]+)?$\u0026#34; $http_origin; \u0026#34;~^https?://([a-z0-9.-]+\\\\.)?sample\\\\.co\\\\.kr(:[0-9]+)?$\u0026#34; $http_origin; } server { listen 443 ssl; server_name api.example.co.kr; # SSL 설정 (생략) location / { add_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;$cors_origin\u0026#39; always; add_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, DELETE, PATCH, PUT, OPTIONS\u0026#39;; add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;Content-Type, Authorization, X-Requested-With, Accept, Access\u0026#39;; add_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; if ($request_method = \u0026#39;OPTIONS\u0026#39;) { return 204; } # 프록시 설정 (생략) } } 주요 설정 설명 CORS 허용 도메인 설정:\nmap $http_origin $cors_origin { default \u0026#34;\u0026#34;; \u0026#34;~^https?://([a-z0-9.-]+\\\\.)?example\\\\.co\\\\.kr(:[0-9]+)?$\u0026#34; $http_origin; } 이 설정은 example.co.kr 도메인과 그 서브도메인들에 대해 CORS를 허용합니다. 정규표현식을 사용하여 유연하게 도메인을 매칭합니다.\nCORS 헤더 설정:\nadd_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;$cors_origin\u0026#39; always; $cors_origin 변수를 사용하여 동적으로 허용된 오리진을 설정합니다.\n허용된 메서드와 헤더:\nadd_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, DELETE, PATCH, PUT, OPTIONS\u0026#39;; add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;Content-Type, Authorization, X-Requested-With, Accept, Access\u0026#39;; 허용된 HTTP 메서드와 요청 헤더를 지정합니다.\nCredentials 허용:\nadd_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; 인증 정보(쿠키, HTTP 인증 등)를 포함한 요청을 허용합니다.\nPreflight 요청 처리:\nif ($request_method = \u0026#39;OPTIONS\u0026#39;) { return 204; } OPTIONS 메서드로 오는 preflight 요청에 대해 204 No Content 응답을 반환합니다.\n결론 이 설정을 통해 example.co.kr 도메인과 그 서브도메인들에서 오는 CORS 요청을 안전하게 처리할 수 있습니다. 필요에 따라 정규표현식을 수정하여 다른 도메인도 추가할 수 있습니다.\nCORS 설정은 보안과 밀접한 관련이 있으므로, 항상 필요한 도메인만 허용하고 정기적으로 설정을 검토하는 것이 좋습니다.\n","date":"2024-09-27","permalink":"/post/2024/2024-09-27-setting-up-multi-domain-cors-in-nginx/","section":"post","summary":"Nginx 서버에서 여러 도메인에 대해 CORS(Cross-Origin Resource Sharing)를 설정하는 방법에 대해 알아보겠습니다.\n","title":"Nginx에서 다중 도메인 CORS 설정하기"},{"content":"자바스크립에서 요긴하게 쓸 수 있는 한 줄 짜리 코드 들을 공유 합니다.\n배열 섞기 배열을 랜덤으로 섞어 줍니다.\nconst shuffleArray = (arr) =\u0026gt; arr.sort(() =\u0026gt; Math.random() - 0.5); const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; console.log(shuffleArray(arr)); 클립보드 복사하기 const copyToClipboard = (text) =\u0026gt; navigator.clipboard?.writeText \u0026amp;\u0026amp; navigator.clipboard.writeText(text); copyToClipboard(\u0026#34;Hello World!\u0026#34;); 유니크 배열 const getUnique = (arr) =\u0026gt; [...new Set(arr)]; const arr = [1, 1, 2, 3, 3, 4, 4, 4, 5, 5]; console.log(getUnique(arr)); 배열 체크 const isArray = (arr) =\u0026gt; Array.isArray(arr); console.log(isArray([1, 2, 3])); // true console.log(isArray({ name: \u0026#39;Ovi\u0026#39; })); // false console.log(isArray(\u0026#39;Hello World\u0026#39;)); // false 랜덤 숫자 const randomInt = (min, max) =\u0026gt; Math.floor(Math.random() * (max - min + 1) + min); console.log(random(1, 50)); 다크 모드 검출 const isDarkMode = () =\u0026gt; window.matchMedia \u0026amp;\u0026amp; window.matchMedia(\u0026#34;(prefers-color-scheme: dark)\u0026#34;).matches; console.log(isDarkMode()); 스크롤 맨 위로 / 아래로 const scrollToTop = (element) =\u0026gt; element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;start\u0026#34; }); const scrollToBottom = (element) =\u0026gt; element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;end\u0026#34; }); 랜덤 색상 생성기 const generateRandomHexColor = () =\u0026gt; `#${Math.floor(Math.random() * 0xffffff).toString(16)}`; 날짜 사이 계산하기 const daysDiff = (date, date2) =\u0026gt; Math.ceil(Math.abs(date - date2) / 86400000); console.log(daysDiff(new Date(\u0026#39;2022-05-10\u0026#39;), new Date(\u0026#39;2022-11-25\u0026#39;))); // 199 값 바꾸기 let foo = \u0026#39;foo\u0026#39;; let bar = \u0026#39;bar\u0026#39;; [foo, bar] = [bar, foo]; console.log(foo, bar); // bar foo 배열 합치기 // 배열을 합칩니다. 하지만, 중복은 유지 const merge = (a, b) =\u0026gt; a.concat(b); // 또는 const merge = (a, b) =\u0026gt; [...a, ...b]; // 중복을 제거 하면서 합침 const merge = [...new Set(a.concat(b))]; // 또는 const merge = [...new Set([...a, ...b])]; 자바스크립트 실제 유형 가져오기 const trueTypeOf = (obj) =\u0026gt; { return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase(); }; console.log(trueTypeOf(\u0026#39;\u0026#39;)); // string console.log(trueTypeOf(0)); // number console.log(trueTypeOf()); // undefined console.log(trueTypeOf(null)); // null console.log(trueTypeOf({})); // object console.log(trueTypeOf([])); // array console.log(trueTypeOf(0)); // number console.log(trueTypeOf(() =\u0026gt; {})); // function 긴 문자열 자르기 const truncateString = (string, length) =\u0026gt; { return string.length \u0026lt; length ? string : `${string.slice(0, length)}...`; }; console.log(truncateString(\u0026#39;동해 물과 백두산이 마르고 닳도록\u0026#39;, 10)); // 동해 물과 백두산이 현재 탭이 보이고 있는지 체크 const isTabInView = () =\u0026gt; !document.hidden; // Not hidden console.log(isTabInView()); // true or false 숫자 앞에 0붙여서 출력하기 const numberPad = (num, size) =\u0026gt; String(num) .padStart(size, \u0026#39;0\u0026#39;) .substring(-size); console.log(numberPad(5, 3)); // 005 빈 배열 체크 const checkEmptyArray = (arr) =\u0026gt; !Array.isArray(arr) || arr.length === 0; console.log(checkEmptyArray([0, 2, 3, 4, 5])); // true console.log(checkEmptyArray([])); // false console.log(checkEmptyArray(\u0026#34;\u0026#34;))y(arr3)); // false ","date":"2022-02-26","permalink":"/post/2022/2022-02-26-one-liners-in-javascript/","section":"post","summary":"자바스크립에서 요긴하게 쓸 수 있는 한 줄 짜리 코드 들을 공유 합니다.\n","title":"유용한 한 줄 자바스크립트"},{"content":"vscode에서 typescript를 사용한 express 프로젝트를 시작 하면서 설정하는 기본적인 작업을 정리해 봅니다.\nVSCode의 설치 할 확장 프로그램 우선 VSCode에 ESLint와 Prettier를 설치해 줍니다.\nESLint : https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint Prettier : https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode ESLint는 자바스크립트 코드의 문법적인 오류나 안티 패턴을 찾아주고 일관된 코드 스타일을 작성하도록 도와줍니다. 원래는 TSLint라고 해서 타입스크립트용 Lint가 별도로 있었지만, 작년(2019)부터 ESLint로 통합되서 운영하게 되었습니다.\nPrettier는 정해진 규칙에 따라서 자동으로 코드를 수정/정리해 주는 도구 입니다. 다양한 언어를 지원하고 있습니다.\nExpress 기본 설정하기 먼저 npm init을 통해서 package.json파일을 만들어 줍니다.\nnpm init -y 그리고 express를 설치해 줍니다.\nnpm install express 설치가 완료 되면 typescript와 @types/express를 설치해 줍니다.\nnpm install --save-dev typescript @types/express @types로 시작하는 패키지를 타입스크립트에서 자료형을 설정해 둔 패키지로 소스코드에서 타입을 검사하고, vscode에서 자동 완성 할 때 도움이 됩니다.\n./src 폴더를 만들고 app.ts 파일을 만들어서 아래와 같이 입력해 주세요.\n./src/app.ts\nimport * as express from \u0026#39;express\u0026#39;; const app = express(); const port = process.env.PORT || 3000; app.get(\u0026#39;/\u0026#39;, (req: express.Request, res: express.Response) =\u0026gt; { res.send(\u0026#39;Hello World!\u0026#39;); }); app.listen(port, () =\u0026gt; { console.log(`Example app listening on port ${port}!`); }); ts-node-dev를 설치해 줍니다.\nnpm install -D ts-node-dev ts-node-dev 는 ts-node와 흡사해서 .ts을 자바스크립트 파일을 컴파일 하지 않고도 바로 실행 할 수 있도록 해 줍니다. 그리고 추가로 파일이 변경 되었을 경우 다시 실행 하는 기능과 inspect를 통해서 디버깅을 할 수 있도록 도와 줍니다.\n그러면 파일을 실행하기 위해서, package.json 파일의 scripts 부분에 아래와 같이 추가해 줍니다.\n{ // ... \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;ts-node-dev --inspect --watch -- ./src/app.ts\u0026#34; }, //... } --inspect : vscode에서 디버깅 할 때 사용 됩니다. --watch : 소스 코드를 수정하면 다시 로드해 줍니다. -- : 뒤에 실행할 파일을 넣어 줍니다. 앞 쪽에 옵션이 들어가 있을경우 사용합니다. 위와 같이 실행 환경이 설정 되면 아래와 같이 실행을 해 주시면 됩니다.\nnpm run dev 웹 브라우저에서 http://127.0.0.1:3000 주소로 접속해서 정상적으로 접속이 되는지 확인 합니다.\ntsconfig.json 파일 설정하기 타입스크립트를 프로젝트에서 사용하기 위해서는 tsconfig.json라는 파일을 통해서 타입스크립트 설정을 해 줘야 합니다. 직접 파일을 생성해서 넣어 줄 수도 있겠지만 tsc 명령어를 통해서 설정을 할 수도 있습니다.\nnpx tsc --init tsconfig.json 파일의 대부분의 스펙이 들어 있습니다. 간단하게 express만 사용하려면 아래와 같은 정도만 설정을 하시면 됩니다.\ntsconfig.json\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;,\t/* 컴파일 후 생성될 파일의 ECMAScript 버전 */ \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;,\t/* 컴파일 후 생성될 파일이 사용하는 모듈 버전 */ \u0026#34;outDir\u0026#34;: \u0026#34;dist/\u0026#34;,\t/* 파일이 생성될 폴더 */ \u0026#34;esModuleInterop\u0026#34;: true\t/* \u0026#39;require\u0026#39;와 \u0026#39;import\u0026#39; 호환 */ }, \u0026#34;include\u0026#34;: [\u0026#34;src/*.ts\u0026#34;]\t/* 사용할 폴더 및 파일 */ } 하지만, 이것저것 다른 패키지와 타입스크립트의 데코레이션 기능등을 사용 하시려면 아래와 같이 설정하시길 추천 듭니다.\ntsconfig.json\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;lib\u0026#34;: [\u0026#34;es2016\u0026#34;,\u0026#34;esnext.asynciterable\u0026#34;], /* 컴파일에 포함될 라이브러리 */ \u0026#34;types\u0026#34;: [\u0026#34;node\u0026#34;], /* 타입 정의가 포함될 이름의 목록 */ \u0026#34;target\u0026#34;: \u0026#34;es2016\u0026#34;, /* 타겟의 ECMASCript 버전 */ \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, /* 모듈 코드 생성 지정 */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, /* 모듈 해석 방법 */ \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, /* 결과물 디렉토리 */ \u0026#34;strict\u0026#34;: true, /* 엄격한 타입 검사 옵션 활성화 */ \u0026#34;emitDecoratorMetadata\u0026#34;: true, /* 소스에 데코레이터 선언에 대한 설계-타입 메타 데이터를 보냄 */ \u0026#34;experimentalDecorators\u0026#34;: true, /* ES 데코레이터에 활성화 */ \u0026#34;sourceMap\u0026#34;: true, /* 소스맵 사용 */ \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, /* default export가 없는 모듈에서 default imports를 허용 */ \u0026#34;esModuleInterop\u0026#34;: true, /* \u0026#39;require\u0026#39;와 \u0026#39;import\u0026#39; 호환 */ \u0026#34;skipLibCheck\u0026#34;: true, /* 모든 선언 파일(*.d.ts)의 타입 검사 생략 */ \u0026#34;resolveJsonModule\u0026#34;: true, /* .json 확장자로 import된 모듈을 포함 */ }, \u0026#34;include\u0026#34;: [ \u0026#34;./src/**/*\u0026#34;, ], \u0026#34;exclude\u0026#34;: [ \u0026#34;node_modules\u0026#34;, \u0026#34;src/test\u0026#34;, \u0026#34;**/*.spec.ts\u0026#34;, \u0026#34;**/*.test.ts\u0026#34;, ] } 이렇게 설정까지 설정을 하시고 tsc를 실행 하시면 dist폴더에 소스가 컴파일 되서 실행 되는걸 확인 할 수 있습니다.\nnpx tsc VSCode 디버깅 설정 .vscode 폴더가 없다면 폴더를 생성하고 ./.vscode/launch.json파일을 아래와 같이 입력해 줍니다.\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Launch Program\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/src/app.ts\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;npm: build\u0026#34;, \u0026#34;env\u0026#34;: { \u0026#34;SRC_PATH\u0026#34;: \u0026#34;dist/\u0026#34; }, \u0026#34;sourceMaps\u0026#34;: true, \u0026#34;smartStep\u0026#34;: true, \u0026#34;internalConsoleOptions\u0026#34;: \u0026#34;openOnSessionStart\u0026#34;, \u0026#34;outFiles\u0026#34;: [ \u0026#34;${workspaceFolder}/dist/**/*.js\u0026#34; ] }, { \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;attach\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Attach to Inspector\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;inspector\u0026#34;, \u0026#34;port\u0026#34;: 9229, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceRoot}\u0026#34; } ] } 이제 브레이크 포인트를 걸고 싶은 행 앞을 클릭하거나 F9키를 누르면 행 앞에 빨간색 원이 생깁니다.\n이게 왼쪽의 디버그메뉴를 선택하거나 Ctrl+Shift+D키를 눌러서 디버그 메뉴로 이동하고 Launch Program을 선택하고 F5 버턴을 누르면 설정했던 중단점에 로직이 가게 되면 프로그램이 중단되면서 프로그램의 상태를 확인 할 수 있게 됩니다.\n또는 터미널에서 npm run dev로 프로그램을 실행 후 디버그 메뉴에서 Attach to Inspector를 선택하고 F5를 누르면 일일히 실행하지 않고도 중간 부터 디버깅을 하실 수 있게 됩니다.\nESLint 설정 이제 ESLint를 설정해 줄 차례입니다. 먼저 eslint를 아래와 같이 설치해 줍니다.\nnpm install --save-dev eslint 그리고 eslint --init을 통해서 기본 설정을 해 줍니다.\nnpx eslint --init 전 위 그림과 같이 설정을 했습니다.\n위와 같이 선택을 한 경우에는 @typescript-eslint/eslint-plugin와 @typescript-eslint/parser 패키지가 자동으로 설치가 됩니다.\nPrettier 설정 prettier에 사용될 패키지를 아래와 같이 설채해 줍니다.\nnpm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier 그리고 prettier의 설정 파일인 .prettierrc.json파일을 생성하고 아래와 같이 편집해 줍니다.\n.prettierrc.json\n{ \u0026#34;printWidth\u0026#34;: 100, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;useTabs\u0026#34;: false, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;quoteProps\u0026#34;: \u0026#34;consistent\u0026#34;, \u0026#34;trailingComma\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;endOfLine\u0026#34;: \u0026#34;auto\u0026#34; } 제 프리티어의 설정은 위와 같습니다.\n.eslintrc.json를 편집해서 eslint와 prettier를 연결해 줍니다.\n{ \u0026#34;env\u0026#34;: { \u0026#34;es2020\u0026#34;: true, \u0026#34;node\u0026#34;: true }, \u0026#34;extends\u0026#34;: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/eslint-recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;plugin:prettier/recommended\u0026#34;, \u0026#34;prettier/@typescript-eslint\u0026#34; ], \u0026#34;parser\u0026#34;: \u0026#34;@typescript-eslint/parser\u0026#34;, \u0026#34;parserOptions\u0026#34;: { \u0026#34;ecmaVersion\u0026#34;: 11, \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34; }, \u0026#34;plugins\u0026#34;: [ \u0026#34;@typescript-eslint\u0026#34; ], \u0026#34;rules\u0026#34;: { }, \u0026#34;ignorePatterns\u0026#34;: [ \u0026#34;dist/\u0026#34;, \u0026#34;node_modules/\u0026#34; ] } extends에서 설정은 eslint와 prettier를 연결해 주고,\nignorePatterns에서 eslint검사를 dist 폴더와 node_modules 폴더의 파일은 생략하는 코드 입니다.\n저장시 자동 포맷 설정하기 이제 파일을 저장 할 때\n./vscode/settings.json 파일을 아래와 같이 편집해 줍니다.\n{ \u0026#34;[typescript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll\u0026#34;: true, \u0026#34;source.organizeImports\u0026#34;: true } } } 위와 같이 설정하면 타입스크립트 파일 일 경우 위와 같은 아래와 같은 동작을 합니다.\neditor.defaultFormatter : 파일을 포맷터를 지정 합니다. source.fixAll : 소스를 저장 할 때 설정에 맞게 포맷팅을 해 줍니다. source.organizeImports : 소스 저장시 import를 정리해 줍니다. 여기까지 설정을 하게 되면 기본적인 개발 환경 설정이 완료 됩니다.\n여기까지 내용은 github에 정리해서 소스로 올려 뒀습니다.\n소스 주소 https://github.com/gyuha/express-typescript-eslint 참고 사이트 VSCode에서 ESLint와 Prettier (+ TypeScript) 사용하기 Express with TypeScript setup 타입스크립트 컴파일러 옵션 Intro to the TSConfig Reference How to use ESLint with TypeScript ","date":"2020-06-10","permalink":"/post/2020/2020-06-10-express-typescript-eslint/","section":"post","summary":"vscode에서 typescript를 사용한 express 프로젝트를 시작 하면서 설정하는 기본적인 작업을 정리해 봅니다.\n","title":"Typescript를 사용한 Express 프로젝트 설정하기(with Eslint)"},{"content":"APK 파일의 리소스를 편집해야 할 일이 있어서 찾아 보다가, 참 편한 프로그램이 있어서 기록을 남겨 둡니다.\nAPK EDITOR STUDIO https://qwertycube.com/apk-editor-studio/\nAPK 에디터 스튜디오는 무료 APK 에디터입니다.\n이 어플리케이션은 APK의 기능은 어떻게 보면 단순 합니다.\n앱 아이콘 변경 앱 제목 변경 APK 리소스 편집 APK 서명 APK 설치 예전에는 이런 작업을 하려면, 여러가지 어플리케이션을 받아서 조합해서 사용 했었는데.\nAPK 에디터 하나면 이 기능들을 모두를 하나의 어플리케이션에서 할 수 있으며, 편집된 APK를 바로 설치까지 할 수 있게 해 줍니다.\nAPK 리소스를 편집해야 할 일이 있다면 꼭 사용해 보시기 바랍니다.\n참고 아래 사이트는 참고 사항입니다.\n아래 링크를 차근차근 따라가 보시면, 이 프로그램이 참 편하구나 싶을 겁니다.\nAndroid APK 디컴파일 방법 안드로이드 어플리케이션 디컴파일 및 리패키징 Android 앱 분석 (APK) ","date":"2020-05-20","permalink":"/post/2020/2020-05-20-apk-editor-studio/","section":"post","summary":"APK 파일의 리소스를 편집해야 할 일이 있어서 찾아 보다가, 참 편한 프로그램이 있어서 기록을 남겨 둡니다.\n","title":"안드로이드 APK 리소스 편집하기"},{"content":"워드프레스로 만든 홈페이지 보안 적용 정리..\n5년 전에 워드프레스(wordpress)로 홈페이지를 제작한 적이 있는데, 어느 순간부터 홈페이지가 이상한 사이트로 이동을 하는 겁니다. 처음에는 단순하게 홈페이지를 복구 했는데, 복구해도 계속 같은 증상이 반복이 되었습니다. 그래서 워드프레스 버전이 낮아서 그런가 해서 php를 7.3으로 올리고 워드프레스를 최신으로 업데이트를 했습니다. 하지만 같은 증상이 반복 되는 겁니다. 결국은 기존에 감염된 파일을 찾아내서 삭제하고 보안을 강화하는 형식으로 홈페이지를 복구 했습니다. 이렇게 한달을 운영하면서 보안이 문제가 없어 보여서 여기에 정리해 봅니다.\n아래 작업을 시작하기 전에 단계마다 사이트와 DB를 백업 하시면서 하시는걸 추천 드립니다.\n보안 플러그인 설치 워드프레스 플러그인 추가에서 security라고 검색을 해 보면 백여개가 넘는 플러그인들이 검색이 됩니다. 이 중에서 평점이 높고 사용자들이 많이 설치한 플러인 위주로 설치하고 사용해 봤습니다. 그리고 3개의 플러그인을 사용하고 있습니다.\niThemes Security Link : iThemes Security\n가장 많은 도움을 받은 플러그인입니다. 관리자 메뉴에서 Settings를 열어 보면 다양한 설정들이 보입니다. 차근차근 하니씩 설정해 주면 됩니다. 대부분의 보안 설정을 진행 할 수 있습니다.\n그리고 가장 추천하는 설정은 File Change Detection입니다. 사이트에서 파일이 변경된 사항을 추적해서 기록해 주며, 메일로도 알려줍니다. 초기에 세팅을 해 놓고 사이트에 문제가 없는지 확인하는데 도움을 많이 줍니다.\nWordfence Security Link : Wordfence Security\n사이트에 대한 공격을 모니터링해 줍니다. 사이트에 공격이 들어오면 알아서 막아도 주면서 해당 IP를 블럭해서 공격을 막아 줍니다. 관리자 메뉴 중에서 Live Traffic이라는 메뉴가 있는데, 여기서 로그인 시도나 해킹 시도에 대한 로그를 조회 해 볼 수 있습니다. 여기를 잘 파악해 보면, \u0026ldquo;아~ 이런식으로 해킹을 시도하는구나\u0026rdquo; 알게 됩니다.\n그리고, 2차 인증(Two-Factor Authentication)기능으로 OTP를 연결해 준다면 로그인 시도에 관련된 공격으로 부터 많이 안전해 집니다.\nSucuri Security Link: Sucuri Security\n앞에 2개의 플러그인 기능과 많이 겹치긴 하지만 보조적인 역할로 설치해 줬습니다. 보안 활동 감시 및 멀웨어 검사등의 기능을 합니다.\n이렇게 위 3개의 플러그인에서 중복되는 기능도 있긴 하지만, 혹시나 모를 안정성을 위해서 3개를 설치 했습니다.\n개인적인 의견으로는 iThemes Security와 Wordfence Security만 설치 해도 충분 할 것으로 보입니다.\n손으로 벌레 잡기 위 플러그인을 설치하면 멀웨어나 다양한 형태의 해킹 시도를 감지 할 수 있습니다. 하지만 플러그인 만으로도 잡히지 않는 경우들 있습니다. 이럴때 하나씩 잡아야 합니다.\n의심되는 파일 찾기 find . -type f -name \u0026#39;*.php\u0026#39; | xargs grep -l \u0026#34;eval *(\u0026#34; find . -type f -name \u0026#39;*.php\u0026#39; | xargs grep -l \u0026#34;base64_decode *(\u0026#34; find . -type f -name \u0026#39;*.php\u0026#39; | xargs grep -l \u0026#34;gzinflate *(\u0026#34; eval은 함수는 php에서 가변 변수를 사용하게 해주는 함수로 가변 변수를 이용해서 다양한 해킹 시도하는 멀웨어 파일에서 자주 사용 됩니다. base64_decode와 gzinflate는 함수는 스트링을 난독화 시켜서 사용자가 php파일을 바로 해독하기 어렵도록 해 줍니다.\n이렇게 3개의 단어를 검색해서 전혀 쓰이지 않을것 같은 파일이나 의심스러운 파일은 수정하거나 삭제해 주는 것이 좋습니다.\nfind . -type f -name \u0026#39;*.php\u0026#39; | grep -i \u0026#39;\u0026lt;iframe\u0026#39; php파일에 iframe이 들어 있는지를 검사합니다.\nfind wp-content/uploads -type f -iname \u0026#39;*.jpg\u0026#39; | xargs grep -i php jpg 파일이지만 안에 php가 들어있는 멀웨어 공격을 검사합니다.\n업로드 폴더 검사 업로드 폴더에 올라간 php실행 파일을 찾아 수상한 파일들은 삭제를 해 줍니다.\nfind wp-content/uploads -type f -name \u0026#39;*.php\u0026#39; 최근에 변경된 파일 찾기 find . -type f -name \u0026#39;*.php\u0026#39; -mtime -7 최근 7일간 php 파일중에서 변경되 파일의 목록을 출력해 줍니다.\n.htaccess 편집하기 .htaccess를 편집하면 사이트 접근을 제한 할 수 있습니다. 보안 플러그인에서도 .htaccess파일을 편집해 줍니다.\n하지만, 일부는 직접 수정해서 원하는 대로 설정을 할 수 있습니다.\n디렉토리 브라우징 끄기 대부분은 빈 index.php 파일을 만들어서 빈 디렉토리의 브라우징을 못 하도록 처리를 해 두긴 하지만, .htaccess파일에서도 이 기능을 끌 수 있습니다.\nOptions -Indexes wp-config.php 파일을 보호해 주기 wp-config.php파일에는 사이트의 중요한 정보를 가지고 있습니다. 웹에서 바로 접근을 할 수 없도록 설정해 줍니다. .htaccess파일에 아래의 내용을 추가해 줍니다.\n\u0026lt;files wp-config.php\u0026gt; order allow,deny deny from all \u0026lt;/files\u0026gt; XML-RPC파일 접근 끄기 xmlrpc.php 파일은 워드프레스 서드파트 앱에서 사이트를 접근하도록 해 줍니다. 만약에 서드파티 앱을 사용하지 않는다면 이 기능을 꺼 주는게 좋습니다. .htaccess파일에 아래의 내용을 추가해 줍니다.\n\u0026lt;Files xmlrpc.php\u0026gt; order deny,allow deny from all \u0026lt;/Files\u0026gt; iThemes Security에서도 설정이 가능 합니다.\n스크립트 인젝션 끄기 해커가 깆존 php문서에 악성코드를 삽입하지 못 하도록 스크립트 삽입을 허용하지 않습니다. .htaccess파일에 mode_rewrite 부분에 아래의 내용을 추가해 줍니다.\n\u0026lt;IfModule mod_rewrite.c\u0026gt; ... Options +FollowSymLinks RewriteEngine On RewriteCond %{QUERY_STRING} (\u0026lt;|%3C).*script.*(\u0026gt;|%3E) [NC,OR] RewriteCond %{QUERY_STRING} GLOBALS(=|[|%[0-9A-Z]{0,2}) [OR] RewriteCond %{QUERY_STRING} _REQUEST(=|[|%[0-9A-Z]{0,2}) RewriteRule ^(.*)$ index.php [F,L] \u0026lt;/IfModule\u0026gt; 특정 ip에서만 wp-admin 폴더를 접근 허용 wp-admin은 관리자 폴더 입니다. 특정 ip에서만 wp-admin을 접근 할 수 있도록 제한 합니다.\nwp-admin폴더에 .htaccess파일을 만들고 아래 내용을 추가해 줍니다.\n\u0026lt;Limit GET POST\u0026gt; order deny,allow deny from all allow from 1.2.3.4 allow from 1.2.3.5 \u0026lt;/Limit\u0026gt; 기본적으로 접근을 제한하고, 그리고 관리자 메뉴에 접근해야 하는 ip만을 위와 같이 등록해 줍니다.\n특정 워드프레스 폴더에서 php 실행 방지하기 몇몇 해커들은 워드프레스 사이트의 업로드 기능을 이용해서 백도어를 설치하는 해킹을 시도 합니다. 이렇게 설치된 파일이 직접 실행이 않도록 /wp-include/ ,/wp-content/uploads/ 폴더등에서는 php가 실행되지 않도록 처리해 줄 수 있습니다.\n/wp-include/ 폴더와 /wp-content/uploads 폴더에 .htaccess파일을 생성하고 아래와 같이 넣어 줍니다.\n\u0026lt;Files *.php\u0026gt; deny from all \u0026lt;/Files\u0026gt; 파일과 폴더의 접근 권한 설정하기 파일과 폴더에 좀 더 엄격한 접근 권한 설정을 해서 파일이 변경 되지 않도록 방지 합니다.\n각 폴더의 권장하는 권한은 아래와 같습니다.\n경로 권한 / 755 .htaccess 444 wp-includes 755 wp-admin 755 wp-admin/js 755 wp-content 755 wp-content/themes 755 wp-content/plugins 755 wp-content/uploads 755 wp-config.php 444 그외 팁 바이러스 검사하기 되도록이면 유명하거나 검증된 플러그인이나 테마를 사용하는 것이 좋습니다. 하지만 꼭 사용하고 싶다면 플러그인 또는 테마를 사용하기 전에 바이러스 검사를 해 볼 수 있습니다. 해당 플러그인이나 테마를 다운로드 받고 나서 VirusTotal 사이트에서 검사를 해 보면 일차적으로 멀웨어가 있는지 체크가 가능 합니다.\n정리 워드프레스는 정말 많은 사이트에서 사용되는 콘텐츠 관리 플랫폼입니다. 전체 웹사이트중 36%가 워드프레스로 구축 되어 있을 정도입니다. 많은 사이트에서 사용하는 만큼 취약점이 발견되면 바로 업데이트가 이루어 지고 있어서 워드프레스 자체만으로는 보안에 취약하지는 않습니다.\n하지만, 간단한 검색만으로 사이트가 워드프레스로 제작되어 있는지 확인이 가능하며, 워드프레스로 제작이 되어 있다면, 이전 버전들에서 노출된 보안의 헛점을 이용해서 공격하는 많은 방법이 공개 되어 있어서, 공격의 대상이 되기 쉽니다. 그리고, 누구나 만들 수 있는 플러그인과 테마로 인해서, 개발자가 본의 아니게 보안에 취약한 플러그인이 만들어 질 수도 있으며, 이런 취약점이 노출이 되면 사이트 보안에 문제가 발생하게 됩니다.\n워드프레스는 아래 3가지 정도면 잘 지키면 보안에 별 문제가 없어 보입니다.\n워드프레스, 테마, 플러그인을 항상 최신 버전으로 유지 한다. 플러그인은 되도록이면 검증된 플러그인으로 설치하고 최소한으로 설치한다. 보안 플러그인은 꼭 사용한다. 이렇게 3가지 정도면 보안에 문제가 발생하지 않는거 같습니다.\n그리고 추가로 혹시나 모를 문제를 방지하기 위해서 정기적인 백업도 잊지 말아야 합니다.\n복구 시점을 만들어 주는것 뿐만 아니라.. 변경 사항을 비교해 보면 보안의 취약점을 찾는데 도움이 됩니다.\n참고자료 \u0026lsquo;만만한 타깃\u0026rsquo; 워드프레스 보안 강화 툴·방법 총정리 워드프레스 보안 강화를 위한 기본적인 세 가지 방법 워드프레스 웹사이트 보안을 위한 10가지 노하우 The Ultimate WordPress Security Guide – Step by Step (2020) 12 Most Useful .htaccess Tricks for WordPress WordPress Security – 19 Steps to Lock Down Your Site Comprehensive WordPress Malware Removal Guide How to Tell if Your PHP Site has been Hacked or Compromised ","date":"2020-05-19","permalink":"/post/2020/2020-05-19-wordpress_security/","section":"post","summary":"워드프레스로 만든 홈페이지 보안 적용 정리..\n","title":"워드프레스 보안 설정"},{"content":"Vue 프로젝트 생성하기 기존에 사용하던 TSLint가 더이상 지원을 받지 못 하게 되면서, ESlint로 넘어가야 상태가 되었습니다.\n여기서는 Vue 프로젝트를 생성하면서 ESlint와 Prettier를 사용하는 세팅을 간단하게 설정하려고 합니다. 사용하는 툴은 vscode입니다.\nvue create myproject 형태로 기본 프로젝트를 선택 합니다.\n\u0026gt; npx vue create myproject ? Please pick a preset: Manually select features ? Check the features needed for your project: (*) Babel (*) TypeScript ( ) Progressive Web App (PWA) Support ( ) Router ( ) Vuex (*) CSS Pre-processors \u0026gt;(*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing ? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? (Y/n) Y ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): \u0026gt; Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) Less Stylus ? Pick a linter / formatter config: ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config \u0026gt; ESLint + Prettier TSLint (deprecated) ? Pick additional lint features: (Press \u0026lt;space\u0026gt; to select, \u0026lt;a\u0026gt; to toggle all, \u0026lt;i\u0026gt; to invert selection) \u0026gt;(*) Lint on save ( ) Lint and fix on commit ? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys) \u0026gt; In dedicated config files In package.json 여기서 처음 체크 박스에서 Linter / Formatter를 꼭 선택해 주시고, Linter / Formatter는 ESLint + Prettier를 선택해 줍니다.\n\u0026gt; cd myproject \u0026gt; code . 그리고 위와 같이 vscode를 실행 해 줍니다.\nVSCode 설정하기 만약 VSCode에는 아래와 같은 확장 프로그램을 설치가 되어 있지 않으면 설치를 해 줍니다.\nESLint Prettier - Code formatter Vetur 그리고, vscode의 설정에서 아래와 내용을 추가해 줍니다.\n{ \u0026#34;[typescript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true }, \u0026#34;[vue]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true } } 여기까지 하면 vscode에서 파일을 저장 할 때 알아서 포맷팅을 해 주고 저장을 해 주게 됩니다.\n마지막으로 추가로 좀 더 상세한 설정을 하고 싶다면, 프로젝트 루트 폴더에 .prettierrc.json파일을 만들고 상세한 설정을 해 주시면 됩니다. 아래와 같은 형식으로 만들어 주시면 됩니다.\n{ \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: false, \u0026#34;trailingComma\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: false, \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34; } 상세한 내용은 아래 링크를 확인 하시면 됩니다.\nhttps://prettier.io/docs/en/options.html 참고 Setup Prettier and ESLint for Typescript https://prettier.io/ Typescript ESLint 설정하기 ESLint - 4. Prettier 적용 ","date":"2020-04-19","permalink":"/post/2020/2020-04-19-vue-typescript-eslint/","section":"post","summary":"Vue 프로젝트 생성하기 기존에 사용하던 TSLint가 더이상 지원을 받지 못 하게 되면서, ESlint로 넘어가야 상태가 되었습니다.\n","title":"Vscode에서 vue 프로젝트 생성시 ESlint와 Prettier 설정해 주기"},{"content":"자바스크립트의 배열을 메서드를 정리해 봅니다.\nArray 추가/삭제 Array.push() 배열의 마지막 요소를 추가해 줍니다.\nlet number_arr = [ 1, 2, 3, 4, 5 ]; number_arr.push(6); console.log(number_arr); // [ 1, 2, 3, 4, 5, 6 ] Output :\n[1, 2, 3, 4, 5, 6]\nArray.unshift() 배열의 가장 첫번째 요소를 추가해 줍니다.\nlet number_arr = [ 1, 2, 3, 4, 5 ]; number_arr.unshift(6); console.log(number_arr); // [ 6, 1, 2, 3, 4, 5 ] Output :\n[6, 1, 2, 3, 4, 5]\nArray.pop() 배열의 가장 마지막 요소를 삭제 합니다.\nlet number_arr = [ 1, 2, 3, 4, 5 ]; let pop = number_arr.pop(); console.log(number_arr); // [ 1, 2, 3, 4 ] console.log(pop); // 5 Output :\n[1, 2, 3, 4]\n5\nArray.shift() 배열에서 가장 첫번째 요소를 삭제합니다.\nlet number_arr = [ 1, 2, 3, 4, 5 ]; let shift = number_arr.shift(); console.log(number_arr); // [ 2, 3, 4, 5 ] console.log(shift); // 1 Output :\n[2, 3, 4, 5]\n1\nArray.slice() 기존 배열은 변하지 않고, 해당 요소를 반환 합니다.\nlet number_arr = [ 1, 2, 3, 4, 5 ]; // Syntax : Array.slice(시작위치, 끝위치) let sp = number_arr.slice(1, 3); // 2번째 부터 3번째 까지 반환합니다. console.log(number_arr); // [1, 2, 3, 4, 5] console.log(sp); // [2, 3] sp = number_arr.slice(2); console.log(sp); // [3, 4, 5] Output :\n[1, 2, 3, 4, 5]\n[2, 3]\n[3, 4, 5]\nArray.splice() 지정한 위치의 배열을 삭제 합니다.\nlet number_arr = [ 1, 2, 3, 4, 5 ]; // Syntax : Array.splice(시작위치, 삭제할갯수, 추가_할_아이템...) let sp = number_arr.splice(1, 2); // 2번째 요소부터 2개를 삭제 합니다. console.log(number_arr); // [ 1, 4, 5 ] console.log(sp); // [2, 3] let sp2 = number_arr.splice(1, 0, 7, 8, 9); // 2번재 요소 위치에 0개를 지우고 7,8,9를 추가해 줍니다. console.log(number_arr); // [1, 7, 8, 9, 4, 5] console.log(sp2); // undefined : 0개를 삭제해서 값이 없습니다. Output :\n[1, 4, 5]\n[2, 3]\n[1, 7, 8, 9, 4, 5]\n[]\nArray.concat() 배열을 합쳐 줍니다.\nlet num1 = [ 1, 2, 3]; let num2 = [4,5,6]; let combine = num1.concat(num2); console.log(combine); // [1, 2, 3, 4, 5, 6] let num3 = [7, 8, 9]; combine = num1.concat(num2, num3); console.log(combine); // [1, 2, 3, 4, 5, 6, 7, 8, 9] Output :\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nArray.of() 함수의 인수로 새 인스터스 배열을 만들어 줍니다.\nlet ar = Array.of(1, 2, 3) console.log(ar); // [1, 2, 3] let ch = Array.of(\u0026#34;짜장\u0026#34;, \u0026#34;짬뽕\u0026#34;); console.log(ch); // [\u0026#34;짜장\u0026#34;, \u0026#34;짬뽕\u0026#34;] Output :\n[1, 2, 3]\n[ \u0026ldquo;짜장\u0026rdquo;, \u0026ldquo;짬뽕\u0026rdquo;]\nArray 반복 Array.forEach() 배열의 요소를 순차적으로 반복해 줍니다.\nlet vl = [ \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39; ]; vl.forEach((e) =\u0026gt; { console.log(e); // one, two, three를 차례대로 출력 }) Output :\none\ntwo\nthree\n2번째 인자는 요소의 인덱스를 돌려 줍니다.\nlet vl = [ \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39; ]; vl.forEach((e, i) =\u0026gt; { console.log(e, i); }) Output :\none 0\ntwo 1\nthree 2\nArray.values() 배열의 요소를 새로운 반복형 객체로 만들어 줍니다.\nlet vl = [ \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39; ]; let iterator = vl.values(); console.log(iterator.next().value); // one console.log(iterator.next().value); // two console.log(iterator.next().value); // three console.log(iterator.next().value); // undefined Output :\none\ntwo\nthree\nundefined\nlet vl = [ \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39; ]; let iterator = vl.values(); for (let i of iterator) { console.log(i); } console.log(iterator.next().value); // undefined : 위에서 모두 반복해서 없음. Output :\none\ntwo\nthree\nArray.entries() 배열의 요소를 키(key)와 값(value)로 짝지어진 반복형 객체로 만들어 줍니다.\nlet vl = [ \u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39; ]; let iterator = vl.values(); for (let i of iterator) { console.log(i); } Output :\n[0, \u0026quot;one\u0026quot;]\n[1, \u0026quot;two\u0026quot;]\n[2, \u0026quot;three\u0026quot;]\nArray 찾기 Array.some() 배열중에서 요소가 조건식에 맞는게 1개라도 있으면 true를 반환합니다.\nconsole.log([2, 5, 8, 1, 4].some((e) =\u0026gt; e \u0026gt; 5)); console.log([2, 5, 8, 1, 4].some((e) =\u0026gt; e \u0026gt; 9)); Output :\ntrue\nfalse\nArray.every() 배열의 요소가 모두 조건식에 맞아야 true를 반환합니다.\nconsole.log([2, 5, 8, 1, 4].every((e) =\u0026gt; e \u0026lt; 9)); console.log([2, 5, 8, 1, 4].every((e) =\u0026gt; e \u0026gt; 4)); Output :\ntrue\nfalse\nArray.find() 배열에서 조건식에 맞는 첫번째 요소를 반환합니다.\nconsole.log([2, 5, 8, 1, 4].find((e) =\u0026gt; e \u0026lt; 9)); console.log([2, 5, 8, 1, 4].find((e) =\u0026gt; e \u0026gt; 4)); Output :\n2\n5\n2번째 값은 배열의 index, 3번째는 현재 배열을 입니다.\nconsole.log([2, 5, 8, 1, 4].find((e, i) =\u0026gt; e \u0026gt; 3 \u0026amp;\u0026amp; i \u0026lt; 2)); Output :\n5\nArray.findIndex() 배열에서 조건식에 맞는 첫번째 요소의 인덱스를 반환합니다.\nconsole.log([2, 5, 8, 1, 4].findIndex((e) =\u0026gt; e \u0026lt; 9)); console.log([2, 5, 8, 1, 4].findIndex((e) =\u0026gt; e \u0026gt; 4)); Output :\n0\n1\nArray.filter() 배열에서 조건식에 맞는 요소들을 배열로 반환합니다.\nconsole.log([2, 5, 8, 1, 4].filter((e) =\u0026gt; e \u0026lt; 9)); console.log([2, 5, 8, 1, 4].filter((e) =\u0026gt; e \u0026gt; 4)); Output :\n[ 2, 5, 8, 1, 4 ]\n[ 5, 8 ]\nArray.indexOf() 배열에서 요소의 위치를 찾는다. 찾을수가 없으면 -1을 반환합니다.\n두번째 값을 찾을 시작 위치 입니다.\nconsole.log([2, 5, 8, 1, 4].indexOf(2)); console.log([2, 5, 8, 1, 4].indexOf(8)); console.log([2, 1, 8, 1, 4].indexOf(1, 3)); Output :\n0\n2\n3\nArray 변환하기 Array.fill() 배열을 요소를 채워 줍니다.\nlet arr = [1, 2, 3, 4]; arr.fill(7); // 모두 7로 채워 넣는다. console.log(arr); Output :\n[ 7, 7, 7, 7 ]\n시작 지점을 정해서 채워 줄 수 있습니다. 시작 위치는 원하는 위치의 -1을 해서 넣어 줍니다.\nlet arr = [1, 2, 3, 4]; arr.fill(7, 1); // 2번째 부터 끝까지 7로 채움, 0부터 시작이다. console.log(arr); Output :\n[ 1, 7, 7, 7 ]\n시작과 끝 지점을 지정해서 채워 줄 수 있습니다. 끝 지점은 위치를 넣어 줘야 합니다.\nlet arr = [1, 2, 3, 4]; arr.fill(7, 1, 3); // 2번째 부터 3번째 까지 7로 채움 console.log(arr); Output :\n[ 1, 7, 7, 4 ]\nArray.copyWithin() 지정한 위치에 값을 복사해서 넣어 줍니다.\n첫번째는 복사할 위치, 두번째는 시작위치 (기본값:0), 세번째는 끝위치(기본값: array.length)\nvar array = [ 1, 2, 3, 4, 5, 6, 7 ]; console.log(array.copyWithin(1, 3, 5)); Output :\n[ 1, 4, 5, 4, 5, 6, 7 ]\n","date":"2020-03-15","permalink":"/post/2020/2020-03-15-javascript-arrary/","section":"post","summary":"자바스크립트의 배열을 메서드를 정리해 봅니다.\n","title":"자바스크립트 배열 메서드 정리"},{"content":"Chocolatey는 윈도우용 패키지 매니저로, 설치하려는 윈도우용 소프트웨어를 일일이 웹사이트에서 찾아서 설치할 필요 없이 간단하게 커맨드 만으로 윈도우용 소프트웨어를 설치 할 수 있게 해 줍니다.\nChocolatey 설치 chocolate를 설치 하려면 관리자 권한 cmd나 PowerShell을 실행해서 설치를 해 줘야 합니다.\ncmd 사용시 @powershell -NoProfile -ExecutionPolicy Bypass -Command \u0026#34;iex ((new-object net.webclient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;))\u0026#34; \u0026amp;\u0026amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin powershell 사용시 Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;)) 패키지 찾기 아래 웹페이지에 접속해서 검색하시면 됩니다.\nhttps://chocolatey.org/packages\n또는 cmd에서 search 나 list 명령어로 검색을 할 수 있습니다.\n\u0026gt; choco search googlechrome Chocolatey v0.10.15 GoogleChrome 79.0.3945.117 [Approved] Downloads cached for licensed users vivaldi.install 2.10.1745.23 ... 생략 10 packages found. 예로 구글크롬 웹브라우저를 검색해 보면 10개의 패키지가 나옵니다. 그냥 chrome을 검색하면 백여개가 넘는 패키지가 목록이 나오게 됩니다.\n여기서 정확하게 필요한 패키지만을 보기 위해서는 -e 또는 --exact 옵션을 넣어 줘야 합니다.\n\u0026gt; choco search googlechrome -e Chocolatey v0.10.15 GoogleChrome 79.0.3945.117 [Approved] Downloads cached for licensed users 1 packages found. 그리고, 간혹 특정 버전의 패키지를 설치 해야 할 경우가 있습니다. 그럴 경우 버전을 확인하기 위해서는 -a, --all 옵션을 넣어 주면 버전 정보를 확인 할 수 있습니다.\n패키지 상세 정보 보기 info 명령어을 사요하거나 search에서 -v옵션을 추가해 주면 됩니다.\n그런데 info 명령어 search에서 -e 옵션이 붙은 것처럼 동작을 하게 됩니다.\n\u0026gt; choco info googlechrome Chocolatey v0.10.15 GoogleChrome 79.0.3945.117 [Approved] Downloads cached for licensed users Title: Google Chrome | Published: 2020-01-07 Package approved as a trusted package on 1 08 2020 01:22:22. ... 생략 또는\n\u0026gt; choco search googlechrome -ev Chocolatey v0.10.15 GoogleChrome 79.0.3945.117 [Approved] Downloads cached for licensed users Title: Google Chrome | Published: 2020-01-07 Package approved as a trusted package on 1 08 2020 01:22:22. ... 생략 여기서 -ev 로 옵션을 줬는데, 이건 -e -v를 하나로 요약한 형식입니다.\n패키지 설치 하기 install 명령을 이용해서 설치하고 싶은 패키지를 아래와 같이 설치 합니다.\n\u0026gt; choco install bandizip Chocolatey v0.10.15 Installing the following packages: bandizip ... 생략 Note: If you don\u0026#39;t run this script, the installation will fail. Note: To confirm automatically next time, use \u0026#39;-y\u0026#39; or consider: choco feature enable -n allowGlobalConfirmation Do you want to run the script?([Y]es/[A]ll - yes to all/[N]o/[P]rint): 명령어 프롬프트가 나오면 y를 눌러주면 간단하게 설치가 완료 됩니다.\n설치 시 자동으로 y를 누르고 싶다면 -y 옵션을 넣어 주면 됩니다. 그리고 강제로 설치하고 싶다면 -f를 넣어 주면 됩니다.\n\u0026gt; choco install -yf bandizip 혹시 특정 버전을 설치하고 싶다면 --version 옵션을 이용해서 해당 버전을 설치 할 수 있습니다.\nchoco install bandizip --version=6.24 패키지 삭제 하기 chocolatey는 설치된 패키지도 uninstall 명령어를 이용해서 편하게 삭제가 가능 합니다.\n\u0026gt; choco uninstall bandizip Chocolatey v0.10.15 Uninstalling the following packages: bandizip ... 생략 Do you want to run the script?([Y]es/[A]ll - yes to all/[N]o/[P]rint): 명령어 프롬프트가 나오면 y를 눌러주면 삭제가 됩니다.\ny키를 누르기 귀찮다면 설치 할 때와 같이 -yf를 누르시면 바로 삭제가 가능 합니다.\n\u0026gt; choco uninstall -yf bandizip choco로 설치된 패키지 목록 확인하기 search 또는 list명령로 확인 가능 합니다. 뒤에 -l 옵션을 주면 로컬에 설치된 패키지의 목록을 출력 해 줍니다.\n\u0026gt; choco search -l bandizip 6.25 ... 생략 zeal 0.6.1 zeal.install 0.6.1 62 packages installed. 또는 clist 명령어를 사용해서도 조회가 가능 합니다.\n\u0026gt; clist -l clist 명령은 choco search를 와 같은 역할을 합니다.\n패키지 업데이트 하기 upgrade 명령어를 통해서 패키지를 최신 버전으로 업데이트가 가능 합니다.\n\u0026gt; choco upgrade bandizip 혹시, choco를 통해서 설치한 프로그램을 모두 업데이트 하고 싶다면 패키지 이름 대신 all을 넣어 주면 됩니다.\n\u0026gt; choco upgrade all chocolatey 설치부터 패키지 설치까지 한방 스크립트 choco_install.bat라는 파일을 만들고 아래의 내용을 복사해서 넣어 주세요.\n그리고, 뒷 부분에 설치하고 싶은 패키지를 넣어 주시면 됩니다.\n@echo off CLS ECHO ************************************** ECHO * Start Chocolatey Batch ECHO ************************************** ::::::::::::::::::::::::::::::::::::::::: :: 체크 및 관리자 권한 가져 오기 NET FILE 1\u0026gt;NUL 2\u0026gt;NUL if \u0026#39;%errorlevel%\u0026#39; == \u0026#39;0\u0026#39; ( goto gotPrivileges ) else ( goto getPrivileges ) :getPrivileges ::::::::::::::::::::::::::::::::::::::::: :: UAC를 사용해서 관리자 권한으로 전환 if \u0026#39;%1\u0026#39;==\u0026#39;ELEV\u0026#39; (shift \u0026amp; goto gotPrivileges) ECHO. ECHO ************************************** ECHO * Use UAC, switch to admin ECHO ************************************** setlocal DisableDelayedExpansion set \u0026#34;batchPath=%~0\u0026#34; setlocal EnableDelayedExpansion ECHO Set UAC = CreateObject^(\u0026#34;Shell.Application\u0026#34;^) \u0026gt; \u0026#34;%temp%\\OEgetPrivileges.vbs\u0026#34; ECHO UAC.ShellExecute \u0026#34;!batchPath!\u0026#34;, \u0026#34;ELEV\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;runas\u0026#34;, 1 \u0026gt;\u0026gt; \u0026#34;%temp%\\OEgetPrivileges.vbs\u0026#34; \u0026#34;%temp%\\OEgetPrivileges.vbs\u0026#34; exit /B :gotPrivileges ::::::::::::::::::::::::::::::::::::::::: :: 시작 하기 setlocal \u0026amp; pushd . WHERE choco 1\u0026gt;NUL 2\u0026gt;NUL if \u0026#39;%errorlevel%\u0026#39; == \u0026#39;0\u0026#39; ( goto chocoInstalled ) else ( goto chocoMissing ) :chocoMissing :::::::::::::::::::::::::::: :: Chocolatey가 없을 경우 설치 :::::::::::::::::::::::::::: ECHO. choice /M \u0026#34;Chocolatey not found. Install now?\u0026#34; IF \u0026#39;%errorlevel%\u0026#39; == \u0026#39;2\u0026#39; exit /B ECHO. ECHO ************************************** ECHO * Chocolatey install ECHO ************************************** @powershell -NoProfile -ExecutionPolicy Bypass -Command \u0026#34;iex ((new-object net.webclient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;))\u0026#34; \u0026amp;\u0026amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin :chocoInstalled ECHO. ECHO ************************************** ECHO * Packages install ECHO ************************************** @echo on :: 항상 자동으로 yes를 선택하도록 설정 choco feature enable --name=allowGlobalConfirmation :: 먼저 기존 패키지 업데이트 choco upgrade all -y :: 사용할 어플리케이션 설치 set choco_install=choco install -fy %choco_install% bandizip %choco_install% firefox %choco_install% googlechrome %choco_install% vcredist140 %choco_install% vcredist2012 %choco_install% directx %choco_install% dotnetfx %choco_install% javaruntime %choco_install% everything %choco_install% wox %choco_install% qbittorrent %choco_install% f.lux %choco_install% typora %choco_install% freefilesync %choco_install% calibre %choco_install% notion %choco_install% vlc %choco_install% krita %choco_install% paint.net %choco_install% jbs %choco_install% ditto %choco_install% ccleaner.portable %choco_install% git.install --params \u0026#34;/GitAndUnixToolsOnPath /NoShellIntegration /NoGuiHereIntegration /WindowsTerminal\u0026#34; :: 항상 자동으로 yes를 선택하는 옵션 끄기 choco feature disable --name=allowGlobalConfirmation :: 업데이트 된 설정 다시 읽기 RefreshEnv.cmd pause choco_install.bat 파일을 실행했을때 관리자 권한이 아니면 관리자 권한을 부여해서 실행하게 됩니다.\n컴퓨터 설치를 자주 하시게 되는 분들은 위와 같이 파일을 하나 설정해 둔다면 유용하게 사용 할 수 있을 것이라고 생각 됩니다.\n","date":"2020-01-10","permalink":"/post/2020/2020-01-10-chocolatey_manual/","section":"post","summary":"Chocolatey는 윈도우용 패키지 매니저로, 설치하려는 윈도우용 소프트웨어를 일일이 웹사이트에서 찾아서 설치할 필요 없이 간단하게 커맨드 만으로 윈도우용 소프트웨어를 설치 할 수 있게 해 줍니다.\n","title":"윈도우용 패키지 매니저 Chocolatey 사용법"},{"content":"express를 import하면 아래와 같이 import 했을 겁니다.\nimport * as Express from \u0026#39;express\u0026#39;; 하지만 tsconfig.json 파일에 아래 내용을 추가 하면..\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, } } 이렇게 import가 가능해 집니다.\nimport Express from \u0026#39;express\u0026#39; ","date":"2019-12-19","permalink":"/post/2019/2019-12-19-typescript-default-import/","section":"post","summary":"express를 import하면 아래와 같이 import 했을 겁니다.\n","title":"Typescript에서 default import 개선.."},{"content":"먼저 띄운 화면을 보고 가시죠~\n캐릭터 얼굴이 마우스 움직이는 방향으로 움직입니다.\n너무 귀엽죠?\n그러면, 설치를 해 볼까요?\n먼저, 확장프로그램에서 live2d를 검색해서 설치해 줍니다.\n그리고 재실행을 해주시면, 아무것도 안 나옵니다. -_-;\nF1 또는 Ctrl+Shit+P을 누르고 live2d install을 해 줍니다. 그리고 다시 VSCode를 실행 해 줍니다.\n그러면, 고양이가 왼쪽 하단에 나옵니다.\n그리고, 나오는 경고\u0026hellip; 살포시 무시하기 위해서 고양이를 살짝 옮기시고, 기어 버튼을 누릅니다.\n그리고 그만볼래(Don't Show Again)을 눌러 줍니다.\n우리는 고양이에 만족 할 순 없으니.. 다른 캐릭터를 찾아 봅니다.\nhttps://github.com/summerscar/live2dDemo\n위 주소를 이동해서 쭈욱 보시면서 캐릭터를 선택 해 주시면 됩니다.\n그리고, 그 캐릭터는 아래 주소에서 테스트 해 보시면 됩니다.\nhttp://summerscar.me/live2dDemo/\n전 위에 캐릭터를 이용해서 표시를 했습니다.\n설정하는 방법은 약간 귀찮습니다.\nFile \u0026gt; Preferences \u0026gt; Settings를 선택 하거나 Ctrl+,으로 설정 화면을 들어 갑니다.\nLive2d를 검색 하시거나 직접 입력을 하시거나, 좌측 상단에 {}버튼을 누르셔서 코드를 넣어 주시면 됩니다.\n저 같은 경우는 위 기본 값에서 사이즈를 반으로 줄여서 넣어 봤습니다.\n{ \u0026#34;live2d.width\u0026#34;: 150, \u0026#34;live2d.height\u0026#34;: 200, \u0026#34;live2d.model\u0026#34;: \u0026#34;33.2017.newyear\u0026#34;, \u0026#34;live2d.headPos\u0026#34;: 0.5, \u0026#34;live2d.scale\u0026#34;: 1 } 하지만, 수정한다고 해서 바로 적용 되지 않습니다.\nF1 또는 Ctrl+Shit+P을 다시 누르고 live2d uninstall을 하고 다시 live2d install을 해 줘야 합니다.\n꼭!!! 지웠다가 다시 설치를 해야 적용이 됩니다.\n결과는 아래와 같습니다.\n참.. 이쁘죠? ㅎㅎㅎ\n","date":"2019-01-22","permalink":"/post/2019/2019-01-22-vscode-live2d/","section":"post","summary":"먼저 띄운 화면을 보고 가시죠~\n","title":"VSCode에 live2d 사용하기"},{"content":"Bridge Network 설치하기 전 kvm을 개발로 쓰면서 bridge network 형태로 자주 사용해서 먼저 bridge network를 설정 해 줍니다.\nkimchi를 설치 이후에 설정으로 추가해 주면\u0026hellip; 문제가 발생하면서 네트워크가 불능이 되어 버립니다.\n그래서 미리 설정을 해 줍니다.\n먼저 bridge-utils를 설치 해 줍니다.\nsudo apt install bridge-utils 그리고, /etc/netplan/50-cloud-init.yaml을 수정해 줍니다.\nsudo vi /etc/netplan/50-cloud-init.yaml 아래와 같이 입력 합니다.\nnetwork: ethernets: enp3s0: dhcp4: false bridges: br0: interfaces: - enp3s0 dhcp4: false addresses: - 192.168.1.200/24 gateway4: 192.168.1.200 nameservers: addresses: - 1.1.1.1 - 8.8.8.8 parameters: forward-delay: 0 stp: false optional: true version: 2 입력한 내용을 적용 합니다.\nsudo netplan apply 이제 네트워크에 잘 적용이 되었는지 확인 합니다.\n$ ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 5: br0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 4e:6a:7f:1e:e0:0e brd ff:ff:ff:ff:ff:ff inet 192.168.1.200/24 brd 192.168.1.255 scope global br0 valid_lft forever preferred_lft forever inet6 fe80::4c6a:7fff:fe1e:e00e/64 scope link valid_lft forever preferred_lft forever 6: wlp3s0: \u0026lt;BROADCAST,MULTICAST\u0026gt; mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 6c:71:d9:9a:4b:3b brd ff:ff:ff:ff:ff:ff 7: enp4s0f2: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel master br0 state UP group default qlen 1000 link/ether 00:90:f5:e7:6e:10 brd ff:ff:ff:ff:ff:ff Kimchi 설치하기 먼저 업데이트 할꺼와 업그레이드 할 꺼를 해 줍니다.\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 그리고 KVM을 설치하고 Kimchi와 Wok이 필요로 하는 패키지들을 설치해 줍니다.\nsudo apt install qemu qemu-kvm libvirt-bin \\ python-paramiko python-pil novnc python-libvirt \\ python-ethtool python-ipaddr python-guestfs \\ libguestfs-tools spice-html5 spice-html5 \\ python-magic keyutils libnfsidmap2 \\ libtirpc1 nfs-common rpcbind python-configobj \\ python-parted -y 혹시 패키지를 찾지 못한다면 Universe 저장소를 활성화 해 줘야 합니다.\nsudo add-apt-repository universe KVM 설치를 확인 합니다.\n$ kvm-ok INFO: /dev/kvm exists KVM acceleration can be used 정상적으로 설치가 되었다면 위와 같은 메시지가 나옵니다.\nnginx를 설치 합니다.\nsudo apt install nginx -y Kimchi의 최신 설치파일을 받아 옵니다.\n$ wget https://github.com/kimchi-project/kimchi/releases/download/2.5.0/wok-2.5.0-0.noarch.deb $ wget https://github.com/kimchi-project/kimchi/releases/download/2.5.0/kimchi-2.5.0-0.noarch.deb 먼저 wok을 설치를 합니다.\n$ sudo dpkg -i wok-2.5.0-0.noarch.deb $ sudo apt install -f -y 그리고, Kimchi를 설치 합니다. 그런데 그냥 설치 하면 python-imaging에서 문제가 발생 합니다. 그래서 python-imaging을 depends에서 제외하고 설치를 해 줍니다.\n$ sudo dpkg --ignore-depends=python-imaging -i kimchi-2.5.0-0.noarch.deb 만약에 UFW를 사용 한다면, 8001번 포트를 열어 줍니다.\n$ sudo ufw allow 8001/tcp 설치가 되었다면 재부팅해 줍니다.\n$ sudo reboot Kimchi 패키지 종속 문제 해결하기 우선 kimchi에서 python-imaging을 제거 해 줘야 합니다. 여기서는 python-imaging을 python-pil을 대체해 줍니다.\n먼저 아래와 같이 편집기를 띄워 줍니다.\n$ sudo vi /var/lib/dpkg/status /var/lib/dpkg/status 파일에서 package: kimchi를 검색해 보면\u0026hellip;\nPackage: kimchi Status: install ok installed Priority: optional Section: base Maintainer: Aline Manera \u0026lt;alinefm@br.ibm.com\u0026gt; Architecture: all Version: 2.5.0 Depends: wok (\u0026gt;= 2.1.0), python-imaging, python-configobj, novnc, python-jsonschema (\u0026gt;= 1.3.0), python-libvirt, gettext, libvirt-bin, nfs-common, qemu-kvm, python-parted, python-psutil (\u0026gt;= 0.6.0), python-ethtool, sosreport, python-ipaddr, python-lxml, open-iscsi, python-guestfs, libguestfs-tools, spice-html5, python-magic, python-paramiko Description: Kimchi web application Build-Depends: xsltproc, gettext, python-lxml Depends에 보시면, python-imaging이라고 되어 있습니다. 이걸 python-pil로 변경해 줍니다.\n웹 브라우저에서\nhttps://[서버 IP]:8001\n로 접속을 해 접속 해 봅니다. 꼭 https로 해야 접속이 됩니다. http를 하면 400번 에러만 보게 됩니다.\n웹 브라우저에서 보안상 어쩌구 해서 무시하고 처음 접속을 하면 되면 8010포트로 이동을 하게 됩니다.\n이때는 그냥.. 살며시 무시하고 url의 포트를 8001로 변경 해 주세요.\n그리고 나면 Wok을 로그인 하면이 나옵니다.\n여기서 사용자의 이름은 패스워드는 우분투의 계정을 넣어 주시면 됩니다.\n여기까지 하면 한 고비를 남겨서 잘 동작하는 화면을 볼 수 있습니다.\nUbuntu 18.04 서버 설치 하기 먼저 ubuntu 18.04의 이미지를 받아 줍니다.\n$ cd /var/lib/kimchi/isos $ sudo wget http://releases.ubuntu.com/18.04.1/ubuntu-18.04.1-live-server-amd64.iso 이미지가 다 받아 지면 Vitualization \u0026gt; Templates 에서 + Add Template 버튼을 누르면 제일 처음에 Ubuntu 18.04가 보입니다.\n하지만, 아직 이미지를 쓰진 못 합니다. ㅜ.ㅜ\nKCHTMPL0020E: Unable to create template due error: KCHIMG0001E: Error probing image OS information: part_list: parted print: /dev/sda: Warning: The driver descriptor says the physical block size is 2048 bytes, but Linux says it is 512 bytes.\nUbuntu 18.04 이미지 오류 수정하기 이미지를 템플릿으로 추가 하려면 위와 같이 메시지가 나옵니다.\n여기서 다시 편집이 들어가야 합니다.\n$ sudo vi /usr/lib/python2.7/dist-packages/wok/plugins/kimchi/model/templates.py 먼저 아래와 같은 라인을 찾습니다. 제가 쓰는 버전에서는 42라인입니다.\nISO_TYPE = \u0026#34;ISO 9660 CD-ROM\u0026#34; 이걸 아래와 같이 변경해 줍니다.\nISO_TYPE = [\u0026#34;DOS/MBR\u0026#34;, \u0026#34;ISO 9660 CD-ROM\u0026#34;] 그리고 다시 아래와 같은 줄을 찾아 줍니다.\nif ISO_TYPE in ftype: 위 라인을 아래와 같이 바꿔 줍니다.\niscdrom = [t for t in ISO_TYPE if t in ftype] if iscdrom: 여기서 수정 할 때 주의 해야 할 점은 python이라서 공백에 민감합니다. 꼭 공백을 맞춰서 넣어 주세요.\npython을 약간만 보셨다면 어렵지 않게 하실 수 있을 겁니다.\n그리고 재부팅을 해 줍니다.\n$ sudo reboot 포트를 443으로 변경해 주기 인증서는 없지만, 그래도 443으로 변경해 주면 포트를 안 써줘도 되니.. 변경 해 줍니다.\nNginx 설정 변경하기 $ sudo vi /etc/nginx/conf.d/wok.conf 아래과 같은 2라인을 찾습니다.\n.... listen 0.0.0.0:8001 ssl; .... proxy_redirect http://127.0.0.1:8010/ https://$host:8001/; .... 내용을 아래와 같이 변경 합니다.\n.... listen 0.0.0.0:443 ssl; .... proxy_redirect http://127.0.0.1:8010/ https://$host:443/; .... Wok 설정 변경하기 $ sudo vi /etc/wok/wok.conf 아래과 같은 라인을 찾습니다.\n.... #proxy_port = 8001 .... 아래과 같이 변경 해 줍니다.\n.... proxy_port = 443 .... 참고 Ubuntu server 18.04 as a Hypervisor using KVM and Kimchi for VM Management Ubuntu 18.04 Server + LXDでブリッジ接続する ","date":"2019-01-04","permalink":"/post/2019/2019-01-04-ubuntu-1804-kimchi-install/","section":"post","summary":"Bridge Network 설치하기 전 kvm을 개발로 쓰면서 bridge network 형태로 자주 사용해서 먼저 bridge network를 설정 해 줍니다.\n","title":"우분투 18.04에서 kimchi 설치 하기"},{"content":"17.10부터 네트워크 인터페이스 설정이 netplan이라는 새로운 네트워크 설정이 생겼다. 기존에 인터페이스 설정(/etc/network/interfaces)보다는 간결해 보입니다.\n변경 할 파일은 아래와 같습니다.\nsudo vi /etc/netplan/50-cloud-init.yaml 기본적으로 dhcp로 설치 했을 경우 아래와 같이 나옵니다.\nnetwork: ethernets: enp4s0f2: addresses: [] dhcp4: true version: 2 그 내용을 아래와 같이 ip와 정보를 넣고 설정 해 주면 됩니다.\nnetwork: ethernets: enp4s0f2: dhcp4: no addresses: [192.168.1.200/24] gateway4: 192.168.1.1 nameservers: addresses: [1.1.1.1,8.8.8.8,8.8.4.4] version: 2 그리고 변경 된 내용을 아래와 같이 적용 합니다.\nsudo netplan apply 변경된 내용을 ifconfig로 확인 하면 됩니다.\n$ ifconfig enp4s0f2: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.1.200 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::290:f5ff:fee7:6e10 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 00:90:f5:e7:6e:10 txqueuelen 1000 (Ethernet) RX packets 89208 bytes 132983451 (132.9 MB) RX errors 0 dropped 9 overruns 0 frame 0 TX packets 55318 bytes 4234704 (4.2 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 252 bytes 19812 (19.8 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 252 bytes 19812 (19.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 그런데.. dhcp4가 true이다가.. 끌때는 no로 변경 되어서.. 오타인가 찾아 봤는데..\n모두 그렇게 사용하고 있네요.. 흠\u0026hellip;..\n이상하지만 잘 동작 합니다. -_-;;;\n","date":"2019-01-04","permalink":"/post/2019/2019-01-04-ubuntu-1804-static-ip/","section":"post","summary":"17.10부터 네트워크 인터페이스 설정이 netplan이라는 새로운 네트워크 설정이 생겼다. 기존에 인터페이스 설정(/etc/network/interfaces)보다는 간결해 보입니다.\n","title":"Ubuntu 18.04에서 netplan을 사용한 static ip 설정"},{"content":"먼저 터미널에서 아래와 같은 파일을 열어 줍니다.\nsudo vi /etc/systemd/logind.conf 파일에서 #HandleLidSwitch=suspend로 되어 있는 곳의 샵(#) 주석을 제거 하고 HandleLidSwitch=ignore 이렇게 변경해 줍니다.\n# This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version. # # Entries in this file show the compile time defaults. # You can change settings by editing this file. # Defaults can be restored by simply deleting this file. # # See logind.conf(5) for details. [Login] #NAutoVTs=6 #ReserveVT=6 #KillUserProcesses=no #KillOnlyUsers= #KillExcludeUsers=root #InhibitDelayMaxSec=5 #HandlePowerKey=poweroff #HandleSuspendKey=suspend #HandleHibernateKey=hibernate HandleLidSwitch=ignore #HandleLidSwitchDocked=ignore #PowerKeyIgnoreInhibited=no #SuspendKeyIgnoreInhibited=no #HibernateKeyIgnoreInhibited=no #LidSwitchIgnoreInhibited=yes #HoldoffTimeoutSec=30s #IdleAction=ignore #IdleActionSec=30min #RuntimeDirectorySize=10% #RemoveIPC=yes #InhibitorsMax=8192 #SessionsMax=8192 #UserTasksMax=33% 그리고 서비스를 재실행 해 줍니다.\nsystemctl restart systemd-logind.service ","date":"2019-01-04","permalink":"/post/2019/2019-01-04-ubuntu-server-labtop-cover/","section":"post","summary":"먼저 터미널에서 아래와 같은 파일을 열어 줍니다.\n","title":"우분투 노트북 서버 사용시 커버를 덮어도 잠들지 않도록 하기"},{"content":"먼저 기존에 설치된 openssh를 삭제하고 다시 설치해야 합니다.\n그리고, sshd_config에서 port를 22번 말고 다른 포트로 변경해 줘야 합니다.\n기본으로는 Port 22는 주석처리 되어 있습니다. 주석처리를 지우고 변경합니다.\n이유는, 윈도우에서 이미 22번 포트를 사용하고 있기 때문입니다. 만약에 꼭 22번을 쓰고 윈도우에서 사용하는 22번 포트를 disable하고 써야 합니다.\n정리하면 아래와 같습니다.\nsudo apt-get remove --purge openssh-server sudo apt-get install openssh-server sudo vi /etc/ssh/sshd_config # Change Port from 22 to 222 sudo service ssh --full-restart ","date":"2018-11-23","permalink":"/post/2018/2018-11-23-windows10-subsystem-openssh/","section":"post","summary":"먼저 기존에 설치된 openssh를 삭제하고 다시 설치해야 합니다.\n","title":"Windows 10 subsystem Ubuntu에서 ssh 설치 하기"},{"content":"express를 타입스크립트롤 시작하는 방법을 설명합니다.\n기본 패키지 설정 package.json 파일을 만들어 줍니다.\nnpm init -y express에 필요한 패키지를 설치해 줍니다.\nyarn add express body-parser Typescript 설정 typescript에 사용할 패키지를 설치 합니다.\nyarn add --dev typescript ts-loader ts-node tslint @types/node @types/express typescript에 필요한 내용을 설치 합니다. 그리고 tsconfig.json파일을 아래와 같이 입력 해 줍니다.\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34; }, \u0026#34;exclude\u0026#34;: [ \u0026#34;node_modules\u0026#34; ] } Webpack 설정 yarn add --dev webpack webpack-watch-server webpack.config.js 파일을 아래와 같이 입력 합니다.\nvar path = require(\u0026#39;path\u0026#39;); module.exports = { entry: \u0026#39;./src/index.ts\u0026#39;, target: \u0026#39;node\u0026#39;, output: { filename: \u0026#39;index.js\u0026#39;, path: path.resolve(__dirname, \u0026#39;dist\u0026#39;) }, devtool: \u0026#39;source-map\u0026#39;, resolve: { // Add `.ts` and `.tsx` as a resolvable extension. extensions: [\u0026#39;.ts\u0026#39;, \u0026#39;.tsx\u0026#39;, \u0026#39;.js\u0026#39;] }, module: { rules: [ // all files with a `.ts` or `.tsx` extension will be handled by `ts-loader` { test: /\\.tsx?$/, loader: \u0026#39;ts-loader\u0026#39; } ] } }; Express 기본 제작 src/index.ts파일을 아래와 같이 작성 합니다.\nimport * as bodyParser from \u0026#34;body-parser\u0026#34;; import * as express from \u0026#34;express\u0026#34;; import { Request, Response } from \u0026#34;express\u0026#34;; import * as http from \u0026#39;http\u0026#39;; var app:express.Application = express(); app.get(\u0026#39;/\u0026#39;, (req: Request, res: Response) =\u0026gt; { res.status(200).json({status: \u0026#34;ok\u0026#34;}); }); let httpPort = 3000; app.set(\u0026#34;port\u0026#34;, httpPort); var httpServer = http.createServer(app); //listen on provided ports httpServer.listen(httpPort, (data) =\u0026gt; { console.log(`Listening on port ${httpPort}`) }); 위 내용은 github에 올려져 있습니다.\n","date":"2018-11-13","permalink":"/post/2018/2018-11-13-express-typescript-webpack/","section":"post","summary":"express를 타입스크립트롤 시작하는 방법을 설명합니다.\n","title":"Express Typescript Webpack"},{"content":"hugo 설치 하기 Install Hugo를 보고 하면 됩니다. 전 ubuntu를 쓰고 있는 관계로.. 간단하게..\nsudo apt install hugo 이렇게 하면 간단하게 설치가 되네요..\n사이트 만들기 $ hugo new site blog Congratulations! Your new Hugo site is created in /home/gyuha/workspace/temp/blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/, or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. $ cd blog 사이트 실행해 보기 $ hugo server ERROR 2018/11/07 00:33:28 port 1313 already in use, attempting to use an available port | EN +------------------+----+ Pages | 3 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 10 ms Watching for changes in /home/gyuha/workspace/temp/blog/{content,data,layouts,static} Watching for config changes in /home/gyuha/workspace/temp/blog/config.toml Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 웹브라우저에서 http://localhost:1313 으로 실행 해 보면 아무것도 안 나온다..\n테마 설치 하기 이 사이트에서 사용한 스킨을 설치해 보겠습니다.\n먼저 git init으로 초기화를 해 주고 테마를 받습니다.\ngit init cd themes git submodule add https://github.com/halogenica/beautifulhugo.git beautifulhugo cd .. 다시 hugo server 를 해 보면.. 아직도 아무것도 나오지 않습니다.\n설정 데이터가 없어서 그럽니다.\ncp themes/beautifulhugo/exampleSite/config.toml . hugo server -D 이렇게 하고 http://localhost:1313으로 실행하면 정상적으로 사이트가 나오는 것을 확인 할 수 있습니다.\n그리고, -D 옵션을 넣어 줘야 갱신된 글이 보입니다.\nconfig.toml을 내가 원하는 형태로 수정해 줍니다.\n새글 추가 하기 hugo new post/2018-11-11-start-blog.md 위와 같이 추가 하면 새 글이 추가 됩니다.\nGitHub에 올리기 Host on GitHub를 참고 하면 됩니다. Makefile 위 과정을 매번 치기 귀찮아서.. makefile로 만들어 봤음\u0026hellip;\nHUGO = hugo COMMIT_MESSAGE = \u0026#34;rebuilding site $(shell date +%Y-%m-%d)\u0026#34; run: $(HUGO) server -D clone: rm -rf public git clone https://github.com/\u0026lt;USERNAME|ORGANIZATION\u0026gt;/\u0026lt;USERNAME|ORGANIZATION\u0026gt;.github.io.git mv gyuha.github.io public new: $(HUGO) new post/$(shell date +%Y-%m-%d)-$(title).md deploy: echo \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. $(HUGO) -D cd ./public \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m $(COMMIT_MESSAGE) \u0026amp;\u0026amp; git push 참고 소스 : https://github.com/gyuha/blog ","date":"2018-11-07","permalink":"/post/2018/2018-11-07-hugo-github/","section":"post","summary":"hugo 설치 하기 Install Hugo를 보고 하면 됩니다. ","title":"Hugo를 사용한 Github 블로그.."},{"content":"serverless에서 webpack을 이용해서 typescript를 구성해 보면서 작업 하던걸 기록 해 둡니다.\n기본 환경 구성 기본적으로 node.js가 설치 되어 있어야 합니다.\nserverless를 설치 합니다.\nnpm install -g serverless 그리고, 프로젝트를 생성해 줍니다.\n$ serverless create -t aws-nodejs -p hello-lambda Serverless: Generating boilerplate... Serverless: Generating boilerplate in \u0026#34;/home/gyuha/workspace/hello-lambda\u0026#34; _______ __ | _ .-----.----.--.--.-----.----| .-----.-----.-----. | |___| -__| _| | | -__| _| | -__|__ --|__ --| |____ |_____|__| \\___/|_____|__| |__|_____|_____|_____| | | | The Serverless Application Framework | | serverless.com, v1.32.0 -------\u0026#39; Serverless: Successfully generated boilerplate for template: \u0026#34;aws-nodejs\u0026#34; $ cd hello-lambda npm init으로 package.jon을 설정해 주고 필요한 패키지를 설치 해 줍니다.\n$ npm init $ npm install --save-dev serverless-webpack serverless-offline ts-loader typescript webpack Severless 설정하기 serverless.yml 파일을 아래와 같이 편집 해 줍니다.\nservice: aws-nodejs # NOTE: update this with your service name provider: name: aws runtime: nodejs8.10 stage: dev region: ap-northeast-2 plugins: - serverless-webpack - serverless-offline functions: hello: handler: src/server.hello events: - http: path: hello method: get 여기서, 주 된 내용은 plugins의 추가와 functions에서 events의 추가 입니다.\nTypescript과 Webpack 설정하기 tsconfig.json 파일을 만들고 아래와 같이 입력해 줍니다.\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, \u0026#34;sourceMap\u0026#34;: true }, \u0026#34;exclude\u0026#34;: [ \u0026#34;node_modules\u0026#34; ] } webpack.copnfg.js 파일을 만들고 아래와 같이 입력해 줍니다.\nconst path = require(\u0026#34;path\u0026#34;); module.exports = { entry: path.join(__dirname, \u0026#34;src/server.ts\u0026#34;), output: { libraryTarget: \u0026#34;commonjs\u0026#34;, filename: \u0026#34;src/server.js\u0026#34;, path: path.resolve(__dirname, \u0026#34;dist\u0026#34;) }, module: { rules: [ { test: /\\.tsx?$/, loader: \u0026#34;ts-loader\u0026#34;, exclude: /node_modules/ } ] }, resolve: { extensions: [\u0026#34;.tsx\u0026#34;, \u0026#34;.ts\u0026#34;, \u0026#34;.js\u0026#34;] } }; 소스 작성 해 주기 src/server.ts 파일을 생성하고 아래과 같이 입력 해 줍니다.\ninterface SomeResponse { statusCode: number; body: string; } export async function hello (event: any, context: any) { const response: SomeResponse = { statusCode: 200, body: JSON.stringify({ message: Math.floor(Math.random() * 10) }) }; return response }; 여기까지 완료 하면.. 기본 실행이 구성 됩니다.\n오프라인 실행하기 sls offline 배포 하기 sls deploy 예제 코드는 serverless-typescript-webpack에서 볼 수 있습니다.\n","date":"2018-11-06","permalink":"/post/2018/2018-11-06-typescript-webpack-serverless/","section":"post","summary":"serverless에서 webpack을 이용해서 typescript를 구성해 보면서 작업 하던걸 기록 해 둡니다.\n","title":"Typescript Webpack Serverless 구성하기"}]